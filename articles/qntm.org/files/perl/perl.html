<!Doctype html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
                <meta name="description" content="2時間半で学べるPerlのチュートリアル">
                <!-- linkto: http://yahoo.co.jp/ -->
		<title>2時間半で学ぶPerl</title>

		<style type="text/css">
			body {
				padding: 2em;
				font-family: Tahoma;
			}
			pre {
				margin-left: 2em;
			}
			pre, tt {
				color: #348275;
			}
		</style>
	</head>

	<body>
<h1 class="original">Learn Perl in about 2 hours 30 minutes</h1>
<h1>2時間半で学ぶPerl</h1>
<h2><a href="http://qntm.org/perl">By Sam Hughes</a></h2>

<p class="original">Perl is a dynamic, dynamically-typed, high-level, scripting (interpreted) language most comparable with PHP and Python. Perl's syntax owes a lot to ancient shell scripting tools, and it is famed for its overuse of confusing symbols, the majority of which are impossible to Google for. Perl's shell scripting heritage makes it great for writing <i>glue code</i>: scripts which link together other scripts and programs. Perl is ideally suited for processing text data and producing more text data. Perl is widespread, popular, highly portable and well-supported. Perl was designed with the philosophy "There's More Than One Way To Do It" (TMTOWTDI) (contrast with Python, where "there should be one - and preferably only one - obvious way to do it").</p>

<p>Perlは動的な、動的型付けの、高級な、スクリプト(インタープリタで解釈される)言語で、PHPやPythonとともによく比較されます。Perlのシンタックスは、昔のshellスクリプトツールから多くの部分を借りており、それにより混乱させるシンボルを使い過ぎていることで有名です。それらの大多数をGoogleで検索することは不可能です。Perlのshellスクリプトから受け継いだ遺産は、<i>glueコード</i>(他のスクリプトやプログラムと一緒にリンクされているスクリプト)を書くのに、大変役に立ちます。Perlは、理想的にテキストデータを処理することや、テキストデータを生み出すことに適しています。Perlは広く行き渡り、有名であり、極めてポータブルで、十分にサポートされています。Perlは"There's More Than One Way To Do It(やり方はひとつじゃない)" (TMTOWTDI)の哲学でデザインされました(Pythonと比較すると、"there should be one - and preferably only one - obvious way to do it(明らかなやり方は、ひとつであるべきであり、むしろひとつのみであるべき)")。</p>

<p class=original>Perl has horrors, but it also has some great redeeming features. In this respect it is like every other programming language ever created.</p>
<p>Perlには恐ろしいところがありますが、それを補って余りあるところもあります。その点で、今までに作られた全ての他のプログラミング言語と同じです。</p>
<p class=original>This document is intended to be informative, not evangelical. It is aimed at people who, like me:</p>
<p>このドキュメントは、情報を与えることを意図しており、熱心に普及させるものではありません。以下のような、私のような人向けのものです:</p>
<ul class=original>
	<li>dislike the official Perl documentation at <a href="http://perl.org">http://perl.org/</a> for being intensely technical and giving far too much space to very unusual edge cases</li>
	<li>learn new programming languages most quickly by "axiom and example"</li>
	<li>wish Larry Wall would get to the point</li>
	<li>already know how to program in general terms</li>
	<li>don't care about Perl beyond what's necessary to get the job done.</li>
</ul>

<ul>
	<li>技術的過ぎて、一般的ではないエッジケースに多くの部分を割いている<a href="http://perl.org">http://perl.org/</a>にある、公式のPerlのドキュメントが嫌い</li>
	<li>"原理と例"でさっさと学びたい</li>
	<li>Larry Wallにはっきり言ってほしい</li>
	<li>一般的な用語でプログラムすることをすでに知っている</li>
	<li>仕事を終えるために何が必要かということ以上のことをPerlについて気にしない</li>
</ul>

<p class=original>This document is intended to be as short as possible, but no shorter.</p>

<p>このドキュメントは可能な限り短くしていますが、足らないことのないようにしています。</p>

<h2 class=original>Preliminary notes</h2>
<h2>前書き</h2>
<ul class=original>
<li><p>The following can be said of almost every declarative statement in this document: "that's not, strictly speaking, true; the situation is actually a lot more complicated". I've deliberately omitted or neglected to bother to research the "full truth" of the matter for the same reason that there's no point in starting off a Year 7 physics student with the Einstein field equations. If you see a serious lie, point it out, but I reserve the right to preserve certain critical lies-to-children.</p></li>
<li><p>Throughout this document I'm using example <tt>print</tt> statements to output data but not explicitly appending line breaks. This is done to prevent me from going crazy and to give greater attention to the actual string being printed in each case, which is invariably more important. In many examples, this results in alotofwordsallsmusheduptogetherononeline if the code is run in reality. Try to ignore this. Or, in your head or in practice, set <tt>$\</tt> (also known as <tt>$OUTPUT_RECORD_SEPARATOR</tt>) to <tt>"\n"</tt>, which adds the line breaks automatically. Or substitute the <tt>say</tt> function.</p></li>
<li><p>Perl docs all have short, memorable names, such as <a href="http://perldoc.perl.org/perlsyn.html">perlsyn</a> which explains Perl syntax, <a href="http://perldoc.perl.org/perlop.html">perlop</a> (operators/precedence), <a href="http://perldoc.perl.org/perlfunc.html">perlfunc</a> (built-in functions) et cetera. <strong><a href="http://perldoc.perl.org/perlvar.html">perlvar</a> is the most important of these</strong>, because this is where you can look up un-Googlable variable names like <tt>$_</tt>, <tt>$"</tt> and <tt>$|</tt>.</p></li>
</ul>

<ul>
<li><p>以下のことを、このドキュメント内のほとんどすべての宣言文で言うことが出来ます: "これは、厳格な意味での、真実ではありません; 状況は実際にはもっと複雑です"。私は故意に問題の"完全な真実"をわざわざ調べることを、省略したり、無視していますが、それは、アインシュタインの場の方程式で7年生の物理学の学生を始めるのに意味がないのと同じ理由です。もし深刻な嘘を見つけたら、指摘してください。ですが、私には子どもにつく重要な嘘をそのままにしておく権利があります。</p></li>
<li><p>このドキュメントを通して、例において<tt>print</tt>ステートメントをデータを出力するために使っていますが、明示的に改行を追加していません。
これは、私を気違いにさせないためであり、それぞれのケースで出力される、より重要な実際の文字列に多くの注意を向けさせるためです。多くの例で、実際にコードを動かすと、alotofwordsallsmusheduptogetherononelineのような結果になります。無視してください、または、頭の中で、練習で、<tt>$\</tt>(<tt>$OUTPUT_RECORD_SEPARATOR</tt>とも言う)を、<tt>"\n"</tt>にしてください。これで、行末に改行が自動的に追加されます。または、代わりに、<tt>say</tt>関数を使ってください。</p></li>
<li><p>Perlのドキュメントはすべて、短く、記憶に残る名前になっています。例えば<a href="http://perldoc.jp/docs/perl/5.14.1/perlsyn.pod">perlsyn</a>は、Perlのシンタックスを説明しています, <a href="http://perldoc.jp/docs/perl/5.14.1/perlop.pod">perlop</a> (オペレータ/優先順位), <a href="http://perldoc.jp/docs/perl/5.14.1/perlfunc.pod">perlfunc</a> (組込関数) など。 <strong><a href="http://perldoc.jp/docs/perl/5.14.1/perlvar.pod">perlvar</a> はそれらの中で最も重要なものです。</strong>なぜなら、そこには、Googleで検索できない<tt>$_</tt>, <tt>$"</tt> and <tt>$|</tt>のような変数名があるからです。</p></li>
</ul>

<h2 class="original">Hello world</h2>

<h2>Hello world</h2>

<p class=original>A Perl <i>script</i> is a text file with the extension <tt>.pl</tt>.</p>
<p>Perl<i>スクリプト</i>は<tt>.pl</tt>という拡張子のテキストファイルです。</p>
<p class=original>Here's the full text of <tt>helloworld.pl</tt>:</p>
<p><tt>helloworld.pl</tt>は以下のようになります:</p>
<pre class="perl prettyprint">
use strict;
use warnings;

print "Hello world";
</pre>
<p class=original>Perl has no explicit compilation step (there <em>is</em> a "compilation" step, but it is performed automatically before execution and no compiled binary is generated). Perl scripts are interpreted by the Perl interpreter, <tt>perl</tt> or <tt>perl.exe</tt>:</p>
<p>Perlには、明確なコンパイルステップはありません("コンパイル"は<em>あります</em>。ですが、それは実行前に自動的に行われ、コンパイルされたバイナリは作られません)。 PerlスクリプトはPerlインタープリタ、<tt>perl</tt>か<tt>perl.exe</tt>で解釈されます:</p>

<pre class="bash">
perl helloworld.pl [arg0 [arg1 [arg2 ...]]]
</pre>
<p class=original>A few immediate notes. Perl's syntax is highly permissive and it will allow you to do things which result in ambiguous-looking statements with unpredictable behaviour. There's no point in me explaining what these behaviours are, because you want to avoid them. The way to avoid them is to put <tt>use strict; use warnings;</tt> at the very top of every Perl script or module that you create. Statements of the form <tt>use</tt> <i>&lt;whatever&gt;</i> are <i>pragmas</i>. A pragma is a signal to the Perl compiler, and changes the way in which the initial syntactic validation is performed. These lines take effect at compile time, and have no effect when the interpreter encounters them at run time.</p>

<p>当面のメモとしていくつか。Perlのシンタックスはかなり寛大なので、結果として振る舞いを予測できない曖昧に見えるようなセンテンスを書くことをあなたに許します。私にとっては意味がないので、それらの振る舞いに関して説明しません。なぜなら、あなたはそれらを避けたいでしょうから。それらを避ける方法は、<tt>use strict;use warnings;</tt>を、あなたの作る全てのperlスクリプトやモジュールの上の方に置くことです。<tt>use</tt> <i>&lt;何でも&gt;</i>のステートメントは<i>プラグマ</i>です。プラグマはPerlコンパイラーへのシグナルです。最初のシンタックスチェックをする方法を変更します。これらの行はコンパイル時に影響し、実行時にはインタープリタが出くわしても影響を受けません。</p>
<p class="original">The symbol <tt>#</tt> begins a comment. A comment lasts until the end of the line. Perl has no block comment syntax.</p>
<p>シンボル<tt>#</tt>はコメントの開始です。コメントは行末で終わります。Perlには、ブロックコメントのシンタックスはありません。</p>

<h2 class="original">Variables</h2>

<h2>変数</h2>

<p class=original>Perl variables come in three types: <i>scalars</i>, <i>arrays</i> and <i>hashes</i>. Each type has its own <i>sigil</i>: <tt>$</tt>, <tt>@</tt> and <tt>%</tt> respectively. Variables are declared using <tt>my</tt>.</p>

<p>Perlの変数には次の3タイプあります: <i>スカラ</i>、<i>配列</i>、 <i>ハッシュ</i>です. それぞれのタイプには、自身の<i>シジル(sigil)</i>があります: それぞれ、<tt>$</tt>, <tt>@</tt> and <tt>%</tt>。 変数は<tt>my</tt>で宣言されます。</p>

<h3 class=original>Scalar variables</h3>

<h3>スカラ変数</h3>

<p class=original>A scalar variable can contain:</p>
<p>スカラ変数は以下のものを格納できます:</p>
<ul class=original>
	<li><tt>undef</tt> (corresponds to <tt>None</tt> in Python, <tt>null</tt> in PHP)</li>
	<li>a number (Perl does not distinguish between an integer and a float)</li>
	<li>a string</li>
	<li>a reference to any other variable.</li>
</ul>
<ul class=original>
	<li><tt>undef</tt> (Pythonにおける<tt>None</tt>、PHPの<tt>null</tt>に対応)</li>
	<li>数字 (Perlはintegerとfloatを区別しません)</li>
	<li>文字</li>
	<li>他の変数へのリファレンス</li>
</ul>

<pre class="perl original">
my $undef = undef;
print $undef; # warning

# implicit undef:
my $undef2;
print $undef2; # exactly the same warning
</pre>

<pre class="perl prettyprint">
my $undef = undef;
print $undef; # warning

# implicit undef:
my $undef2;
print $undef2; # まったく同じwarning
</pre>

<pre class="perl prettyprint">
my $num = 4040.5;
print $num; # "4040.5"
</pre>

<pre class="perl prettyprint">
my $string = "world";
print $string; # "world"
</pre>

<p class=original>(References are coming up shortly.)</p>
<p>(リファレンスは後で説明します)</p>

<p class=original>String concatenation using the <tt>.</tt> operator (same as PHP):</p>
<p>文字列の連結には<tt>.</tt>演算子を使います(PHPと同じ):</p>
<pre class="perl prettyprint">
print "Hello ".$string; # "Hello world"
</pre>

<p class=original>String concatenation by passing multiple arguments to <tt>print</tt>:</p>
<p>複数の引数を<tt>print</tt>に渡すことで文字列を連結できます:</p>
<pre class="perl prettyprint">print "Hello ", $string; # "Hello world"</pre>

<p class=original><strong>It is impossible to determine whether a scalar contains a "number" or a "string".</strong> More precisely, it is irrelevant. Perl is weakly typed in this respect. Whether a scalar behaves like a number or a string depends on the operator with which it is used. When used as a string, a scalar will behave like a string. When used as a number, a scalar will behave like a number (or raise a warning if this isn't possible):</p>

<p><strong>スカラーに"数字"か"変数"のいずれかが入っているのかを判断することはできません。</strong> より正確には、そんなことは見当違いです。Perlはその点で弱い型付けです。 スカラが数字か文字のどちらかのように振舞うかは、使われる演算子によります。文字列として使えば、スカラは文字列のようにふるまいます。数字として使えば、スカラは数字のようにふるまいます(また、そうすることが出来なければ、警告を発します):</p>

<pre class="perl prettyprint">
my $str1 = "4G";
my $str2 = "4H";

print $str1 .  $str2; # "4G4H"
print $str1 +  $str2; # "8" with two warnings
print $str1 eq $str2; # "" (empty string, i.e. false)
print $str1 == $str2; # "1" with NO WARNING!
</pre>

<p class=original>The lesson is to always using the correct operator in the correct situation. There are separate operators for comparing scalars as numbers and comparing scalars as strings:</p>
<p>このレッスンでは、正しい状況で正しい演算子を使うようにしています。数字としてスカラを比較するのと、文字列としてスカラを比較するのとでは、演算子を区別します。:</p>

<pre class="perl original">
# Numerical operators:  &lt;,  &gt;, &lt;=, &gt;=, ==, !=, &lt;=&gt;
# String operators:    lt, gt, le, ge, eq, ne, cmp
</pre>

<pre class="perl prettyprint">
# 数字用の演算子:  &lt;,  &gt;, &lt;=, &gt;=, ==, !=, &lt;=&gt;
# 文字用の演算子:    lt, gt, le, ge, eq, ne, cmp
</pre>

<p class=original><strong>Perl has no boolean data type.</strong> A scalar in an <tt>if</tt> statement evaluates to boolean "false" if and only if it is one of the following:</p>

<p><strong>Perlにはブーリアンのデータ型はありません。</strong> <tt>if</tt>ステートメントではスカラは、以下のいずれかの場合にのみ"偽"として評価されます:</p>

<ul>
	<li><tt>undef</tt></li>
	<li>number <tt>0</tt></li>
	<li>string <tt>""</tt></li>
	<li>string <tt>"0"</tt>.</li>
</ul>

<p class=original>The Perl documentation <em>repeatedly</em> claims that functions return "true" or "false" values in certain situations. In practice, when a function is claimed to return "true" it usually returns <tt>1</tt>, and when it is claimed to return false it usually returns the empty string, <tt>""</tt>.</p>

<p>Perlのドキュメントでは、<em>繰り返し</em>、特定の状況で"真"か"偽"の値を関数が返すように主張しています。実際には、
関数が真を返すように主張しているときは、普通<tt>1</tt>を返します。また、関数が偽を返すように主張しているなら、普通は空文字<tt>""</tt>を返します。</p>

<h3 class=original>Array variables</h3>
<h3>配列変数</h3>

<p class=original>An array variable is a list of scalars indexed by integers beginning at 0. In Python this is known as a <i>list</i>, and in PHP this is known as an <i>array</i>.</p>
<p>配列変数は整数の0で始まるはじまるインデックスされたスカラです。Pythonでは、<i>list</i>で、PHPでは、<i>array</i>です。</p>

<pre class="perl original">
my @array = (
	"print",
	"these",
	"strings",
	"out",
	"for",
	"me", # trailing comma is okay
);
</pre>

<pre class="perl prettyprint">
my @array = (
	"print",
	"these",
	"strings",
	"out",
	"for",
	"me", # カンマを最後に続けても問題ありません
);
</pre>

<p class=original>You have to use a dollar sign to access a value from an array, because the value being <em>retrieved</em> is not an array but a scalar:</p>

<p>配列から値にアクセスするときにはドル記号を使わなければいけません。<em>取られる</em>値は配列ではなく、スカラだからです:</p>

<pre class="perl prettyprint">
print $array[0]; # "print"
print $array[1]; # "these"
print $array[2]; # "strings"
print $array[3]; # "out"
print $array[4]; # "for"
print $array[5]; # "me"
print $array[6]; # warning
</pre>

<p class=original>You can use negative indices to retrieve entries starting from the end and working backwards:</p>
<p>負のインデックスを、後ろから値を取るのに使えます。逆向きになります:</p>

<pre class="perl prettyprint">
print $array[-1]; # "me"
print $array[-2]; # "for"
print $array[-3]; # "out"
print $array[-4]; # "strings"
print $array[-5]; # "these"
print $array[-6]; # "print"
print $array[-7]; # warning
</pre>

<p class=original>There is no collision between a scalar <tt>$array</tt> and an array <tt>@array</tt> containing a scalar entry <tt>$array[0]</tt>. There may, however, be reader confusion, so avoid this.</p>

<p>スカラ<tt>$array</tt>とスカラのエントリ<tt>$array[0]</tt>を持つ配列<tt>@array</tt>は衝突しません。 とはいえ、コードを読む人が混乱しますので、同じ名前を付けるのは避けましょう。</p>

<p class=original>To get an array's length:</p>
<p>配列の長さを得るには:</p>

<pre class="perl prettyprint">
print "This array has ", (scalar @array), "elements"; # "This array has 6 elements"
print "The last populated index is ", $#array;        # "The last populated index is 5"
</pre>

<p class=original>String concatenation using the <tt>.</tt> operator:</p>
<p>文字列の結合には<tt>.</tt>演算子を使います:</p>

<pre class="perl prettyprint">
print $array[0].$array[1].$array[2]; # "printthesestrings"
</pre>

<p class=original>String concatenation by passing multiple arguments to <tt>print</tt>:</p>
<p>複数の引数を<tt>print</tt>に渡すことで文字列を連結できます:</p>

<pre class="perl prettyprint">
print @array; # "printthesestringsoutforme"
</pre>

<p class=original>The arguments with which the original Perl script was invoked are stored in the built-in array variable <tt>@ARGV</tt>.</p>
<p>オリジナルのPerlスクリプトの実行時の引数は、組込の配列変数<tt><@ARGV/tt>に入ります。</p>

<p class=original>Variables can be interpolated into strings:</p>
<p>変数を文字列の間に入れることができます:</p>
<pre class="perl prettyprint">
print "Hello $string"; # "Hello world"
print "@array";        # "print these strings out for me"
</pre>

<p class=original><strong>Caution.</strong> One day you will put somebody's email address inside a string, <tt>"jeff@gmail.com"</tt>. This will cause Perl to look for an array variable called <tt>@gmail</tt> to interpolate into the string, and not find it, resulting in a runtime error. Interpolation can be prevented in two ways: by backslash-escaping the sigil, or by using single quotes instead of double quotes.</p>
<p><strong>注意。</strong> ある日、誰かのメールアドレス、<tt>"jeff@gmail.com"</tt>を文字列に入れたとします。 これは、Perlに<tt>@gmail</tt>という配列変数を探させ、文字列の間に入れようとします。それが見つからなければ、エラーになります。変数の展開を防ぐには2つの方法があります:シジルをエスケープする。まてゃあ、ダブルクォートの代わりにシングルクォートを使う。</p>

<pre class="perl prettyprint">
print "Hello \$string"; # "Hello $string"
print 'Hello $string';  # "Hello $string"
print "\@array";        # "@array"
print '@array';         # "@array"
</pre>

<h3 class=original>Hash variables</h3>
<h3>ハッシュ変数</h3>

<p class=original>A hash variable is a list of scalars indexed by strings. In Python this is known as a <i>dictionary</i>, and in PHP it is known as an <i>array</i>.</p>
<p>ハッシュ変数は文字でインデックスされた素からのリストです。Pythonでは<i>dictionary</i>、PHPでは<i>array</i>になります。</p>

<pre class="perl prettyprint">
my %scientists = (
	"Newton"   =&gt; "Isaac",
	"Einstein" =&gt; "Albert",
	"Darwin"   =&gt; "Charles",
);
</pre>

<p class=original>Notice how similar this declaration is to an array declaration. In fact, the double arrow symbol <tt>=&gt;</tt> is called a "fat comma", because it is just a synonym for the comma separator. A hash is g declared using a list with an even number of elements, where the even-numbered elements (0, 2, ...) are all considered as strings.</p>
<p>この宣言は配列変数の宣言にとても似ていることに注意してください。実際に、二重矢印記号<tt>=&gt;</tt>は、"ファットカンマ"と呼ばれます。というのも、これは、カンマセパレータのまさにシノニムだからです。ハッシュは偶数の数のリストを使って宣言されます。偶数の要素(0, 2, ...)は全て文字列と考えられます</p>

<p class=original>Once again, you have to use a dollar sign to access a value from a hash, because the value being <em>retrieved</em> is not a hash but a scalar:</p>
<p>またまた、ハッシュから値にアクセスするには、ドル記号を使わなければいけません。<em>取られる</em>値はハッシュではなく、スカラだからです:</p>

<pre class="perl original">
print $scientists{"Newton"};   # "Isaac"
print $scientists{"Einstein"}; # "Albert"
print $scientists{"Darwin"};   # "Charles"
print $scientists{"Dyson"};    # runtime error - key not set
</pre>

<pre class="perl prettyprint">
print $scientists{"Newton"};   # "Isaac"
print $scientists{"Einstein"}; # "Albert"
print $scientists{"Darwin"};   # "Charles"
print $scientists{"Dyson"};    # 実行時エラー(訳註:警告の間違い) - キーがセットされていない
</pre>

<p class=original>Note the braces used here. Again, there is no collision between a scalar <tt>$hash</tt> and a hash <tt>%hash</tt> containing a scalar entry <tt>$hash{"foo"}</tt>.</p>

<p>ブレースが使われていることに注意してください。配列のときと同じですが、素からの<tt>$hash</tt>とスカラのエントリ<tt>$hash{"foo"}</tt>が入っているハッシュの<tt>%hash</tt>は衝突しません。</p>

<p class=original>You can convert a hash straight to an array with twice as many entries, alternating between key and value (and the reverse is equally easy):</p>
<p>エントリを2倍にしてハッシュを配列に直接変換することや、キーと値を変更することができます(その逆もまた簡単です):</p>

<pre class="perl prettyprint">
my @scientists = %scientists;
</pre>

<p class=original>However, unlike an array, the keys of a hash have <em>no underlying order</em>. They will be returned in whatever order is more efficient. So, notice the rearranged <em>order</em> but preserved <em>pairs</em> in the resulting array:</p>

<p>ですが、配列とは違い、ハッシュのキーは<em>順番がありません</em>。より効率的な順番で返ってきます。そのため、整列され直された<em>順番</em>に気をつけてください。しかし、結果の配列の<em>ペア</em>は保持されます:</p>

<pre class="perl prettyprint">
print @scientists; # something like "EinsteinAlbertDarwinCharlesNewtonIsaac"
</pre>

<p class=original>To recap, you have to use <strong>square brackets</strong> to retrieve a value from an array, but you have to use <strong>braces</strong> to retrieve a value from a hash. The square brackets are effectively a numerical operator and the braces are effectively a string operator. The fact that the <em>index</em> supplied is a number or a string is of absolutely no significance:</p>
<p>要点をまとめると、配列から値を取り出すのには<strong>四角いブラケット</strong>を使わなければいけませんが、ハッシュから値を取り出すのは<strong>ブレース</strong>を使わなければいけません。提供される<em>インデックス</em>が数字であるか文字列であるということには、重要性はありません:</p>

<pre class="perl prettyprint">
my $data = "orange";
my @data = ("purple");
my %data = ( "0" =&gt; "blue");

print $data;      # "orange"
print $data[0];   # "purple"
print $data["0"]; # "purple"
print $data{0};   # "blue"
print $data{"0"}; # "blue"
</pre>

<h3 class=original>Lists</h3>
<h3>リスト</h3>

<p class=original>A <i>list</i> in Perl is a different thing again from either an array or a hash. You've just seen several lists:</p>
<p>Perlにおける<i>リスト</i>は配列やハッシュとは違うものです。既にいくつかのリストがありました:</p>

<pre class="perl prettyprint">
(
	"print",
	"these",
	"strings",
	"out",
	"for",
	"me",
)

(
	"Newton"   =&gt; "Isaac",
	"Einstein" =&gt; "Albert",
	"Darwin"   =&gt; "Charles",
)
</pre>

<p class=original><strong>A list is not a variable.</strong> A list is an ephemeral <em>value</em> which can be <em>assigned</em> to an array or a hash variable. This is why the syntax for declaring array and hash variables is identical. There are many situations where the terms "list" and "array" can be used interchangeably, but there are equally many where lists and arrays display subtly different and extremely confusing behaviour.</p>
<p><strong>リストは変数ではありません。</strong>リストはその場限りの<em>値</em>で、配列やハッシュ変数に<em>割り当て</em>られます。このことは、配列とハッシュの変数の宣言のシンタックスがが一致していることの理由です。"リスト"と"配列"の用語が交換可能な状況は多くありますが、同様に、リストと配列がいくぶん違って見えるところもあり、その振る舞いに非常に混乱します。</p>
<p class=original>Okay. Remember that <tt>=&gt;</tt> is just <tt>,</tt> in disguise and then look at this example:</p>
<p>いいでしょう。 <tt>=&gt;</tt>は、ただの<tt>,</tt>であることを思い出し、返送させて、次の例を見てください:</p>

<pre class="perl prettyprint">
(0, 1, 2, 3, 4, 5)
(0 =&gt; 1, 2 =&gt; 3, 4 =&gt; 5)
</pre>

<p class=original>The use of <tt>=&gt;</tt> hints that one of these lists is an array declaration and the other is a hash declaration. But on their own, neither of them are declarations of anything. They are just lists. <em>Identical</em> lists. Also:</p>
<p><tt>=&gt;</tt>の使い方が一方のリストが配列の宣言であることを示し、他方はハッシュの宣言であることを示しています。ですが、2つとも、それ自身、何の宣言でもありません。ただのリストです。<em>同一の</em>リストです。また:</p>

<pre class="perl prettyprint">
()
</pre>

<p class=original>There aren't even hints here. This list could be used to declare an empty array or an empty hash and the <tt>perl</tt> interpreter clearly has no way of telling either way. Once you understand this odd aspect of Perl, you will also understand why the following fact must be true: <strong>List values cannot be nested.</strong> Try it:</p>

<p>なんのヒントも存在しません。このリストは空の配列として宣言されているのでしょうか、それとも、カラのハッシュとしてでしょうか。<tt>perl</tt>インタープリタには、明らかにどちらとも判断することができません。Perlの変わった一面であると理解したなら、次の事実が真であることもまた理解するでしょう: <strong>リストの値はネストできません。</strong> 試してみてください:</p>

<pre class="perl prettyprint">
my @array = (
	"apples",
	"bananas",
	(
		"inner",
		"list",
		"several",
		"entries",
	),
	"cherries",
);
</pre>

<p class=original>Perl has no way of knowing whether <tt>("inner", "list", "several", "entries")</tt> is supposed to be an inner array or an inner hash. Therefore, Perl assumes that it is neither and <strong>flattens the list out into a single long list</strong>:</p>

<p>Perlには、<tt>("inner"(訳註:内側の), "list"(訳註:リストが), "several"(訳註:複数の), "entries"(訳註:値))</tt>が内包された配列なのか、ハッシュなのかどうかがわかりません。そのため、Perlはいずれでもないと想定し、<strong>ひとつの長いリストに平板化します</strong>:</p>

<pre>
print $array[0]; # "apples"
print $array[1]; # "bananas"
print $array[2]; # "inner"
print $array[3]; # "list"
print $array[4]; # "several"
print $array[5]; # "entries"
print $array[6]; # "cherries"

print $array[2][0]; # error
print $array[2][1]; # error
print $array[2][2]; # error
print $array[2][3]; # error
</pre>

<p class=original>The same is true whether the fat comma is used or not:</p>
<p>ファットカンマを使っていてもいなくても同じく真です:</p>

<pre class="perl original">
my %hash = (
	"beer" =&gt; "good",
	"bananas" =&gt; (
		"green"  =&gt; "wait",
		"yellow" =&gt; "eat",
	),
);

# The above raises a warning because the hash was declared using a 7-element list

print $hash{"beer"};    # "good"
print $hash{"bananas"}; # "green"
print $hash{"wait"};    # "yellow";
print $hash{"eat"};     # undef, so raises a warning

print $hash{"bananas"}{"green"};  # error
print $hash{"bananas"}{"yellow"}; # error
</pre>

<pre class="perl prettyprint">
my %hash = (
	"beer" =&gt; "good",
	"bananas" =&gt; (
		"green"  =&gt; "wait",
		"yellow" =&gt; "eat",
	),
);

# 上のコードはwarningが出ます。ハッシュが7つの要素のリストで宣言されているからです。

print $hash{"beer"};    # "good"
print $hash{"bananas"}; # "green"
print $hash{"wait"};    # "yellow";
print $hash{"eat"};     # undef, そのため、警告がでます

print $hash{"bananas"}{"green"};  # error
print $hash{"bananas"}{"yellow"}; # error
</pre>


<p class=original>More on this shortly.</p>
<p>詳細は後ほど。</p>

<h2>コンテキスト</h2>

<p class=original>Perl's most distinctive feature is that its code is <i>context-sensitive</i>. <strong>Every expression in Perl is evaluated either in scalar context or list context</strong>, depending on whether it is expected to produce a scalar or a list. Many Perl expressions and built-in functions display radically different behaviour depending on the context in which they are evaluated.</p>

<p>Perlの最も特徴のあるところは、コードが<i>コンテクストセンシティブ</i>なところです。<strong>Perlの全ての式はスカラコンテキストかリストコンテキストで評価されます</strong>。スカラかリストをのいずれかを作るかを期待されているかに依存します。多くのPerlの式と組込の関数は、それが評価されるコンテキストによって、振る舞いに根本的に違いを見せます。</p>

<p class=original>A scalar declaration such as <tt>my $scalar =</tt> evaluates its expression in scalar context. A scalar value such as <tt>"Mendeleev"</tt> evaluated in scalar context returns the scalar:</p>

<p><tt>my $scalar =</tt>のようなスカラの宣言はスカラコンテキストとして評価されます。<tt>"Mendeleev"</tt>のようなスカラの値がスカラ今敵うとで評価され、スカラを返します:</p>

<pre class="perl prettyprint">
my $scalar = "Mendeleev";
</pre>
<p class=original>An array or hash declaration such as <tt>my @array =</tt> or <tt>my %hash =</tt> evaluates its expression in list context. A list value evaluated in list context returns the list, which then gets fed in to populate the array or hash:</p>
<p><tt>my @array =</tt> や <tt>my %hash =</tt> のような配列やハッシュの宣言は、リストコンテキストで評価されます。リストの値はリストコンテキストで評価され、リストを返します。配列やハッシュに代入するようなときです:</p>

<pre class="perl prettyprint">
my @array = ("Alpha", "Beta", "Gamma", "Pie");
my %hash = ("Alpha" =&gt; "Beta", "Gamma" =&gt; "Pie");
</pre>

<p class=original>No surprises so far.</p>
<p>驚くようなことはありません。</p>

<p class=original>A scalar expression evaluated in list context turns into a single-element list:</p>
<p>スカラの式はリストコンテキストで評価されると、ひとつの値のリストとなります:</p>

<pre class="perl prettyprint">
my @array = "Mendeleev";
print $array[0];     # "Mendeleev"
print scalar @array; # "1"
</pre>
<p class=original>A list expression evaluated in scalar context returns <em>the final scalar in the list</em>:</p>
<p>リストの式がスカラコンテキストで評価されると、<em>リストの最後のスカラ</em>を返します:</p>
<pre class="perl prettyprint">
my $scalar = ("Alpha", "Beta", "Gamma", "Pie");
print $scalar; # "Pie"
</pre>
<p class=original>An array expression (an array is different from a list, remember?) evaluated in scalar context returns <em>the length of the array</em>:</p>
<p>配列の式(配列はリストと違います。覚えてる？)は、スカラコンテキストでは<em>配列の長さ</em>を返します:</p>

<pre class="perl prettyprint">
my @array = ("Alpha", "Beta", "Gamma", "Pie");
my $scalar = @array;
print $scalar; # "4"
</pre>
<p class=original>You can force any expression to be evaluated in scalar context using the <tt>scalar</tt> built-in function. In fact, this is why we use <tt>scalar</tt> to retrieve the length of an array.</p>
<p>どのような式も<tt>scalar</tt>組込関数を使えばスカラコンテキストで強制的に評価することが出来ます。このことが、なぜ<tt>scalar</tt>を配列の長さを取るのに使うのかの理由です。</p>

<p class=original>You are not bound by law or syntax to return a scalar value when a subroutine is evaluated in scalar context, nor to return a list value in list context. As seen above, Perl is perfectly capable of fudging the result for you.</p>
<p>サブルーチンがスカラコンテキストで評価されるときにスカラを返すような法律やシンタックスにはあなたは縛られていませんし、また、リストコンテキストでリストを返すこともまた同じです。上で見たように、Perlは完全にあなたのために結果を作ることができます。</p>

<!--
<p>As a more complicated example, let's examine what happens when we perform a regular expression match. A regex match expression evaluated in scalar context returns <tt>""</tt> (the empty string) if the match fails, <tt>1</tt> on success:</p>
<pre class="perl prettyprint">
my $bill = "The amount was \$123.45. You must pay immediately.";
my $scalar = ($bill =~ m/^The amount was \$(\d+\.\d\d)\. You must (\w+) ([\w\s]+)\.$/);
print $scalar; # "1"
</pre>
<p>The same expression evaluated in list context returns a list of matches:</p>
<pre class="perl prettyprint">
my $bill = "The amount was \$123.45. You must pay immediately.";
my @array = ($bill =~ m/^The amount was \$(\d+\.\d\d)\. You must (\w+) ([\w\s]+)\.$/);
print @array; # "123.45payimmediately"
</pre>
-->

<h2 class=original>References and nested data structures</h2>
<h2>リファレンスとネストされたデータ構造</h2>

<p class=original>In the same way that lists cannot contain lists as elements, <strong>arrays and hashes cannot contain other arrays and hashes as elements.</strong> They can only contain scalars. For example:</p>
<p>リストが要素としてリストを含めないのと同様、<strong>配列とハッシュは他の配列やハッシュを要素として持てません</strong>。 両方ともスカラしか持てません。 例えば:</p>

<pre class="perl prettyprint">
my @outer = ();
my @inner = ("Mercury", "Venus", "Earth");

$outer[0] = @inner;

print $outer[0];    # "3", not "MercuryVenusEarth" as you would hope
print $outer[0][0]; # error, not "Mercury" as you would hope
</pre>

<p class=original><tt>$outer[0]</tt> is a scalar, so it demands a scalar value. When you try to assign an array value like <tt>@inner</tt> to it, <tt>@inner</tt> is evaluated in scalar context. This is the same as assigning <tt>scalar @inner</tt>, which is the length of array <tt>@inner</tt>, which is 3.</p>
<p><tt>$outer[0]</tt>はスカラです。そのため、スカラの値を要求します。<tt>@inner</tt>のような配列を割り当てようとすると、<tt>@inner</tt>はスカラコンテキストで評価されます。つまり、<tt>scalar @inner</tt>と同じです。配列<tt>@inner</tt>の長さ、3になります。</p>

<p class=original>However, a scalar variable may contain a <i>reference</i> to any variable, including an array variable or a hash variable. This is how more complicated data structures are created in Perl.</p>
<p>ですが, スカラ変数は、配列変数やハッシュ変数を含む、他の変数への<i>リファレンス</i>を持てます。これが、Perlでより複雑なデータ構造を作る方法です。</p>

<p class=original>A reference is created using a backslash.</p>
<p>リファレンスはバックスラッシュを使って作られます。</p>
<pre class="perl prettyprint">
my $colour    = "Indigo";
my $scalarRef = \$colour;
</pre>

<p class=original>Any time you would use the name of a variable, you can instead just put some braces in, and, within the braces, put a <em>reference</em> to a variable instead.</p>
<p>いつでも、変数の名前を使えます。代わりにブレースを置いて、ブレース内に変数への<em>リファレンス</em>を置きます。</p>
<pre class="perl prettyprint">
print $colour;         # "Indigo"
print $scalarRef;      # e.g. "SCALAR(0x182c180)"
print ${ $scalarRef }; # "Indigo"
</pre>

<p class=original>As long as the result is not ambiguous, you can omit the braces too:</p>
<p>結果が曖昧でない限り、ブレースを省略することもできます:</p>

<pre class="perl prettyprint">
print $$scalarRef; # "Indigo"
</pre>

<p class=original>If your reference is a reference to an array or hash variable, you can get data out of it using braces or using the more popular arrow operator, <tt>-&gt;</tt>:</p>
<p>リファレンスが配列かハッシュ変数のリファレンスの場合、ブレースかより一般的なアロー演算子、<tt>-&gt;</tt>を使ってデータを取り出せます:</p>

<pre class="perl prettyprint">
my @colours = ("Red", "Orange", "Yellow", "Green", "Blue");
my $arrayRef = \@colours;

print $colours[0];       # direct array access
print ${ $arrayRef }[0]; # use the reference to get to the array
print $arrayRef-&gt;[0];    # exactly the same thing

my %atomicWeights = ("Hydrogen" =&gt; 1.008, "Helium" =&gt; 4.003, "Manganese" =&gt; 54.94);
my $hashRef = \%atomicWeights;

print $atomicWeights{"Helium"}; # direct hash access
print ${ $hashRef }{"Helium"};  # use a reference to get to the hash
print $hashRef-&gt;{"Helium"};     # exactly the same thing - this is very common
</pre>

<h3 class=original>Declaring a data structure</h3>
<h3>データ構造を宣言する</h3>

<pre class="perl prettyprint">
my %owner1 = (
	"name" =&gt; "Santa Claus",
	"DOB"  =&gt; "1882-12-25",
);

my $owner1Ref = \%owner1;

my %owner2 = (
	"name" =&gt; "Mickey Mouse",
	"DOB"  =&gt; "1928-11-18",
);

my $owner2Ref = \%owner2;

my @owners = ( $owner1Ref, $owner2Ref );

my $ownersRef = \@owners;

my %account = (
	"number" =&gt; "12345678",
	"opened" =&gt; "2000-01-01",
	"owners" =&gt; $ownersRef,
);
</pre>

<p class=original>That's obviously unnecessarily laborious, because you can shorten it to:</p>
<p>これは、明らかに不必要で骨の折れます。なぜなら、次のように省略できます:</p>

<pre class="perl prettyprint">
my %owner1 = (
	"name" =&gt; "Santa Claus",
	"DOB"  =&gt; "1882-12-25",
);

my %owner2 = (
	"name" =&gt; "Mickey Mouse",
	"DOB"  =&gt; "1928-11-18",
);

my @owners = ( \%owner1, \%owner2 );

my %account = (
	"number" =&gt; "12345678",
	"opened" =&gt; "2000-01-01",
	"owners" =&gt; \@owners,
);
</pre>

<p class=original>It is also possible to declare <i>anonymous</i> arrays and hashes using different symbols. Use square brackets for an anonymous array and braces for an anonymous hash. The value returned in each case is a <em>reference</em> to the anonymous data structure in question. Watch carefully, this results in exactly the same <tt>%account</tt> as above:</p>
<p>
別の記号を使って<i>無名</i>配列やハッシュを宣言することも出来ます。四角いブラケットを無名配列に、ブレースを無名ハッシュに使います。それぞれ、返される値は、無名のデータ構造の<em>リファレンス</em>になります。注意して見てください。次の結果は、上の<tt>%account</tt>と全く同じです:</p>

<pre class="perl prettyprint">
# Braces denote an anonymous hash
my $owner1Ref = {
	"name" =&gt; "Santa Claus",
	"DOB"  =&gt; "1882-12-25",
};

my $owner2Ref = {
	"name" =&gt; "Mickey Mouse",
	"DOB"  =&gt; "1928-11-18",
};

# Square brackets denote an anonymous array
my $ownersRef = [ $owner1Ref, $owner2Ref ];

my %account = (
	"number" =&gt; "12345678",
	"opened" =&gt; "2000-01-01",
	"owners" =&gt; $ownersRef,
);
</pre>

<p class=original>Or, for short (and this is the form you should <em>actually</em> use when declaring complex data structures in-line):</p>
<p>または、省略するすると(そして、行でデータ複雑な構造を宣言する時に、<em>実際に</em>使うべき形です):</p>

<pre class="perl prettyprint">
my %account = (
	"number" =&gt; "31415926",
	"opened" =&gt; "3000-01-01",
	"owners" =&gt; [
		{
			"name" =&gt; "Philip Fry",
			"DOB"  =&gt; "1974-08-06",
		},
		{
			"name" =&gt; "Hubert Farnsworth",
			"DOB"  =&gt; "2841-04-09",
		},
	],
);
</pre>

<h3 class="original">Getting information out of a data structure</h3>
<h3>データ構造から情報を取り出す</h3>

<p class="original">Now, let's assume that you still have <tt>%account</tt> kicking around but everything else (if there was anything else) has fallen out of scope. You can print the information out by reversing the same procedure in each case:</p>

<p>さて、いじくりまわす<tt>%account</tt>がまだあるとしましょう。ですが、全ての他のもの(他のものがあったなら)は、スコープの外に落ちます。それぞれのケースで同じ手順を逆向きにすることで、情報を表示できます。</p>

<pre class="perl prettyprint">
my $ownersRef = $account{"owners"};
my @owners    = @{ $ownersRef };
my $owner1Ref = $owners[0];
my %owner1    = %{ $owner1Ref };
my $owner2Ref = $owners[1];
my %owner2    = %{ $owner2Ref };
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
</pre>

<p class=original>Or, for short:</p>
<p>または, 省略して:</p>

<pre class="perl prettyprint">
my @owners = @{ $account{"owners"} };
my %owner1 = %{ $owners[0] };
my %owner2 = %{ $owners[1] };
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
</pre>

<p class=original>Or using references:</p>
<p>または、リファレンスを使って:</p>

<pre class="perl prettyprint">
my $ownersRef = $account{"owners"};
my $owner1Ref = $ownersRef-&gt;[0];
my $owner2Ref = $ownersRef-&gt;[1];
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $owner1Ref-&gt;{"name"}, " (born ", $owner1Ref-&gt;{"DOB"}, ")\n";
print "\t", $owner2Ref-&gt;{"name"}, " (born ", $owner2Ref-&gt;{"DOB"}, ")\n";
</pre>

<p class=original>And if we completely skip all the intermediate values:</p>
<p>そして、全ての中間の値をスキップするなら:</p>

<pre class="perl prettyprint">
print "Account #", $account{"number"}, "\n";
print "Opened on ", $account{"opened"}, "\n";
print "Joint owners:\n";
print "\t", $account{"owners"}-&gt;[0]-&gt;{"name"}, " (born ", $account{"owners"}-&gt;[0]-&gt;{"DOB"}, ")\n";
print "\t", $account{"owners"}-&gt;[1]-&gt;{"name"}, " (born ", $account{"owners"}-&gt;[1]-&gt;{"DOB"}, ")\n";
</pre>

<h3 class=original>How to shoot yourself in the foot with references to arrays and hashes</h3>
<h3>配列とハッシュのリファレンスで自分で自分の足を撃つ方法</h3>

<p class=original>This array has five elements:</p>
<p>この配列には5つの要素があります:</p>
<pre class="perl prettyprint">
my @array1 = (1, 2, 3, 4, 5);
print @array1; # "12345"
</pre>

<p class=original>This array has one element (which happens to be a reference to an anonymous, five-element array):</p>
<p>この配列にはひとつの要素(無名の5つの要素の配列のリファレンス)があります:</p>
<pre class="perl prettyprint">
my @array2 = [1, 2, 3, 4, 5];
print @array2; # e.g. "ARRAY(0x182c180)"
</pre>

<p class=original>This <em>scalar</em> is a reference to an anonymous, five-element array:</p>
<p>この <em>スカラ</em> は、無名の5つの要素の配列のリファレンスになります:</p>
<pre class="perl prettyprint">
my $array3Ref = [1, 2, 3, 4, 5];
print $array3Ref;      # e.g. "ARRAY(0x22710c0)"
print @{ $array3Ref }; # "12345"
print @$array3Ref;     # "12345"
</pre>

<h2 class=original>Flow control</h2>
<h2>フロー制御</h2>

<h3><tt>if</tt> ... <tt>elsif</tt> ... <tt>else</tt> ...</h3>

<p class=original>No surprises here, other than the spelling of <tt>elsif</tt>:</p>
<p><tt>elsif</tt>のスペル以外には驚くものはありません:</p>

<pre class="perl prettyprint">
my $word = "antidisestablishmentarianism";
my $strlen = length $word;

if($strlen &gt;= 15) {
	print "'", $word, "' is a very long word";
} elsif(10 &lt;= $strlen &amp;&amp; $strlen &lt; 15) {
	print "'", $word, "' is a medium-length word";
} else {
	print "'", $word, "' is a a short word";
}
</pre>

<p class=original>Perl provides a shorter "<i>statement</i> <tt>if</tt> <i>condition</i>" syntax which is highly recommended for short statements:</p>
<p>Perlにはより短い "<i>ステートメント</i> <tt>if</tt> <i>条件</i>"のシンタックスがあります。短いステートメント用に、強く推奨されます:</p>

<pre class="perl prettyprint">
print "'", $word, "' is actually enormous" if $strlen >= 20;
</pre>

<h3><tt>unless</tt> ... <tt>else</tt> ...</h3>

<pre class="perl prettyprint">
my $temperature = 20;

unless($temperature > 30) {
	print $temperature, " degrees Celsius is not very hot";
} else {
	print $temperature, " degrees Celsius is actually pretty hot";
}
</pre>

<p class=original><tt>unless</tt> blocks are generally best avoided like the plague because they are very confusing. An "<tt>unless</tt> [... <tt>else</tt>]" block can be trivially refactored into an "<tt>if</tt> [... <tt>else</tt>]" block by negating the condition [or by keeping the condition and swapping the blocks]. Mercifully, there is no <tt>elsunless</tt> keyword.</p>

<p><tt>unless</tt>ブロックは災いのように避けるのが一番です。それらは混乱のもととなります。"<tt>unless</tt> [... <tt>else</tt>]"ブロックは簡単に、"<tt>if</tt> [... <tt>else</tt>]" ブロックに、条件を否定する[または、条件をそのままにブロックを交換する]ことでリファクタできます。幸い、 <tt>elsunless</tt>のキーワードはありません。</p>

<p class=original>This, by comparison, is highly recommended because it is so easy to read:</p>
<p>一方で、以下は読みやすさのために、強く推奨されます</p>
<pre class="perl prettyprint">
print "Oh no it's too cold" unless $temperature > 15;
</pre>

<h3 class=original>Ternary operator</h3>
<h3>三項演算子</h3>

<p class=original>The ternary operator <tt>?:</tt> allows simple <tt>if</tt> statements to be embedded in a statement. The canonical use for this is singular/plural forms:</p>
<p>三項演算子 <tt>?:</tt> は、単純な <tt>if</tt> ステートメントをひとつのステートメントに埋め込めます。三項演算子の標準的な使い方として、単数/複数の形があります:</p>

<pre class="perl prettyprint">
my $gain = 48;
print "You gained ", $gain, " ", ($gain == 1 ? "experience point" : "experience points"), "!";
</pre>

<p class=original>Aside: singulars and plurals are best spelled out in full in both cases. Don't do something clever like the following, because anybody searching the codebase to replace the words "tooth" or "teeth" will never find this line:</p>
<p>余談: 両方のケースの単数と複数を完全に書き出されています。決して以下のような巧妙なことをしないでください。
コードを検索して、"tooth"か"teeth"の単語を置き換えようとしても、この行から見つけることができません。</p>

<pre class="perl prettyprint">
my $lost = 1;
print "You lost ", $lost, " t", ($lost == 1 ? "oo" : "ee"), "th!";
</pre>

<p class=original>Ternary operators may be nested:</p>
<p>三項演算子はネストできます:</p>

<pre class="perl prettyprint">
my $eggs = 5;
print "You have ", $eggs == 0 ? "no eggs" :
                   $eggs == 1 ? "an egg"  :
                   "some eggs";
</pre>

<p class=original><tt>if</tt>, <tt>unless</tt> and <tt>?:</tt> statements evaluate their conditions in scalar context. For example, <tt>if(@array)</tt> returns true if and only if <tt>@array</tt> has 1 or more elements. It doesn't matter what those elements are - they may contain <tt>undef</tt> or other false values for all we care.</p>

<p><tt>if</tt>、 <tt>unless</tt> と <tt>?:</tt> ステートメントは条件をスカラコンテキストで評価します。 <tt>if(@array)</tt>は、<tt>@array</tt>にひとつ以上のエレメントがある場合のみ、真となります。配列の中の値が何かは問題にしません - 全てが<tt>undef</tt>や他の偽の値でも</p>

<h3 class=original>Array iteration</h3>
<h3>配列のイテレーション</h3>

<p class=original>There's More Than One Way To Do It.</p>
<p>やりかたはひとつではありません。</p>

<p class=original>Basic C-style <tt>for</tt> loops are available, but these are obtuse and old-fashioned and should be avoided. Notice how we have to put a <tt>my</tt> in front of our iterator <tt>$i</tt>, in order to declare it:</p>
<p>基本的なC-styleの<tt>for</tt>ループは利用できますが、わかりにくく、古臭いので、使うべきではありません。<tt>my</tt>をイテレータ<tt>$i</tt>の前に措いて、次のように宣言します:</p>

<pre class="perl prettyprint">
for(my $i = 0; $i &lt; scalar @array; $i++) {
	print $i, ": ", $array[$i];
}
</pre>

<p class=original>Native iteration over an array is much nicer. Note: unlike PHP, the <tt>for</tt> and <tt>foreach</tt> keywords are synonyms. Just use whatever looks most readable:</p>
<p>配列のネイティブのイテレーションはより簡単です。注意: PHPと違い、 <tt>for</tt> と <tt>foreach</tt> キーワードはシノニムです。もっとも読みやすいもののいずれかを使ってください:</p>
<pre class="perl prettyprint">
foreach my $string ( @array ) {
	print $string;
}
</pre>

<p class=original>If you do need the indices, the range operator <tt>..</tt> creates an anonymous array of integers:</p>
<p>複数のインデックスが必要なら、範囲演算子<tt>..</tt>で整数の無名配列を作れます:</p>

<pre class="perl prettyprint">
foreach my $i ( 0 .. $#array ) {
	print $i, ": ", $array[$i];
}
</pre>

<p class=original>If you don't provide an explicit iterator, Perl uses a default iterator, <tt>$_</tt>. <tt>$_</tt> is the first and friendliest of the built-in variables:</p>
<p>明示的なイテレータを使わなければ、Perlはデフォルトのイテレータとして<tt>$_</tt>を使います。<tt>$_</tt>は

If you don't provide an explicit iterator, Perl uses a default iterator, . <tt>$_</tt>は最初のフレンドリーな組込の変数です:</p>

<pre class="perl prettyprint">
foreach ( @array ) {
	print $_;
}
</pre>

<p class=original>If using the default iterator, and you only wish to put a single statement inside your loop, you can use the super-short loop syntax:</p>
<p>デフォルトのイテレータを使い、また、ループに単一のステートメントしか置かないなら、とても短いループのシンタックスを使えます:</p>
<pre class="perl prettyprint">
print $_ foreach @array;
</pre>

<p class=original>Perl also provides <tt>while</tt> loops but those are coming up in a second.</p>
<p>Perlには、また、<tt>while</tt> ループもあります。 ですが、それらはまた、後で。</p>

<h3 class=original>Hash iteration</h3>
<h3>ハッシュイテレータ</h3>

<p class=original>You can't iterate over a hash. However, you can iterate over its keys. Use the <tt>keys</tt> built-in function to retrieve an array containing all the keys of a hash. Then use the <tt>foreach</tt> approach that we used for arrays:</p>
<p>ハッシュはイテレートできません。そのキーをイテレートできます。組込関数の<tt>keys</tt>を使って、ハッシュの全てのキーを含む配列を取り出してください。それから、配列で使った<tt>foreach</tt>のアプローチを使います:</p>

<pre class="perl prettyprint">
foreach my $key (keys %scientists) {
	print $key, ": ", $scientists{$key};
}
</pre>

<p class=original>Since a hash has no underlying order, the keys may be returned in any order. Use the <tt>sort</tt> built-in function to sort the array of keys alphabetically beforehand:</p>
<p>ハッシュには順番がありませんので、keysはどのような順番でも戻ります。組込の<tt>sort</tt>関数を使って、アルファベット順でキーの配列をソートできます:</p>
<pre class="perl prettyprint">
foreach my $key (sort keys %scientists) {
	print $key, ": ", $scientists{$key};
}
</pre>

<p class=original>There is also a special <tt>each</tt> built-in function which retrieves key/value pairs one at a time. Every time <tt>each</tt> is called, it returns an array containing two values, until the end of the array is reached, when a false value is returned. We assign the values of two scalars to the values of the array, simultaneously:</p>
<p>特別な組込関数<tt>each</tt>もあり、これは、キー/値のペアを一度にひとつ取り出します。<tt>each</tt>が呼ばれるたびに、配列の最後に至るまで、偽の値が戻るまで、2つの値をもつ配列を返します。配列の値を2つのスカラに、同時に割り当てます:</p>

<pre class="perl prettyprint">
while( my ($key, $value) = each %scientists ) {
	print $key, ": ", $value;
}
</pre>

<h3 class=original>Loop control</h3>
<h3>ループ制御</h3>

<p class=original><tt>next</tt> and <tt>last</tt> can be used to control the progress of a loop. In most programming languages these are known as <tt>continue</tt> and <tt>break</tt> respectively. We can also optionally provide a label for any loop. By convention, labels are written in <tt>ALLCAPITALS</tt>. Having labelled the loop, <tt>next</tt> and <tt>last</tt> may target that label. This example lists all the non-fictional animals from an array:</p>

<p><tt>next</tt> と <tt>last</tt>はループ進みを制御するのに使われます。多くのプログラミング言語では、それぞれ、<tt>continue</tt> と <tt>break</tt>となっています。オプションで、どのループにもラベルをつけることができます。慣例により、ラベルは <tt>全て大文字で</tt>書くことになっています。ループにラベルをつけることで、<tt>next</tt> と <tt>last</tt> にラベルを対象にできます。配列から全ての架空でない動物をリストする例です:</p>

<pre class="perl prettyprint">
my @input = (
	"dragon", "camel", "cow", "pangolin", "unicorn",
	"pig", "sheep", "donkey", "pig", "basilisk",
	"monkey", "jellyfish", "squid", "crab", "dragon",
);
my @fictional = ("basilisk", "dragon", "unicorn");

INPUT: foreach my $input ( @input ) {

	# See if this input animal is fictional
	foreach my $fictional ( @fictional ) {

		# It is?
		if($input eq $fictional) {
		
			# Then jump to the next input animal
			next INPUT;
		}
	}
	
	# Animal is not fictional, print it
	print $input;
}
</pre>

<h2 class=original>Array functions</h2>
<h2>配列関数</h2>

<h3 class=original>In-place array modification</h3>
<h3>その場で配列を変更する</h3>

<p>We'll use <tt>@stack</tt> to demonstrate these:</p>

<pre class="perl prettyprint">
my @stack = ("Fred", "Eileen", "Denise", "Charlie");
print @stack; # "FredEileenDeniseCharlie"
</pre>

<p class=original><tt>pop</tt> extracts and returns the final element of the array. This can be thought of as the top of the stack:</p>
<p><tt>pop</tt> は配列の最後の要素を引き出して返します。スタックの上として考えられます:</p>
<pre class="perl prettyprint">
print pop @stack; # "Charlie"
print @stack;     # "FredEileenDenise"
</pre>

<p class=original><tt>push</tt> appends extra elements to the end of the array:</p>
<p><tt>push</tt> は追加の要素を配列の最後に付加します:</p>
<pre class="perl prettyprint">
push @stack, "Bob", "Alice";
print @stack; # "FredEileenDeniseBobAlice"
</pre>

<p class=original><tt>shift</tt> extracts and returns the first element of the array:</p>
<p><tt>shift</tt> は配列の最初の要素を引き出して返します:</p>
<pre class="perl prettyprint">
print shift @stack; # "Fred"
print @stack;       # "EileenDeniseBobAlice"
</pre>

<p class=original><tt>unshift</tt> inserts new elements at the beginning of the array:</p>
<p><tt>unshift</tt> 配列の最初に新しい要素を挿入します:</p>
<pre class="perl prettyprint">
unshift @stack, "Hank", "Grace";
print @stack; # "HankGraceEileenDeniseBobAlice"
</pre>

<p class=original><tt>pop</tt>, <tt>push</tt>, <tt>shift</tt> and <tt>unshift</tt> are all special cases of <tt>splice</tt>. <tt>splice</tt> removes and returns an array slice, replacing it with a different array slice:</p>
<p><tt>pop</tt>、<tt>push</tt>、 <tt>shift</tt>、<tt>unshift</tt> は、全て、<tt>splice</tt>の特別なケースです。<tt>splice</tt> は、配列のスライスを削除して、返します。別の配列スライスでそれを置き換えます:</p>
<pre class="perl prettyprint">
print splice(@stack, 1, 4, "&lt;&lt;&lt;", "&gt;&gt;&gt;"); # "GraceEileenDeniseBob"
print @stack;                             # "Hank&lt;&lt;&lt;&gt;&gt;&gt;Alice"
</pre>

<h3 class=original>Creating new arrays from old</h3>
<h3>古い配列から新しい配列を作る</h3>

<p class=original>Perl provides the following functions which act on arrays to create other arrays.</p>
<p>Perlには以下の関数があり、配列に対して、新しい配列を作ります</p>

<h4><tt>join</tt></h4>

<p class="original">The <tt>join</tt> function concatenates many strings into one:</p>
<p><tt>join</tt> 関数は多くの文字列を一つに結合します:</p>

<pre class="perl prettyprint">
my @elements = ("Antimony", "Arsenic", "Aluminum", "Selenium");
print @elements;             # "AntimonyArsenicAluminumSelenium"
print "@elements";           # "Antimony Arsenic Aluminum Selenium"
print join(", ", @elements); # "Antimony, Arsenic, Aluminum, Selenium"
</pre>

<h4><tt>reverse</tt></h4>

<p class=original>The <tt>reverse</tt> function returns an array in reverse order:</p>
<p><tt>reverse</tt> 関数は順番を逆にした配列を返します:</p>

<pre class="perl prettyprint">
my @numbers = ("one", "two", "three");
print reverse(@numbers); # "threetwoone"
</pre>

<h4><tt>map</tt></h4>

<p class=original>The <tt>map</tt> function takes an array as input and applies an operation to every scalar <tt>$_</tt> in this array. It then constructs a new array out of the results. The operation to perform is provided in the form of a single expression inside braces:</p>
<p><tt>map</tt>関数は入力として配列をとり、配列内の全てのスカラ <tt>$_</tt>を操作します。結果として新しい配列を作ります。操作はひとつのブレースで渡します::</p>

<pre class="perl prettyprint">
my @capitals = ("Baton Rouge", "Indianapolis", "Columbus", "Montgomery", "Helena", "Denver", "Boise");

print join ", ", map { uc $_ } @capitals;
# "BATON ROUGE, INDIANAPOLIS, COLUMBUS, MONTGOMERY, HELENA, DENVER, BOISE"
</pre>

<h4><tt>grep</tt></h4>

<p class=original>The <tt>grep</tt> function takes an array as input and returns a filtered array as output. The syntax is similar to <tt>map</tt>. This time, the second argument is evaluated for each scalar <tt>$_</tt> in the input array. If a boolean true value is returned, the scalar is put into the output array, otherwise not.</p>
<p><tt>grep</tt>関数は入力として配列をとり、フィルターされた配列を出力します。シンタックスは<tt>map</tt>と似ています。今度は、第二引数は入力された配列の各スカラ<tt>$_</tt>を評価されます。ブーリアンで真の値が戻れば、スカラは配列として出力されますが、そうでなければ、出力されません。</p>

<pre class="perl prettyprint">
print join ", ", grep { length $_ == 6 } @capitals;
# "Helena, Denver"
</pre>

<p class="original">Instead of a single Perl expression, you may supply a regular expression. In this case, the scalar is put into the output array only if the regular expression matches <tt>$_</tt>:</p>
<p>単一のPerlの式ではなく、正規表現を渡せます。次のケースでは、正規表現が<tt>$_</tt>にマッチした場合のみ、スカラが配列に出力されます:</p>

<pre class="perl prettyprint">
print join ", ", grep m/^[B-H]/, @capitals;
# "Baton Rouge, Columbus, Helena, Denver, Boise"
</pre>

<p class=original>Obviously, the length of the resulting array is the <em>number of successful matches</em>, which means you can use <tt>grep</tt> to quickly check whether an array contains an element:</p>
<p>当然、結果の配列の長さは、<em>マッチに成功した数</em>になります、このとことは、<tt>grep</tt>を配列に要素があるかどうかを素早くチェックするのに使えることを意味します。:</p>

<pre class="perl prettyprint">
print scalar grep { $_ eq "Columbus" } @capitals; # "1"
</pre>

<p class=original><tt>grep</tt> and <tt>map</tt> may be combined to form <i>list comprehensions</i>, an exceptionally powerful feature conspicuously absent from many other programming languages.</p>
<p><tt>grep</tt> と <tt>map</tt> は、<i>リスト包含</i>の形に含まれます。他の多くのプログラミング言語に目立って欠けている、例外的に強力な機能です。</p>

<h4><tt>sort</tt></h4>

<p class=original>By default, the <tt>sort</tt> function returns the input array, sorted into alphabetical order:</p>
<p>デフォルトでは、<tt>sort</tt>関数は入力された配列をアルファベット順に並びかえます:</p>

<pre class="perl prettyprint">
my @elevations = (19, 1, 2, 100, 3, 98, 100, 1056);

print join ", ", sort @elevations;
# "1, 100, 100, 1056, 19, 2, 3, 98"
</pre>

<p class=original>However, similar to <tt>grep</tt> and <tt>map</tt>, you may supply some code of your own. Sorting is always performed using a series of comparisons between elements. Your block receives <tt>$a</tt> and <tt>$b</tt> as inputs and should return -1 if <tt>$a</tt> is "less than" <tt>$b</tt>, 0 if they are "equal" or 1 if <tt>$a</tt> is "greater than" <tt>$b</tt>.</p>
<p>しかし、<tt>grep</tt> と <tt>map</tt>と似て、自分のコードを渡すことも出来ます。ソートは常に要素間の一連の比較を使ってされます。コードブロックは、<tt>$a</tt>と<tt>$b</tt>を受け、<tt>$a</tt>が<tt>$b</tt>"より小さ"ければ -1、"同じ"であれば 0、<tt>$a</tt>が<tt>$b</tt>"より大き"ければ 1 を返します。</p>

<p class=original>The <tt>cmp</tt> operator does exactly this for strings:</p>
<p><tt>cmp</tt> 演算子は文字列に対して、まさにこれをします:</p>

<pre class="perl prettyprint">
print join ", ", sort { $a cmp $b } @elevations;
# "1, 100, 100, 1056, 19, 2, 3, 98"
</pre>

<p class=original>The "spaceship operator", <tt>&lt;=&gt;</tt>, does the same for numbers:</p>
<p>"スペースシップ演算子", <tt>&lt;=&gt;</tt>は、数字に対して同じことをします:</p>

<pre class="perl prettyprint">
print join ", ", sort { $a &lt;=&gt; $b } @elevations;
# "1, 2, 3, 19, 98, 100, 100, 1056"
</pre>

<p class=original><tt>$a</tt> and <tt>$b</tt> are always scalars, but they can be references to quite complex objects which are difficult to compare. If you need more space for the comparison, you can create a separate subroutine and provide its name instead:</p>
<p><tt>$a</tt> と <tt>$b</tt> は常にスカラーですが、比較が難しい非常に複雑なオブジェクトのリファレンスもありえます。比較によりスペースが必要なら、別のサブルーチンを作り、代わりにその名前を渡せます:</p>

<pre class="perl prettyprint">
sub comparator {
	# lots of code...
	# return -1, 0 or 1
}

print join ", ", sort comparator @elevations;
</pre>

<p class=original>You can't do this for <tt>grep</tt> or <tt>map</tt> operations.</p>
<p>同じことは、<tt>grep</tt> や <tt>map</tt> ではできません。</p>

<p class=original>Notice how the subroutine and block are never explicitly provided with <tt>$a</tt> and <tt>$b</tt>. Like <tt>$_</tt>, <tt>$a</tt> and <tt>$b</tt> are, in fact, global variables which are <em>populated</em> with a pair of values to be compared each time.</p>
<p>サブルーチンとブロックは <tt>$a</tt> と <tt>$b</tt>と一緒には渡されません。<tt>$_</tt>のように、 <tt>$a</tt>と<tt>$b</tt>は、実際、グローバル変数で、その時々に、比較される値のペアで<em>埋められ</em>ます</p>

<h2 class=original>Built-in functions</h2>
<h2>組込関数</h2>
<p class="original">By now you have seen at least a dozen built-in functions: <tt>print</tt>, <tt>sort</tt>, <tt>map</tt>, <tt>grep</tt>, <tt>each</tt>, <tt>keys</tt>, <tt>scalar</tt> and so on. Built-in functions are one of Perl's greatest strengths. They</p>
<p>今までで、少なくともよくある組込関数が出てきました: <tt>print</tt>, <tt>sort</tt>, <tt>map</tt>, <tt>grep</tt>, <tt>each</tt>, <tt>keys</tt>, <tt>scalar</tt> など。 組込関数はPerlの最も偉大な強みのひとつです。それらは、</p>

<ul class="original">
	<li>are numerous</li>
	<li>are very useful</li>
	<li>are extensively documented (in "perlfunc")</li>
	<li>vary greatly in syntax, so check the documentation</li>
	<li>sometimes accept regular expressions as arguments</li>
	<li>sometimes accept entire blocks of code as arguments</li>
	<li>sometimes don't require commas between arguments</li>
	<li>sometimes will consume an arbitrary number of comma-separated arguments and sometimes will not</li>
	<li>sometimes will fill in their own arguments if too few are supplied</li>
	<li>generally don't require brackets around their arguments except in ambiguous circumstances</li>
</ul>
<ul>
	<li>たくさんある</li>
	<li>とても便利</li>
	<li>広くドキュント化されている("perlfunc"に)</li>
	<li>シンタックスで大きく異なるので、ドキュメントを見ること</li>
	<li>引数として正規表現を受け付けるものもある</li>
	<li>引数として完全なコードブロックを受け付けるものもある</li>
	<li>引数の間にコンマが不要なものもある</li>
	<li>コンマで区切られた任意の数を取るものもあれば、そうでないものもある</li>
	<li>引数が少なすぎる場合に、自分自身で引数を埋めるものもある</li>
	<li>曖昧な状況でなければ、一般的に引数のまわりに括弧は不要</li>
</ul>
<p class=original>The best advice regarding built-in functions is to know that they exist, so that you can <strong>use them</strong>. If you are carrying out a task which feels like it's low-level and common enough that it's been done many times before, the chances are that it has.</p>
<p>組込関数が存在していることを知ることに館する最も良いアドバイスは、<strong>使ってみる</strong>ことです。低レベルで以前に何度も行っている十分に共通だと感じるタスクを実行しているなら、そのチャンスです。</p>

<h2 class=original>User-defined subroutines</h2>
<h2>ユーザー定義のサブルーチン</h2>

<p class=original>Although the brackets are optional, subroutines should always be invoked using brackets, even when called with no arguments. This makes it clear that a subroutine call is happening.</p>
<p>括弧はオプションですが、サブルーチンは、引数がひとつも無くても、常に括弧付きで使うべきです。こうしておけば、サブルーチンが呼ばれたことが、明確になります。</p>

<p class=original>Subroutines are declared using the <tt>sub</tt> keyword. In contrast with built-in functions, user-defined subroutines always accept the same input: a list of scalars. That list may of course have a single element, or be empty. A single scalar is taken as a list with a single element. A hash with <var>N</var> elements is taken as a list with 2<var>N</var> elements.</p>

<p>サブルーチンは<tt>sub</tt> キーワードを使って宣言されます。組込関数と対照的に、ユーザー定義のサブルーチンは常に同じ入力を受け付けます: スカラのリストです。そのリストは、もちろん、ひとつの要素か、空の場合もあります。ひとつのスカラは一つの要素のリストです。<var>N</var>要素のハッシュは2<var>N</var>要素のリストです。</p>

<p class=original>Once you're inside a subroutine, the arguments are available using the built-in array variable <tt>@_</tt>. Examples follow.</p>
<p>サブルーチンの中では、組込の配列変数<tt>@_</tt>が使えます。例は以下に続きます。</p>

<h3 class=original>Unpacking arguments</h3>
<h3>引数を取り出す</h3>
<p class=original>There's More Than One Way To unpack these arguments, but some are superior to others.</p>
<p>引数を取り出すのにいくつかやり方があります。 ですが、いくつかは、ほかのものより、より良いです。</p>

<p class=original>The example subroutine <tt>leftPad</tt> below pads a string out to the required length using the supplied pad character. (The <tt>x</tt> function concatenates multiple copies of the same string in a row.) (Note: for brevity, these subroutines all lack some elementary error checking, i.e. ensuring the pad character is only 1 character, checking that the width is greater than or equal to the length of existing string, checking that all needed arguments were passed at all.)</p>
<p>例のサブルーチン<tt>leftPad</tt>は、以下の例は、渡された詰め込み文字を使って、必要な長さになるまで文字列に付加します。(<tt>x</tt>関数は行に同じ文字列の複数のコピーをつなげます)。(注意: 簡潔さのために、これらのサブルーチンは全て基本的なエラーチェックを行っていません。例えば、詰め込み文字が1文字のみであることを保証するとか、長さが既存の文字列の長さ以上であるか、必要な引数が全て渡されているかどうか、など)。</p>
<p class=original><tt>leftPad</tt> is typically invoked as follows:</p>
<p><tt>leftPad</tt> は典型的に、次のように呼ばれます:</p>
<pre class="perl prettyprint">
print leftPad("hello", 10, "+"); # "+++++hello"
</pre>

<ol>
	<li>
		<p class=original>Some people don't unpack the arguments at all and use <tt>@_</tt> "live". This is unreadable and discouraged:</p>
  		<p>人によっては、引数を取り出さずに<tt>@_</tt>を"そのまま"使うかもしれません。これは、読みにくく、推奨されません:</p>
<pre class="perl prettyprint">
sub leftPad {
	my $newString = ($_[2] x ($_[1] - length $_[0])) . $_[0];
	return $newString;
}
</pre>
	</li>
	<li>
		<p class=original>Unpacking <tt>@_</tt> is only slightly less strongly discouraged:</p>
		<p><tt>@_</tt>の取り出しは、ほんの少しずつするのは、強く推奨されません:</p>
<pre class="perl prettyprint">
sub leftPad {
	my $oldString = $_[0];
	my $width     = $_[1];
	my $padChar   = $_[2];
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
	</li>
	<li>
		<p class=original>Unpacking <tt>@_</tt> by removing data from it using <tt>shift</tt> is highly recommended for up to 4 arguments:</p
		<p><tt>@_</tt>を取り出すのに、<tt>shift</tt>を使って、@_からデータを削除するのは、引数が4つまでなら強く推奨されます:</p<pre class="perl prettyprint">
sub leftPad {
	my $oldString = shift @_;
	my $width     = shift @_;
	my $padChar   = shift @_;
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
		<p class=original>If no array is provided to the <tt>shift</tt> function, then it operates on <tt>@_</tt> implicitly. This approach is seen very commonly:</p>
		<p><tt>shift</tt>に配列を渡さなければ、暗黙に、<tt>@_</tt>に対して操作します。このアプローチはとてもよく見られます:</p>
	<pre class="perl prettyprint">
sub leftPad {
	my $oldString = shift;
	my $width     = shift;
	my $padChar   = shift;
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
		<p class=original>Beyond 4 arguments it becomes hard to keep track of what is being assigned where.</p>
		<p>引数が5つ以上になるなら、どこで割り当てたかを追い続けるのが難しくなるでしょう。</p>
	</li>
	<li>
		<p class=original>You can unpack <tt>@_</tt> all in one go using multiple simultaneous scalar assignment. Again, this is okay for up to 4 arguments:</p>
		<p><tt>@_</tt>の取り出しを、同時に全て一度にスカラに割り当てることが出来ます。 この方法も、引数が4つまでなら問題ありません:</p>
<pre class="perl prettyprint">
sub leftPad {
	my ($oldString, $width, $padChar) = @_;
	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
	return $newString;
}
</pre>
	</li>
	<li>
		<p class=original>For subroutines with large numbers of arguments or where some arguments are optional or cannot be used in combination with others, best practice is to require the user to provide a hash of arguments when calling the subroutine, and then unpack <tt>@_</tt> back into that hash of arguments. For this approach, our subroutine call would look a little different:</p>
		<p>引数が多いサブルーチンや、いくつかの引数がオプションであるとか、他との組み合わせで使えないなら、最も良い方法は、サブルーチンの呼び出し時に、ユーザにハッシュの引数を渡させることです。そして、<tt>@_</tt>をハッシュに取り出します。このアプローチのために、サブルーチンの呼び出しはちょっと違ったものになります:</p>
<pre class="perl prettyprint">
print leftPad("oldString" =&gt; "pod", "width" =&gt; 10, "padChar" =&gt; "+");
</pre>
		<p class=original>And the subroutine itself looks like this:</p>
		<p>そして、サブルーチン自身は次のようになります:</p>
<pre class="perl prettyprint">
sub leftPad {
	my %args = @_;
	my $newString = ($args{"padChar"} x ($args{"width"} - length $args{"oldString"})) . $args{"oldString"};
	return $newString;
}
</pre>
	</li>
</ol>
<h3 class=original>Returning values</h3>
<h3>戻り値</h3>
<p class=original>Like other Perl expressions, subroutine calls may display contextual behaviour. You can use the <tt>wantarray</tt> function (which should be called <tt>wantlist</tt> but never mind) to detect what context the subroutine is being evaluated in, and return a result appropriate to that context:</p>

<p>他のPerlの式と同様、サブルーチン呼び出しは、コンテキスト依存の振る舞いをします。<tt>wantlist</tt>(<tt>wantlist</tt>と呼ばれるべきですが、気にしないでください)を使って、どのコンテキストでサブルーチンが評価されているかをチェックでき、コンテキストに適した結果を返すことが出来ます:</p>

<pre class="perl prettyprint">
sub contextualSubroutine {
	# Caller wants a list. Return a list
	return ("Everest", "K2", "Etna") if wantarray;

	# Caller wants a scalar. Return a scalar
	return "Everest ::: K2 ::: Etna";
}

my @array = contextualSubroutine();
print @array; # "EverestK2Etna"

my $scalar = contextualSubroutine();
print $scalar; # "Everest ::: K2 ::: Etna"
</pre>

<h2 class=original>A quick note on variables</h2>
<h2>変数についての簡単なメモ</h2>
<p class=original>All the variables you have seen so far are <i>lexical</i> variables, which are declared using the <tt>my</tt> keyword and last until the end of the enclosing block or file.</p>
<p>今まで見てきた全ての変数は、<i>レキシカル</i>変数です。それらは、<tt>my</tt>キーワードを使って宣言されており、ブロックかファイルの終わりまで有効です。</p>
<p class=original><i>Package</i> variables, which we are about to meet, are declared using the <tt>our</tt> keyword and are effectively global in scope.</p>
<p><i>パッケージ</i>変数は、すぐに出てきますが、<tt>our</tt>キーワードを使って宣言され、スコープ内のグローバル変数として有効になります</p>
<!--
<h3>Built-in variables</h3>
<p><strong>The complete list of built-in variables is <a href="http://perldoc.perl.org/perlvar.html">perlvar</a>.</strong></p>
<p>Perl has several dozen built-in variables. Some have useful names, such as <tt>@ARGV</tt> which contains the list of arguments with which the current Perl script was invoked, and <tt>%ENV</tt> which contains environment variables. Others are common enough that they can be referenced freely: the only two that I'd pick are the default iterator <tt>$_</tt> and the subroutine argument list <tt>@_</tt>, the latter of which you will encounter very shortly.</p>
<p>The remainder are mostly unmemorable punctuation names such as <tt>$"</tt>, <tt>$,</tt> and <tt>$!</tt>.</p>
<p>Using such variables without explanation is discouraged. You have some options:</p>
<ul>
	<li>Comments.</li>
	<li><tt>use English</tt>. This call creates human-readable aliases for all built-in variables. For example, <tt>$"</tt>, <tt>$,</tt> and <tt>$!</tt> can be used as <tt>$LIST_SEPARATOR</tt>, <tt>$OUTPUT_FIELD_SEPARATOR</tt> and <tt>$OS_ERROR</tt> respectively.</li>
</ul>
-->
<h2 class=original>Packages and modules</h2>
<h2>パッケージとモジュール</h2>

<p class=original>In Perl, packages and modules are different things.</p>
<p>Perlでは、パッケージとモジュールは違うものです。</p>

<h3 class=original>Packages</h3>
<h3>パッケージ</h3>

<p class=original>A <i>パッケージ</i> is a namespace in which subroutines and package variables can be declared. Any subroutine or package variable you declare is implicitly declared within the current package. At the beginning of execution, you are in the <tt>main</tt> package, but you can switch package using the <tt>package</tt> built-in function:</p>
<p><i>package</i>は名前空間で、その中で、宣言したサブルーチンやパッケージ変数は、暗黙的に、現在のパッケージ内で宣言されます。実行の最初は、<tt>main</tt>パッケージになりますが、組込関数の<tt>package</tt>を使って、パッケージを切り替えられます:</p>

<pre class="perl prettyprint">
sub subroutine {
	print "universe";
}

our $variable = "empty";
	
package Food::Potatoes;

# no collision:
sub subroutine {
	print "kingedward";
}

our $variable = "mashed";
</pre>

<p class=original>Any time you call a subroutine, you implicitly call a subroutine which is inside the current package. The same is true of package variables. Alternatively, you can explicitly provide a package. See what happens if we continue the above script:</p>
<p>サブルーチンを呼んだときはいつでも、暗黙に現在のパッケージ内のサブルーチンを呼んでいます。同じことは、パッケージ変数にも言えます。その代わりに、パッケージを明示的に書くこともできます。下のスクリプトを実行したら、何が起きるでしょうか:</p>

<pre class="perl prettyprint">
subroutine();    # "kingedward"
print $variable; # "mashed"

main::subroutine();              # "universe"
print $main::variable;           # "empty"
Food::Potatoes::subroutine();    # "kingedward"
print $Food::Potatoes::variable; # "mashed"
</pre>

<h3 class=original>Modules</h3>
<h3>モジュール</h3>

<p class=original>A <i>module</i> is a <tt>.pm</tt> file that you can include in another Perl file (script or module). A module is a text file with exactly the same syntax as a <tt>.pl</tt> Perl script. An example module might be located at <tt>C:\foo\bar\baz\Mathematics\Powers.pm</tt> or <tt>/foo/bar/baz/Mathematics/Powers.pm</tt>, and read as follows:</p>
<p>A <i>モジュール</i>は、他のPerlファイル(スクリプトかモジュール)に含めることが出来る<tt>.pm</tt>ファイルです。モジュールは <tt>.pl</tt> Perlスクリプトとまったく同じシンタックのステキストファイルです。例のモジュールは、<tt>C:\foo\bar\baz\Mathematics\Powers.pm</tt> か <tt>/foo/bar/baz/Mathematics/Powers.pm</tt>にあります。続きを読んでください:</p>
<pre class="perl prettyprint">
use strict;
use warnings;

package Mathematics::Powers;

our $e = 2.71828;

sub exp {
	return $e ** shift;
}

1;
</pre>

<p class=original>Because a module is executed from top to bottom when it is loaded, you need to return a true value at the end to show that it was loaded successfully. <tt>return 1</tt> would suffice. If you don't use <tt>return</tt>, the value returned is <em>the value returned when the most recent statement was evaluated</em>. So, you will often see <tt>1</tt> at the bottom of a Perl module, as shown above.</p>
<p>モジュールはロードされると、最初から最後まで実行されるので、ロードが成功したことを示すために、最後に真の値を返す必要があります。<tt>return 1</tt>で十分です。<tt>return</tt>を使わなければ、返される値は、<em>直近のステートメントが評価されたときの戻り値</em>になります。そのために、上で見たように、Perlモジュールの最後に<tt>1</tt>が良く見られることになります。</p>

<p class=original>So that the Perl interpreter can find them, directories containing Perl modules should be listed in your environment variable <tt>PERL5LIB</tt> beforehand. List the root directory containing the modules, don't list the module directories or the modules themselves:</p>
<p>Perlインタープリタはそれらを見つけることができるためには、その前に、Perlモジュールが入っているディレクトリが、環境変数<tt>PERL5LIB</tt>にリストされているべきです。モジュールが入っているルートディレクトリをリストしてください。モジュールのディレクトリやモジュール自身をリストしてはいけません。</p>

<pre class="bash">
set PERL5LIB=C:\foo\bar\baz;%PERL5LIB%
</pre>
<p>or</p>
<pre class="bash">
export PERL5LIB=/foo/bar/baz:$PERL5LIB
</pre>

<p>Once the Perl module is created and <tt>perl</tt> knows where to look for it, you can use the <tt>require</tt> built-in function to search for and execute it during a Perl script. For example, calling <tt>require Mathematics::Powers</tt> causes the Perl interpreter to search each directory listed in <tt>PERL5LIB</tt> in turn, looking for a file called <tt>Mathematics/Powers.pm</tt>. After the module has been loaded, the subroutines and variables that were defined there suddenly become available in the main script. Our example script might be called <tt>powers.pl</tt> and read as follows:</p>
<p class=original>Perlモジュールが作られて、<tt>perl</tt>がそれがどこにあるかを知っていれば、組込の<tt>require</tt>関数を使って探し、Perlのスクリプト中で実行することができます。例えば、<tt>require Mathematics::Powers</tt>を呼ぶと、Perlインタープリタは<tt>PERL5LIB</tt>にリストされているディレクトリを順番に、<tt>Mathematics/Powers.pm</tt>というファイルを探します。モジュールがロードされたら、突然にサブルーチンと変数がメインスクリプトに定義されます。この例のスクリプトを<tt>powers.pl</tt>と呼びましょう。続けて読んでくさい:</p>

<pre class="perl prettyprint">
use strict;
use warnings;

require Mathematics::Powers;

print Mathematics::Powers::exp(2); # "7.3890461584"
</pre>

<p class=original>Now read this next bit carefully.</p>
<p>では、次はちょっと注意して読んでください。</p>
<p class=original>Packages and modules are two completely separate and distinct features of the Perl programming language. The fact that they both use the same double colon delimiter is a monumental red herring. It is possible to switch packages multiple times over the course of a script or module, and it is possible to use the same package declaration in multiple locations in multiple files. Calling <tt>require Foo::Bar</tt> <em>does not</em> look for and load a file with a <tt>package Foo::Bar</tt> declaration somewhere inside it. Calling <tt>require Foo::Bar</tt> <em>does not</em> necessarily load subroutines or package variables in the <tt>Foo::Bar</tt> namespace. Calling <tt>require Foo::Bar</tt> merely loads a file called <tt>Foo/Bar.pm</tt>, which need not have <em>any</em> kind of package declaration inside it at all, and in fact might declare <tt>package Baz::Qux</tt> and other nonsense inside it for all you know.</p>
<p>パッケージとモジュールの2つは、プログラミング言語Perlにおいて完全に分かれており、区別された機能です。この2つが同じダブルコロンのデリミタを使っていることは、記念碑的な赤ニシンです。これは、スクリプトまたはモジュールのコース経由でパッケージを複数回切り替えることができ、また、複数のファイル内の複数の場所で同一のパッケージ宣言を使うこともできます。<tt>require Foo::Bar</tt>を呼ぶことは<tt>Foo::Bar</tt>名前空間にあるサブルーチンやパッケージ変数を必ずしもロード<em>しません</em>。<tt>require Foo::Bar</tt>を呼ぶことは、単に<tt>Foo/Bar.pm</tt>というファイルをロードするだけであり、そのファイルに、<em>どのような</em>種類のパッケージ宣言も必要有りません。実際には、あなたの知っている全ての<tt>package Baz::Qux</tt>のような意味のないものも宣言できます。</p>

<p>Likewise, a subroutine call <tt>Baz::Qux::processThis()</tt> need not necessarily have been declared inside a file named <tt>Baz/Qux.pm</tt>. It could have been declared <em>literally anywhere</em>.</p>
<p>Separating these two concepts is one of the stupidest features of Perl, and treating them as separate concepts invariably results in chaotic, maddening code. Fortunately for us, the majority of Perl programmers obey the following two laws:</p>
<ol>
	<li><strong>A Perl script (<tt>.pl</tt> file) must always contain exactly zero <tt>package</tt> declarations.</strong></li>
	<li><strong>A Perl module (<tt>.pm</tt> file) must always contain exactly one <tt>package</tt> declaration, corresponding exactly to its name and location.</strong> E.g. module <tt>Mathematics/Powers.pm</tt> must begin with <tt>package Mathematics::Powers</tt>.</li>
</ol>
<p>Because of this, in practice you will find that most "packages" and "modules" produced by reliable third parties <em>can</em> be regarded and referred to interchangeably. However, it is important that you do not take this for granted, because one day you <em>will</em> meet code produced by a madman.</p>

<h2>Object-oriented Perl</h2>

<p>Perl is not a great language for OO programming. Perl's OO capabilities were grafted on after the fact, and this shows.</p>

<ul>
	<li><p>An <i>object</i> is simply a reference (i.e. a scalar variable) which happens to know which class its referent belongs to. To tell a reference that its referent belongs to a class, use <tt>bless</tt>. To find out what class a reference's referent belongs to (if any), use <tt>ref</tt>.</p></li>
	<li><p>A <i>method</i> is simply a subroutine that expects an object (or, in the case of class methods, a package name) as its first argument. Object methods are invoked using <tt>$obj-&gt;method()</tt>; class methods are invoked using <tt>Package::Name-&gt;method()</tt>.</p></li>
	<li><p>A <i>class</i> is simply a package that happens to contain methods.</p></li>
</ul>

<p>A quick example. An example module <tt>Animals/Animals.pm</tt> containing a class <tt>Animals::Animal</tt> reads like this:</p>

<pre class="perl prettyprint">
use strict;
use warnings;

package Animals::Animal;

sub eat {
	# First argument is always the object to act upon.
	my $self = shift;
	
	foreach my $food ( @_ ) {
		if($self-&gt;canEat($food)) {
			print "Eating ", $food;
		} else {
			print "Can't eat ", $food;
		}
	}
}

sub canEat {
	return 1;
}

1;
</pre>

<p>And a Perl script making use of this class might read:</p>

<pre class="perl prettyprint">
use strict;
use warnings;

require Animals::Animal;

my $animal = {};                  # $animal is an ordinary hash reference
print ref $animal;                # "HASH"
bless $animal, "Animals::Animal"; # now it is an object of class "Animals::Animal"
print ref $animal;                # "Animals::Animal"

$animal-&gt;eat("insects", "curry", "salmon");
</pre>

<p>This final call is equivalent to <tt>Animals::Animal::eat($animal, "insects", "curry", "salmon")</tt>.</p>

<p>Note: literally any reference can be blessed into any class. It's up to you to ensure that (1) the referent can actually be used as an instance of this class and (2) that the class in question exists and has been loaded.</p>

<h3>Inheritance</h3>

<p>To create a class inheriting from a base class, populate the <tt>@ISA</tt> package variable. Let's suppose we subclassed <tt>Animals::Animal</tt> with <tt>Animals::Bear</tt>, located at <tt>Animals/Bear.pm</tt>:</p>

<pre class="perl prettyprint">
use strict;
use warnings;

package Animals::Bear;

require Animals::Animal;

# Inherit from Animals::Animal
our @ISA = ("Animals::Animal");

# Override one method
sub canEat {
	shift;
	return 1 if shift eq "salmon";
	return 0;
}

1;
</pre>

<p>And some sample code:</p>

<pre class="perl prettyprint">
use strict;
use warnings;

require Animals::Bear;

my $bear = bless {}, "Animals::Bear";

$bear-&gt;eat("insects", "curry", "salmon"); # eat only the salmon
</pre>

<p>This final method call tries to invoke <tt>Animals::Bear::eat($bear, "insects", "curry", "salmon")</tt>, but a subroutine <tt>eat()</tt> isn't defined in the <tt>Animals::Bear</tt> package. However, because <tt>@ISA</tt> has been populated with a parent package <tt>Animals::Animal</tt>, the Perl interpreter tries calling <tt>Animals::Animal::eat($bear, "insects", "curry", "salmon")</tt> instead, which works. Note how the class <tt>Animals::Animal</tt> had to be loaded explicitly by <tt>Animals::Bear</tt>.</p>
<p>Since <tt>@ISA</tt> is an array, Perl supports multiple inheritance, with all the benefits and horrors this entails.</p>

<h2><tt>BEGIN</tt> blocks</h2>

<p>A <tt>BEGIN</tt> block is executed as soon as the compiler has finished parsing it, even before the compiler parses the rest of the file. It is ignored at execution time.</p>

<pre class="perl prettyprint">
use strict;
use warnings;

# a package declaration might go here

BEGIN {
	# do something extremely important
}

# actual code
</pre>

<p>A <tt>BEGIN</tt> block is always executed first. If you create multiple <tt>BEGIN</tt> blocks (don't), they are executed in order from top to bottom as the compiler encounters them. A <tt>BEGIN</tt> block always executes first even if it is placed halfway through a script (don't do this) or even at the end (or this).</p>
<p>Because they are executed at compilation time, a <tt>BEGIN</tt> block placed inside a conditional block will <em>still</em> be executed first, even if the conditional evaluates to false and despite the fact that the conditional <em>has not been evaluated at all yet</em> and in fact <em>may never be evaluated</em>. <strong>Do not put <tt>BEGIN</tt> blocks in conditionals!</strong> If you want to do something conditionally at compile time, you need to put the conditional <em>inside</em> the <tt>BEGIN</tt> block:</p>
<pre class="perl prettyprint">
BEGIN {
	if($condition) {
		# etc.
	}
}
</pre>

<h2><tt>use</tt></h2>
<p>Okay. Now that you understand the obtuse behaviour and semantics of packages, modules, class methods and <tt>BEGIN</tt> blocks, I can explain the exceedingly commonly-seen <tt>use</tt> function.</p>
<p>The following three statements:</p>
<pre class="perl prettyprint">
use Bugs::Caterpillar ("crawl", "pupate");
use Bugs::Caterpillar ();
use Bugs::Caterpillar;
</pre>
<p>are respectively equivalent to:</p>
<pre class="perl prettyprint">
BEGIN {
	require Bugs::Caterpillar;
	Bugs::Caterpillar-&gt;import("crawl", "pupate");
}
BEGIN {
	require Bugs::Caterpillar;
}
BEGIN {
	require Bugs::Caterpillar;
	Bugs::Caterpillar-&gt;import();
}
</pre>
<ul>
	<li>No, the three examples are not in the wrong order. It is just that Perl is dumb.</li>
	<li>A <tt>use</tt> call is a disguised <tt>BEGIN</tt> block. The same caveats apply. <tt>use</tt> statements must always be placed at the top of the file, and <strong>never inside conditionals</strong>.</li>
	<li><tt>import()</tt> is not a built-in Perl function. It is a <strong>user-defined class method</strong>. The burden is on the programmer of the <tt>Bugs::Caterpillar</tt> package to define or inherit <tt>import()</tt>, and the method could theoretically accept anything as arguments and do anything with those arguments.</li>
	<li>Notice how <tt>require Bugs::Caterpillar</tt> loads a <strong>module</strong> named <tt>Bugs/Caterpillar.pm</tt>, whereas <tt>Bugs::Caterpillar-&gt;import()</tt> calls the <tt>import()</tt> subroutine that was defined inside the <tt>Bugs::Caterpillar</tt> <strong>package</strong>. Let's hope the module and the package coincide!</li>
</ul>

<h2>Exporter</h2>

<p>The most common way to define an <tt>import()</tt> method is to inherit it from Exporter module. Exporter is a <i>de facto</i> core feature of the Perl programming language. In Exporter's implementation of <tt>import()</tt>, the list of arguments that you pass in is interpreted as a list of subroutine names. When a subroutine is <tt>import()</tt>ed, it becomes available in the current namespace as well as in its own original namespace.</p>

<p>This concept is easiest to grasp using an example. Here's what <tt>Bugs/Caterpillar.pm</tt> looks like:</p>

<pre class="perl prettyprint">
use strict;
use warnings;

package Bugs::Caterpillar;

require Exporter;

our @ISA = ("Exporter");

our @EXPORT_OK = ("crawl", "eat");
our @EXPORT    = ("crawl");

sub crawl  { print "inch inch";   }
sub eat    { print "chomp chomp"; }
sub pupate { print "bloop bloop"; }

1;
</pre>

<p>And here's a script which makes use of the <tt>Bugs/Caterpillar.pm</tt> module:</p>

<pre class="perl prettyprint">
use strict;
use warnings;

use Bugs::Caterpillar;

Bugs::Caterpillar::crawl();  # "inch inch"
Bugs::Caterpillar::eat();    # "chomp chomp"
Bugs::Caterpillar::pupate(); # "bloop bloop"

crawl(); # "inch inch"
</pre>

<p>The package variable <tt>@EXPORT_OK</tt> can be populated with a list of all subroutines which the user can import explicitly by passing subroutine names to <tt>import()</tt>. If <tt>import()</tt> is called with the name of a subroutine not in this list, a runtime error will occur. For example, try <tt>use Bugs::Caterpillar ("pupate")</tt>.</p>

<p>The package variable <tt>@EXPORT</tt> can be populated with a list of subroutines to be exported by default. These are exported if <tt>import()</tt> is called with no arguments at all, which is what happens in this example.</p>

<p>As a result of being <tt>import()</tt>ed, a method such as <tt>Bugs::Caterpillar::crawl()</tt> become available without qualification as <tt>crawl()</tt>. This saves typing. (Note: regardless of the content of <tt>@EXPORT_OK</tt>, every method can always be called "longhand", as shown above. There are no private methods in Perl. Customarily, a method intended for private use is named with a leading underscore or two.)</p>

<p><strong>A caution.</strong> Notice how <tt>crawl()</tt> was neither defined in the script, nor explicitly <tt>import()</tt>ed from another file with e.g. <tt>use Bugs::Caterpillar ("crawl")</tt>. Suppose the middle three lines weren't there to provide clues, and suppose there were a dozen <tt>use</tt> calls alongside <tt>use Bugs::Caterpillar</tt>. And remember that any module is free to have more <tt>use</tt> calls of its own. In such a situation, it is extremely difficult to locate the place where <tt>crawl()</tt> was originally defined. The moral of this story is twofold:</p>
<ol>
<li><p>When creating a module which makes use of Exporter, never use <tt>@EXPORT</tt> to export subroutines by default. Always make the user call subroutines "longhand" or <tt>import()</tt> them explicitly (using e.g. <tt>use Bugs::Caterpillar ("crawl")</tt>, which is a strong clue to look in <tt>Bugs/Caterpillar.pm</tt> for the definition of <tt>crawl()</tt>).</p></li>
<li><p>When <tt>use</tt>ing a module, always explicitly name the subroutines you want to <tt>import()</tt>. If you don't want to <tt>import()</tt> any subroutines and wish to refer to them longhand, you must supply an explicit empty list: <tt>use Bugs::Caterpillar ()</tt>.</p></li>
</ol>

<h2>Files</h2>

<p>A <i>file handle</i> is a completely different object from a scalar, array or hash variable. File handles are customarily represented in <tt>ALLCAPS</tt>; three familiar built-in filehandles are <tt>STDIN</tt>, <tt>STDOUT</tt> and <tt>STDERR</tt>.</p>

<p>Filehandles don't need declaring explicitly using <tt>my</tt> or <tt>our</tt>. They pop into existence automatically. A file handle can be opened using <tt>open</tt>. <tt>open</tt> must be supplied with a <i>method</i>. The method <tt>&lt;</tt> indicates that we wish to open the file to read from it:</p>

<pre class="perl prettyprint">
my $f = "text.txt";
my $result = open INPUT, "&lt;", $f;

if(!defined $result || !$result) {
	die "Couldn't open ", $f, " for reading";
}
</pre>

<p>As seen above, you should always check that the <tt>open</tt> operation completed successfully. If successful, <tt>open</tt> returns a true value. Otherwise, it returns <tt>undef</tt>. This checking procedure being rather tedious, a frequently-seen idiom is this:</p>
<pre class="perl prettyprint">
open(INPUT, "&lt;", $f) || die "Couldn't open ", $f, " for reading";
</pre>
<p>Notice how without the brackets, this would be:</p>
<pre class="perl prettyprint">
open INPUT, "&lt;", $f || die "Couldn't open ", $f, " for reading";
</pre>
<p>Which is the same as the nonsensical:</p>
<pre class="perl prettyprint">
open INPUT, "&lt;", ($f || die "Couldn't open ", $f, " for reading");
</pre>
<p>For this reason (and, as far as I can tell, solely this reason), Perl provides a completely separate operator, <tt>or</tt>, which works exactly like <tt>||</tt> except that it has extremely low precedence, making this possible:</p>
<pre class="perl prettyprint">
open INPUT, "&lt;", $f or die "Couldn't open ", $f, " for reading";
</pre>
<p>To read a line of text from a filehandle, use the <tt>readline</tt> built-in function. <tt>readline</tt> returns a full line of text, with a line break intact at the end of it (except possibly for the final line of the file), or <tt>undef</tt> if you've reached the end of the file.</p>
<pre class="perl prettyprint">
while(1) {
	my $line = readline INPUT;
	last unless defined $line;
	# process the line...
}
</pre>
<p>To truncate that possible trailing line break, use <tt>chomp</tt>:</p>
<pre class="perl prettyprint">
chomp $line;
</pre>
<p>Note that <tt>chomp</tt> acts on <tt>$line</tt> in place. <tt>$line = chomp $line</tt> is probably not what you want.</p>
<p>You can also use <tt>eof</tt> to detect the end of the file:</p>
<pre class="perl prettyprint">
while(!eof INPUT) {
	my $line = readline INPUT;
	# process $line...
}
</pre>
<p>But beware of just using <tt>while(my $line = readline INPUT)</tt>, because if <tt>$line</tt> turns out to be <tt>"0"</tt>, the loop will terminate early. If you want to write something like that, Perl provides the <tt>&lt;&gt;</tt> operator which wraps up <tt>readline</tt> in a fractionally safer way. This is very commonly-seen and perfectly safe:</p>
<pre class="perl prettyprint">
while(my $line = &lt;INPUT&gt;) {
	# process $line...
}
</pre>
<p>And even:</p>
<pre class="perl prettyprint">
while(&lt;INPUT&gt;) {
	# process $_...
}
</pre>
<p>To read a single line of user input:</p>
<pre class="perl prettyprint">
my $line = &lt;STDIN&gt;;
</pre>
<p>To just wait for the user to hit Enter:</p>
<pre class="perl prettyprint">
&lt;STDIN&gt;;
</pre>
<p>Calling <tt>&lt;&gt;</tt> with no filehandle reads data from standard input, or from any files named in arguments when the Perl script was called.</p>
<p>Writing to a file involves first opening it in a different mode. The method <tt>&gt;</tt> indicates that we wish to open the file to write to it. (<tt>&gt;</tt> will clobber the content of the target file if it already exists and has content. To merely append to an existing file, use mode <tt>&gt;&gt;</tt>). Then, simply provide the filehandle as a zeroth argument for the <tt>print</tt> function.</p>
<pre class="perl prettyprint">
open OUTPUT, "&gt;", $f or die "Couldn't open ", $f, " for writing";
print OUTPUT "The eagles have left the nest";
</pre>
<p>Notice the absence of a comma between the filehandle and the first argument in <tt>print</tt>. As you've gathered, if the filehandle is omitted, <tt>STDOUT</tt> is used by default.</p>
<p>File handles are actually closed automatically at script exit time, but otherwise:</p>
<pre class="perl prettyprint">
close INPUT;
close OUTPUT;
</pre>
<p>A scalar variable may hold a reference to a file handle instead of a variable:</p>
<pre class="perl prettyprint">
my $fh;
open $fh, "&lt;", "text.txt" or die;
while(&lt;$fh&gt;) {
	# etc...
}
close $fh;
</pre>
<h2>System calls</h2>
<p>Apologies if you already know the following non-Perl-related facts. Every time a process finishes on a Windows or Linux system (and, I assume, on most other systems), it concludes with a 16-bit <i>status word</i>. The highest 8 bits constitute a <i>return code</i> between 0 and 255 inclusive, with 0 conventionally representing unqualified success, and other values representing various degrees of failure. The other 8 bits are less frequently examined - they "reflect mode of failure, like signal death and core dump information".</p>
<p>You can exit from a Perl script with the return code of your choice (from 0 to 255) using <tt>exit</tt>.</p>
<p>Perl provides More Than One Way To - in a single call - spawn a child process, pause the current script until the child process has finished, and then resume interpretation of the current script. Whichever method is used, you will find that immediately afterwards, the built-in variable <tt>$?</tt> (<tt>$CHILD_ERROR</tt>) has been populated with the status word that was returned from that child process's termination. You can get the return code by taking just the highest 8 of those 16 bits: <tt>$? >> 8</tt>.</p>
<p>The <tt>system</tt> function can be used to invoke another program with the arguments listed. The value returned by <tt>system</tt> is the same value with which <tt>$?</tt> is populated:</p>
<pre class="perl prettyprint">
my $rc = system "perl", "anotherscript.pl", "foo", "bar", "baz";
$rc >>= 8;
print $rc; # "37";
</pre>
<p>Alternatively, you can use backticks <tt>``</tt> to run an actual command at the command line and capture the standard output from that command. In scalar context the entire output is returned as a single string. In list context, the entire output is returned as an array of strings, each one representing a line of output.</p>
<pre class="perl prettyprint">
my $text = `perl anotherscript.pl foo bar baz`;
print $text; # "foobarbaz"
</pre>
<p>This is the behaviour which would be seen if <tt>anotherscript.pl</tt> contained, for example:</p>
<pre class="perl prettyprint">
use strict;
use warnings;

print @ARGV;
exit(37);
</pre>

<h2>Miscellaneous notes</h2>
<p>Perl provides a wide selection of quote-like operators in addition to what you've seen in these documents:</p>
<ul>
	<li>
		<p>There's an alternate syntax, <tt>qw{ }</tt>, for declaring arrays. This often seen in <tt>use</tt> statements:</p>
<pre class="perl prettyprint">
use Account qw{create open close suspend delete};
</pre>
	</li>
	<li>
		<p><tt>qr//</tt> can be used to put a regex into a scalar variable. This is especially useful because recompiling a regular expression multiple times actually takes substantial time:</p>
<pre class="perl prettyprint">
my @capitals = ("Baton Rouge", "Indianapolis", "Columbus", "Montgomery", "Helena", "Denver", "Boise");
my $regex = qr/^[B-H]/;
print join ", ", grep /$regex/, @capitals;
</pre>
	</li>
	<li>
		<p><tt>qx{ }</tt> can be used instead of `backticks` to invoke a program and capture its output:</p>
<pre class="perl prettyprint">
my $text = qx{perl anotherscript.pl foo bar baz};
</pre>
	</li>
	<li>
		<p>And many more!</p>
	</li>
</ul>
<p>Instead of braces, you can use any character you like as the delimiter in these alternate quote-like operators, as well as in <tt>m//</tt> regex matches and <tt>s///</tt> regex replacements. This is actually quite useful if your regex contains a lot of slashes or backslashes. For example, <tt>m!///!</tt> matches three literal forward slashes.</p>
<p>Perl does have <tt>CONSTANTS</tt>. These are discouraged now, but weren't always. Constants are actually just subroutine calls with omitted brackets.</p>
<p>Sometimes people omit quotes around hash keys. They can get away with it because in this situation a bareword (a string with no sigil) occurs as a string, as opposed to a subroutine call or a filehandle or a package name.</p>
<p>If you see a block of unformatted code wrapped in a delimiter with double chevrons, like <tt>&lt;&lt;EOF</tt>, the magic word to Google for is "heredoc".</p>
<p>The Data::Dumper module can be used to output an arbitrary scalar variable to the screen. This is an essential debug tool.</p>

<p>Warning! Many built-in functions can be called with no arguments, <strong>causing them to operate on <tt>$_</tt> instead</strong>. Hopefully this will help you understand formations like:</p>
<pre class="perl prettyprint">
print foreach @array;

foreach ( @array ) {
	next unless defined;
}
</pre>
<p>I dislike this formation because it can lead to problems when refactoring.</p>


<h3 class=original>File tests</h3>
<h3>ファイルテスト</h3>

<p class=original>The function <tt>-e</tt> is a built-in function which tests whether the named file exists.</p>
<p>関数<tt>-e</tt> は組込の関数で与えられた名前のファイルが存在するかどうかをテストします。</p>
<pre class="perl prettyprint">
print "what" unless -e "/usr/bin/perl";
</pre>
<p class=original>The function <tt>-d</tt> is a built-in function which tests whether the named file is a directory.</p>
<p>関数<tt>-d</tt> は組込の関数で与えられた名前のファイルがディレクトリかどうかをテストします。</p>
<p class=original>The function <tt>-f</tt> is a built-in function which tests whether the named file is a plain file.</p>
<p>関数<tt>-f</tt> は組込の関数で与えられた名前のファイルが普通のファイルかどうかをテストします。</p>
<p class=original>These are just three of a large class of functions of the form <tt>-X</tt> where <tt>X</tt> is some lower- or upper-case letter. These functions are called <i>file tests</i>. Note the leading minus sign. In a Google query, the minus sign indicates to exclude results containing this search term. This makes file tests hard to Google for! Just search for "perl file test" instead.</p>
<p><tt>-X</tt>形式の大きなクラスの関数の3つの関数です。<tt>X</tt>は小文字か大文字です。これらの関数は<i>ファイルテスト</i>と呼ばれます。マイナス記号が先に来ることに気をつけてください。Googleクエリでは、マイナス記号は、その言葉を結果に含めないことを指示します。そのため、ファイルテストをGoogleで検索しづらくしています! 代わりに、"perl file test"で検索して下さい。</p>

<script type="text/javascript"><!--
	var sc_project=667681; 
	var sc_invisible=1; 
	var sc_partition=5; 
	var sc_security="f56850e2"; 
	var sc_remove_link=1; 
// --></script>
<script type="text/javascript" src="http://www.statcounter.com/counter/counter_xhtml.js"></script>

<noscript>
	<p><img
		class="statcounter"
		src="http://c6.statcounter.com/counter.php?sc_project=667681&amp;java=0&amp;security=f56850e2&amp;invisible=1"
		alt="website statistics"
	/></p>
</noscript>
</body>
</html> 