=head1 名前

Date::Calc - グレゴリオ暦に基づいた日付計算

=head1 モットー

小さく、早く、単純なままに

=head1 前書き

このモジュールは、グレゴリオ暦(今日の西洋で一番良く使われています)に基づくあらゆる日付計算のため
CのライブラリーとPerlのモジュール(これもCのライブラリーを内部的に使っていますが)
によって構成されています。それにより、妥当な標準に従います。
すなわち、ISO/R 2015-1971及びDIN 1355に準拠し、適用できる部分ではISO 8601の拡張もあります。

(DIN 1355について調べるなら、 http://www.engelschall.com/u/sb/download/Date-Calc/DIN1355/ のドキュメントを読んでください(ドイツ語です)).

このモジュールは、当然のことながら2000年以降も正しく動作します(200年問題対応)
なんと1年から、あなたのシステムで扱える最も大きな正の数(それは少なくとも32767年です)までの全ての数を扱うことが出来るのです。
しかしながら、内部のPOSIXの日付・時間処理の関数の一部であるこのパッケージの出入力を行なう関数にとってそれは正しくありません。単に、以下の日付のみに対応します。

 01-Jan-1970 00:00:00 GMT .. 19-Jan-2038 03:14:07 GMT [Unix etc.]
 01-Jan-1904 00:00:00 LT  .. 06-Feb-2040 06:28:15 LT  [MacOS Classic]
 (LT = local time)

このパッケージの事業であるグレゴリオ暦は紀元1年にさかのぼることを記しておきます。
-- もっともグレゴリオ暦は、
1582年にPope Gregory13世による法令に一致するように服従するほとんどのヨーロッパにあるカトリックの国々によって、
この年にに採用されたのですが。

主にプロテスタントであるいくつかの国々は、それまで使っていたユリウス暦を使い続け、20世紀の初頭にいたるまで変更しませんでした。

最終的には、あなたが自然と想像するであろう全ての機能をつけること予定していません。
むしろUNIXの精神と伝統に基づき、道具箱であるよう、それでいながらいつでもあなたが行きたいところに連れて行くべきものとして
提供する予定なのです。

共通の問題を解決するためには、このドキュメントの下にあるレシピの項を見てください。

もし、どうしても特定の問題を解く方法を発見できなければ、教えてください。
Eメールアドレスは、このドキュメントの最後のところにあります。

=head1 一覧

  use Date::Calc qw(
      Days_in_Year
      Days_in_Month
      Weeks_in_Year
      leap_year
      check_date
      check_time
      check_business_date
      Day_of_Year
      Date_to_Days
      Day_of_Week
      Week_Number
      Week_of_Year
      Monday_of_Week
      Nth_Weekday_of_Month_Year
      Standard_to_Business
      Business_to_Standard
      Delta_Days
      Delta_DHMS
      Delta_YMD
      Delta_YMDHMS
      Normalize_DHMS
      Add_Delta_Days
      Add_Delta_DHMS
      Add_Delta_YM
      Add_Delta_YMD
      Add_Delta_YMDHMS
      System_Clock
      Today
      Now
      Today_and_Now
      This_Year
      Gmtime
      Localtime
      Mktime
      Timezone
      Date_to_Time
      Time_to_Date
      Easter_Sunday
      Decode_Month
      Decode_Day_of_Week
      Decode_Language
      Decode_Date_EU
      Decode_Date_US
      Fixed_Window
      Moving_Window
      Compress
      Uncompress
      check_compressed
      Compressed_to_Text
      Date_to_Text
      Date_to_Text_Long
      English_Ordinal
      Calendar
      Month_to_Text
      Day_of_Week_to_Text
      Day_of_Week_Abbreviation
      Language_to_Text
      Language
      Languages
      Decode_Date_EU2
      Decode_Date_US2
      Parse_Date
      ISO_LC
      ISO_UC
  );

  use Date::Calc qw(:all);

  Days_in_Year
      $days = Days_in_Year($year,$month);

  Days_in_Month
      $days = Days_in_Month($year,$month);

  Weeks_in_Year
      $weeks = Weeks_in_Year($year);

  leap_year
      if (leap_year($year))

  check_date
      if (check_date($year,$month,$day))

  check_time
      if (check_time($hour,$min,$sec))

  check_business_date
      if (check_business_date($year,$week,$dow))

  Day_of_Year
      $doy = Day_of_Year($year,$month,$day);

  Date_to_Days
      $days = Date_to_Days($year,$month,$day);

  Day_of_Week
      $dow = Day_of_Week($year,$month,$day);

  Week_Number
      $week = Week_Number($year,$month,$day);          # DEPRECATED

  Week_of_Year
      ($week,$year) = Week_of_Year($year,$month,$day); # RECOMMENDED
      $week = Week_of_Year($year,$month,$day);         # DANGEROUS

  Monday_of_Week
      ($year,$month,$day) = Monday_of_Week($week,$year);

  Nth_Weekday_of_Month_Year
      if (($year,$month,$day) =
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n))

  Standard_to_Business
      ($year,$week,$dow) =
      Standard_to_Business($year,$month,$day);

  Business_to_Standard
      ($year,$month,$day) =
      Business_to_Standard($year,$week,$dow);

  Delta_Days
      $Dd = Delta_Days($year1,$month1,$day1,
                       $year2,$month2,$day2);

  Delta_DHMS
      ($Dd,$Dh,$Dm,$Ds) =
      Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                 $year2,$month2,$day2, $hour2,$min2,$sec2);

  Delta_YMD
      ($Dy,$Dm,$Dd) =
      Delta_YMD($year1,$month1,$day1,
                $year2,$month2,$day2);

  Delta_YMDHMS
      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds) =
      Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                   $year2,$month2,$day2, $hour2,$min2,$sec2);

  Normalize_DHMS
      ($Dd,$Dh,$Dm,$Ds) =
      Normalize_DHMS($Dd,$Dh,$Dm,$Ds);

  Add_Delta_Days
      ($year,$month,$day) =
      Add_Delta_Days($year,$month,$day,
                     $Dd);

  Add_Delta_DHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec,
                     $Dd,$Dh,$Dm,$Ds);

  Add_Delta_YM
      ($year,$month,$day) =
      Add_Delta_YM($year,$month,$day,
                   $Dy,$Dm);

  Add_Delta_YMD
      ($year,$month,$day) =
      Add_Delta_YMD($year,$month,$day,
                    $Dy,$Dm,$Dd);

  Add_Delta_YMDHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec,
                       $D_y,$D_m,$D_d, $Dh,$Dm,$Ds);

  System_Clock
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      System_Clock([$gmt]);

  Today
      ($year,$month,$day) = Today([$gmt]);

  Now
      ($hour,$min,$sec) = Now([$gmt]);

  Today_and_Now
      ($year,$month,$day, $hour,$min,$sec) = Today_and_Now([$gmt]);

  This_Year
      $year = This_Year([$gmt]);

  Gmtime
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      Gmtime([time]);

  Localtime
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      Localtime([time]);

  Mktime
      $time = Mktime($year,$month,$day, $hour,$min,$sec);

  Timezone
      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds, $dst) = Timezone([time]);

  Date_to_Time
      $time = Date_to_Time($year,$month,$day, $hour,$min,$sec);

  Time_to_Date
      ($year,$month,$day, $hour,$min,$sec) = Time_to_Date([time]);

  Easter_Sunday
      ($year,$month,$day) = Easter_Sunday($year);

  Decode_Month
      if ($month = Decode_Month($string))

  Decode_Day_of_Week
      if ($dow = Decode_Day_of_Week($string))

  Decode_Language
      if ($lang = Decode_Language($string))

  Decode_Date_EU
      if (($year,$month,$day) = Decode_Date_EU($string))

  Decode_Date_US
      if (($year,$month,$day) = Decode_Date_US($string))

  Fixed_Window
      $year = Fixed_Window($yy);

  Moving_Window
      $year = Moving_Window($yy);

  Compress
      $date = Compress($year,$month,$day);

  Uncompress
      if (($century,$year,$month,$day) = Uncompress($date))

  check_compressed
      if (check_compressed($date))

  Compressed_to_Text
      $string = Compressed_to_Text($date);

  Date_to_Text
      $string = Date_to_Text($year,$month,$day);

  Date_to_Text_Long
      $string = Date_to_Text_Long($year,$month,$day);

  English_Ordinal
      $string = English_Ordinal($number);

  Calendar
      $string = Calendar($year,$month[,$orthodox]);

  Month_to_Text
      $string = Month_to_Text($month);

  Day_of_Week_to_Text
      $string = Day_of_Week_to_Text($dow);

  Day_of_Week_Abbreviation
      $string = Day_of_Week_Abbreviation($dow);

  Language_to_Text
      $string = Language_to_Text($lang);

  Language
      $lang = Language();
      Language($lang);
      $oldlang = Language($newlang);

  Languages
      $max_lang = Languages();

  Decode_Date_EU2
      if (($year,$month,$day) = Decode_Date_EU2($string))

  Decode_Date_US2
      if (($year,$month,$day) = Decode_Date_US2($string))

  Parse_Date
      if (($year,$month,$day) = Parse_Date($string))

  ISO_LC
      $lower = ISO_LC($string);

  ISO_UC
      $upper = ISO_UC($string);

  Version
      $string = Date::Calc::Version();


=head1 重要な注釈

(共通の問題を解決するためには、このドキュメントの下にあるレシピの項を見てください。)

=item * 2000年問題対応 

このモジュールにおける年の数の上限は、最も大きな正の整数の大きさによって決められています。
その数はあなたのシステム上におけるC言語におけるint型の変数によって表現されます。
そして、ANSI C standardによれば少なくとも32767です(例外は下を見てください)

単純な計算をするために、このモジュールは紀元1年までさかのぼります。この暦がカトリックのPope Gregory13世によって最初に決められた1582年より前です。

そのため、B<例えば1998年と言いたい時には、いつでも1998年と表記してください。決して代りに98年と書いてはいけません。>
何でかと言えば、そうすると実際は1998年ではなくて紀元98年を元に計算してしまいます。

自身の名前に"compress"という単語を含んでいる関数(これらの関数は、1970年から2069年まででのみ動作し、"00"から"99"までの省略を受け付けます)
そして、"Decode_Date_"で始まる名前の関数(これらは"moving window"として知られている方法を使って、100より小さな数を変換します)
はこの規則の例外です。
(訳者注：moving windowっていうのがなんなのか良く分かりません・・・多分知らなくてもいいとは思いますが)

2桁の数字を、少なくとも最近の年くらいはきちんとした4桁の年の数に変換したいならば、
"Fixed_Window()" と "Moving_Window()"の二つの関数を使ってください。(使い方はずっと下のほうにあります)

以下のimportしたりexportする関数は、とても限られた範囲に代表される日時しか扱えないと記しておきます。
それらはPOSIX関数である"time()"、"gmtime()"、"localtime()"、"mktime()"のインターフェイスもしくは、
"localtime()"と"mktime()"の代りであるBSD関数の"timegm()"そしてPOSIX関数の"gmtime()"のインターフェースです。
それとは対照的に、このパッケージ内の他の全ての関数では、仮想的に紀元1年1月1日から全ての日を網羅しています。

              System_Clock()
              Today()
              Now()
              Today_and_Now()
              This_Year()
              Gmtime()
              Localtime()
              Mktime()
              Timezone()
              Date_to_Time()
              Time_to_Date()

これらの関数は、01-Jan-1970 00:00:00 GMTから19-Jan-2038 03:14:07 GMTまでの範囲しか扱えません。
(しかしながら19-Jan-2038 03:14:07 GMTというのは、権威のある32ビットシステムでだけで、
原理的にはちょっとだけコードを修正すれば64ビットシステムでも使えるはずです)

MacOS Classicでは、扱える日の範囲は、両端を含んでlocaltimeで01-Jan-1904 00:00:00 から 06-Feb-2040 06:28:15となっています。

さらに、"Easter_Sunday()"関数は、1583年から2299年の範囲の年だけを扱うことが出来ると記しておきます。


=item * 最初の目次 

このモジュールにおいては、B<全ての>範囲は1から始まります。B<0ではありません>

例えば、ある月の日付、週の中の日、年の中の日付、年の中の月、年の中の週、
最初の意味のある年の数、そして言語はB<全て>1から数え始めます。B<0ではありません。>

唯一の例外は、"Week_Number()"関数(この関数は、与えられた日が実は前年の最後の週にある場合に0を返します)、
そしてもちろん、時間は(0..23)、分は(0..59)、秒は(0..59)です。

=item * 関数命名のきまり

以下の場合は完全に、関数の名前がどんな値を返すかを暗示しています。

=item * 真偽値

このモジュールにおける真偽値は、常に偽を表すのには数値の0、真を表すのには数値の1です。

=item * 例外処理 

このモジュールの関数は、常に入力されたパラメーター・中間の値・出力の値が範囲外である場合は、
対応するエラーメッセージと共に終了します。

以下の関数は、異なる形でエラーを用います。

  -  check_date()
  -  check_time()
  -  check_business_date()
  -  check_compressed()
(これらは、入力されたものが意味のある日や時間でなければ偽の値を返します)

  -  Nth_Weekday_of_Month_Year()
(この関数は、求められた第5週の日が存在しなければ、空のリストを返します)

  -  Decode_Month()
  -  Decode_Day_of_Week()
  -  Decode_Language()
  -  Fixed_Window()
  -  Moving_Window()
  -  Compress()
(これらは、失敗したり無意味な入力に対しては偽を返します)

  -  Decode_Date_EU()
  -  Decode_Date_US()
  -  Decode_Date_EU2()
  -  Decode_Date_US2()
  -  Parse_Date()
  -  Uncompress()
(これらは、失敗したり無意味な入力に対しては、空のリストを返します)

あなたはいつでもこのモジュール内のどの関数の例外も取得できますし、
evalで囲われた関数呼び出しを、渦巻状の括弧と特殊変数"$@"の値をチェックしながら使うことで、
その例外をあなた自身が扱うことができます。
詳しくは、perlfunc(1)の"eval"の項を読んでください。


=head1 解説

=item * use Date::Calc qw( Days_in_Year Days_in_Month ... ); 

=item * use Date::Calc qw(:all); 

関数を明確にインポートをしたければ、"qw()"の括弧の中に列挙することもできますし、
":all"を使うことで、全ての関数をインポートすることも可能です。

=item * $days = Days_in_Year($year,$month); 

この関数は、"$year"で与えられた年の、1月から始まり"$month"を含む月までにある日数の和を返します。

例："Days_in_Year(1998,1)"と書けば"31"が返り、"Days_in_Year(1998,2)"ならば"59"、
"Days_in_Year(1998,3)"なら"90"といった具合です。

ちなみに"Days_in_Year($year,12)"は、"$year"で与えられた年の日数を返します。すなわち、"365"もしくは"366"です。

=item * $days = Days_in_Month($year,$month); 

この関数は、"$year"で与えられた年の、"$month"で与えられた月の日数を返します。
うるう年かどうかを判定することが2月にしか影響がないとはいえ、"$year"は必ずなくてはいけません。


例："Days_in_Month(1998,1)"だと"31"が返り、"Days_in_Month(1998,2)"だと"28"、"Days_in_Month(2000,2)"ならば"29"、"Days_in_Month(1998,3)"ならば"31"、他も同じです。


=item * $weeks = Weeks_in_Year($year); 

この関数は、"$year"で与えられた年の週の数を返します。つまり、"52"か"53"です。

=item * if (leap_year($year)) 

この関数は、"$year"で与えられた年がうるう年なら"true"、すなわち"1"を返し、そうでなければ"false"、すなわち"0"を返します。


=item * if (check_date($year,$month,$day)) 

この関数は、"$year"、"$month"、"$day"の3つの数値が、日付として意味を持てば"true" ("1")を返し、そうでなければ"false" ("0")を返します。

=item * if (check_time($hour,$min,$sec)) 

この関数は、"$hour"、"$min"、"$sec"の3つの数値が意味のある時間、すなわち(0 <= $hour < 24, 0 <= $min < 60 and 0 <= $sec < 60)を満たせば
"true" ("1")を返し、そうでなければ"false" ("0") を返します。

=item * if (check_business_date($year,$week,$dow)) 

この関数は、"$year"、"$week"、"$dow"、の3つの数値がビジネスフォーマット上で存在する日を構成していれば"true" ("1")、そうでなければ "false" ("0")を返します。
(訳者注：$dowはDayOfYearの略語です。また、ビジネスフォーマットの良い訳があれば教えてください)

注意して欲しいのは、この関数は与えられた日が仕事のある日(つまり月曜から金曜)かどうかはB<計算しません>。
そんな時には代りに"(Day_of_Week($year,$month,$day) < 6)"としてください。


=item * $doy = Day_of_Year($year,$month,$day); 

この関数は、与えられた年の中における、与えられた日の(相対的な)順番を返します。

例えば、 "Day_of_Year($year,1,1)"なら"1"だし、"Day_of_Year($year,2,1)"なら"32"、
"Day_of_Year($year,12,31)" ならば"365"か"366"です。

=item * $days = Date_to_Days($year,$month,$day); 

この関数は、紀元1年1月1日から数え始めた時の、与えられた日の(絶対的な)順番を返します

すなわち、"Date_to_Days(1,1,1)"ならば"1"、"Date_to_Days(1,12,31)"ならば"365"、"Date_to_Days(2,1,1)"ならば"366"、"Date_to_Days(1998,5,1)"ならば"729510"といった具合です。

これは、時に(とても正しいとはいえない)ユリウス暦も参照する。
その年の月の数(1から365もしくは366)はしばしばユリウス暦のことを指すので、混乱を引き起こすかもしれない。

実際問題として、グレゴリオ暦の前に使われていたのはユリウス暦(この名称はローマ時代に研究したかの有名なユリウス・シーザーの名前から取られた)である。
ユリウス暦は、年の正確な長さに合わせるためにあまりに多くのうるう年があり、
例えば自身の統治の延長等のため、勝手気ままにルールが変わるのであまり正確ではない。
(訳者注：この辺りの訳がこんがらがっています・・・・)

この関数によって返された値から、日付を取るには、
このように"Add_Delta_days"関数を使う。(ずっと下で解説してある)

  $days = Date_to_Days($year,$month,$day);
  ($year,$month,$day) = Add_Delta_Days(1,1,1, $days - 1);



