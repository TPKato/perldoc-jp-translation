=pod

=head1 NAME

=head1 名前

Tutorial - extended CGI::Session manual

Tutorial - CGI::Sessionのさらに広範囲に渡って記述されたマニュアル

=head1 STATE MAINTANANCE OVERVIEW

=head1 状態メンテナンスの大要

Since HTTP is a stateless protocol, each subsequent click to a web site is treated as new by the web server. The server does not relate the visits with previous one, thus all the state information from the previous requests are lost. This makes creating such applications as shopping carts, login/authentication routines, secure restricted services in the web impossible. So people had to do something against this despair situation HTTP was putting us in.

HTTPはステートレスなプロトコルですので、WEBサイトに対するそれぞれの
webサイトに対するクリックはwebサーバーによって新しい訪問として扱われます。
サーバーは直前の訪問とは無関係です。したがって全てのそれ以前のリクエスト
からの状態は失われます。このことによってショッピングカートや、
ログイン認証ルーチン、セキュリティー上の制限を設けるようなサービスなどは
web上で不可能になります。よって人々はHTTPが我々を絶望的な状況に投げ入れる
ことに対して何らかの対策を取らなければなりませんでした。

For our rescue come such technologies as HTTP Cookies and QUERY_STRINGs that help us save the users' session for a certain period. Since cookies and query_strings alone cannot take us too far B<RFC 2965, Section 5, "Implementation Limitations">, several other libraries/technologies have been developed to extend their capabilities and promise a more reliable and a more persistent system. CGI::Session is one of them.

我々を救うべく、一定期間ユーザーのセッションを保つHTTPクッキーや
クエリ文字列と言った技術が誕生しました。クッキー及びクエリ文字列だけでは
B<RFC 2965, Sesctoin 5, "Implementation Limitations">に記述されている通り
我々を救うにはほど遠いものがあり、いくつか別のライブラリ/技術がさらなる
機能とさらなる信頼性、及び継続性を保つシステムを約束するために
開発されています。CGI::Sessionはそれらの中の一つです

Before we discuss this library, let's look at some alternative solutions.

=head2 COOOKIE

=head2 クッキー

Cookie is a piece of text-information that a web server is entitled to place in the user's hard disk, assuming a user agent (i.e.. Web Browser) is compatible with the specification. After the cookie being placed, user agents are required to send these cookies back to the server as part of the HTTP request. This way the server application ( CGI ) will have a way of relating previous requests by the same user agent, thus overcoming statelessness of HTTP.

Although cookies seem to be promising solutions for the statelessness of HTTP, they do carry certain limitations, such as limited number of cookies per domain and per user agent and limited size on each cookie. User Agents are required to store at least 300 cookies at a time, 20 cookies per domain and allow 4096 bytes of storage for each cookie. They also rise several Privacy and Security concerns, the lists of which can be found on the sections 6-B<"Privacy"  and 7-"Security Considerations"> of B<RFC 2965> respectively.

=head2 QUERY STRING

=head2 クエリ文字列

Query string is a string appended to URL following a question mark (?) such as:

クエリ文字列とはこのようなURLのクエスチョンマーク(?)に続く文字列です。

    http://my.dot.com/login.cgi?user=sherzodr&password=topSecret

As you probably guessed already, it can also help you to pass state information from a click to another, but how secure is it do you think? Considering these URLs tend to get cached by most of the user agents and also logged in the servers access log, to which everyone can have access to, it is not secure.

おそらくあなたは既にこの解法を使っていたのではないかと思われます。
クエリ文字列でも別の場所へのクリックによる状態を渡すのを助けますが、
あなたはどれだけ安全なものかと言うことを考えていますか？これらのURLが
大半のユーザーエージェントによって誰もがアクセスできるサーバーのアクセスログに
残しがちだと言うことを念頭に置くと、安全であるとは言いがたいです。

=head2 HIDDEN FIELDS

=head2 隠しフィールド

Hidden field is another alternative to using query strings and they come in two flavors: hidden fields used in POST methods and the ones in GET. The ones used in GET methods will turn into a true query string once submitted, so all the disadvantages of QUERY_STRINGs do apply. Although POST requests do not have limitations of its sister-GET, the pages that hold them do the cached by web browser, and are available within the source code of the page (obviously). They also become unwieldily to manage when one has oodles of state information to keep track of ( for instance, a shopping cart or an advanced search engine).

隠しフィールドはクエリ文字列の代わりに使用されるもう一つの選択肢であり、
隠しフィールドはPOSTメソッド及びGETメソッドの両方で用いられると言う
特性があります。GETメソッドで用いられる隠しフィールドは一度サブミットされると
本物のクエリ文字列に返信してしまうため、クエリ文字列を送信するのと比べて
何の進歩もありません。しかしながらPOSTリクエストは姉貴分であるGETのような
制限が無いのですが、それらを持つページをブラウザによってキャッシュさせる
ことができ、(もちろん)ページのソースコードの範囲で有効になってしまいます。
多数のステート情報を記憶させておくとなる際にも扱いにくくなります。
(例えばショッピングカートや優れたサーチエンジンです。)

Query strings and hidden fields are also lost easily by closing the browser, or by clicking the browser's "Back" button.

クエリ文字列及び隠しフィールドはブラウザを閉じるか、さもなくばブラウザの
"戻る"ボタンをクリックすることで簡単に失われてしまいます。

=head2 SERVER SIDE SESSION MANAGEMENT

=head2 サーバーサイドセッション管理

This technique is built upon the aforementioned technologies plus a server-side storage device, which saves the state data for a particular session. Each session has a unique id associated with the data in the server. This id is also associated with the user agent in either the form of a cookie, a query_string parameter, a hidden field or all at the same time.

このテクニックは前述した技術にサーバーサイドでのストレージデバイスを
プラスしたものを基に構築されており、状態のデータを特定のセッションとして
保存します。それぞれのセッションはサーバー内のデータによって連想された
ユニークなidを所持しています。このidはユーザーエージェンと側でクッキーや、
クエリ文字列や隠しフィールド、又はその全てを同時に行う言ういずれかの形でも
連想されます。

Advantages:

進展した箇所:

=over 4

=item *

We no longer need to depend on the User Agent constraints in cookie amounts and sizes

私達はもはやクッキーの量やサイズと言ったユーザーエージェントの制限に
依存する必要が無くなったのです。

=item *

Sensitive data like user's username, email address, preferences and such no longer need to be traveling across the network at each request (which is the case with query strings, cookies and hidden_fields). Only thing that travels across the network is the unique id generated for the session ("ID-1234", for instance), which should make no sense to bad guys whatsoever.

ユーザーのユーザー名やEメールアドレス、嗜好のような敏感なデータ類は
もうそれぞれのリクエストごとにネットワーク上を行き来する必要がなくなったの
です。(クエリ文字列、クッキー及び隠しフィールドに対してのことを言っています)。
ネットワーク上を行き来するのはセッションのために生成されたユニークなidのみで
(例えば"ID-1234"です)、例えどんな悪い奴にとっても意味をなさないはずです。


=item *

User will not have sensitive data stored in his computer in an unsecured plain text format (which is a cookie file).

ユーザーはセキュアでない平文型式のデータ(クッキーファイルのことです。)が
コンピュータ内に保存されていることに神経を尖らせる必要が無くなるのです。

=item *

It's possible to handle very big and even complex (in-memory) data structures transparently.

巨大で複雑でさえもある(メモリ内の)データ構造を透過的に扱うことが可能と
なります。

=back

That's what CGI::Session is all about - implementing server side session management. Now is a very good time to get the feet wet.

これがCGI::Sessionに関する全てです - サーバーサイドセッション管理の実装。
今こそそのぬかるみから足を踏み出す好機なのです。

=head1 PROGRAMMING STYLE

=head1 プログラミングスタイル

Server side session management system might be seeming awfully convoluted if you have never dealt with it.  Fortunately, with CGI::Session this cumbersome task can be achieved in much elegent way, all the complexity being handled by the library transparently. This section of the manual can be treated as an introductory tutorial to  both logic behind session management, and to CGI::Session programming style.

もしあなたがサーバーサイドセッション管理システムを扱ったことが無ければ
それが凄まじく入り組んだ物のように思えるのかもしれません。好運なことに、
CGI::Sessionこの扱いにくい処理はエレガントな手法によって、全ての複雑さを
ライブラリを用いることで透過的に扱うことを可能にするのです。マニュアルの
このセクションはセッション管理の背後にあるロジックと、CGI::Sessionの
プログラミングスタイルについての両方の導入チュートリアルとして扱ってもらって
不遜はありません。

=head1 WHAT YOU NEED TO KNOW FIRST

=head1 最初にあなたが知るべき事

The syntax of the CGI::Session 3.x has changed from previous releases. But we still keep supporting the old syntax for backward compatibility. To help us do this, in the initial releases of 3.x interface we introduced an '-api3' switch:

CGI::Session 3.xの文法は以前のリリースから変貌を遂げました。しかし我々はまだ
前バージョンと互換を取るために、継続して古い文法をサポートし続けています。
そのため、3.xインターフェースの初期のリリースに関して我々は'-api3'スイッチを
導入しました:

    use CGI::Session qw/-api3/;

It tells the library that you will be using the new syntax. But in latest releases of the library, it will detect and turn it out automaticly. So no "-api3" switch is necessary any longer. Please don't ask us anything about the old, 2.x api if you have never used it. We won't tell you!

これによってライブラリに新しい文法を使うことを伝えるのです。しかしライブラリの
最新リリースでは、自動的に探知するでしょう。つまり"-api3"スイッチをもはや
呼び出す必要が無くなるのです。あなたが古い2.xのapiをもう使わないというならば、
我々にそのことを尋ねるのはどうかお止め下さい。我々はあなたに何も教えない
でしょう。

But before you start using the library, you will need to decide where and how you want the session data to be stored in disk. In other words, you will need to tell what driver to use. You can choose either of "File", "DB_File" and "MySQL" drivers, which are shipped with the distribution by default. Examples in this document will be using "File" driver exclusively to make sure the examples are accessible in all machines with the least requirements. To do this, we create the session object like so:

しかし本ライブラリを使い始める前に、どこにどうやってセッションデータを
ディスクに保存するのかを決断する必要があるでしょう。言い替えればどのドライバ
を使うのかを伝えなければなりません。あなたはデフォルトでディストリビュー
ションに搭載されている"File", "DB_File"及び"MySQL"ドライバのいずれかを選択
することが可能です。このドキュメントでは要求するものがもっとも少ないため
理解しやすい"File"ドライバを用いた例を示します。実行するには次のように
セッションオブジェクトを作成して下さい。

    use CGI::Session;
    $session = new CGI::Session("driver:File", undef, {Directory=>'/tmp'});

The first argument is called Data Source Name (DSN in short). If it's undef, the library will use the default driver, which is "File". So instead of being explicit about the driver as in the above example, we could simply say:

一つ目の引数は呼び出されるデータソース(略してDSN)の名前です。undefであれば、
ライブラリはデフォルトのドライバ、「File」を使用するでしょう。よって、
下記の例のようにドライバに関しては明示的に示す代わりにこのように表現する
ことも可能です:

    $session = new CGI::Session(undef, undef, {Directory=>'/tmp'});

and we're guaranteed it will fall back to default settings.

これにより、デフォルトの設定になることが保証されます。

The second argument is session id to be initialized. If it's undef, it will force CGI::Session to create a new session. Instead of passing a session id, you can also pass a CGI.pm object, or any other object that can implement either of cookie() or param() methods. In this case, the library will try to retrieve the session id from either B<CGISESSID> cookie or B<CGISESSID> CGI parameter (query string)

２つ目の引数は初期化用のセッションidです。もしundefであれば、CGI::Sessionに
新しいセッションを強制的に作らせます。session idを渡す代わりに、CGI.pm
オブジェクトを渡すか、さもなくばcookie()あるいはparam()メソッドのいずれかを
実装したオブジェクトを渡すことも可能です。このケースでは、ライブラリは
B<CGISESSID>クッキーあるいはB<CGISESSID>CGIパラメータ(クエリ文字列)の
いずれかよりセッションidを取得しようと試みるでしょう。

The third argument should be in the form of hashref. This will be used by specific CGI::Session driver only. For the list of all the available attributes, consult respective CGI::Session driver:

３番目の引数はハッシュのリファレンスと言う形であるべきです。これは特定の
CGI::Sessionドライバにのみ適用されます。使用可能な全属性の一覧を見たい場合は
それぞれのCGI::Sessionドライバを参照願います。

=over 4

=item *

L<File|CGI::Session::File> - default driver for storing session data in plain files. Full name: B<CGI::Session::File>

L<File|CGI::Session::File> - 平文でセッションデータを格納するためのデフォルトの
ドライバです。フルネーム: B<CGI::Session::File>

=item *

L<DB_File|CGI::Session::DB_File> - for storing session data in BerkelyDB. Requires: L<DB_File>. Full name: B<CGI::Session::DB_File>

L<DB_File|CGI::Session::DB_File> - BerkelyDBにセッションデータを格納します。
必要物: L<DB_File>。フルネーム: B<CGI::Session::DB_File>

=item *

L<MySQL|CGI::Session::MySQL> - for storing session data in MySQL tables. Requires L<DBI|DBI> and L<DBD::mysql|DBD::mysql>. Full name: B<CGI::Session::MySQL>

L<MySQL|CGI::Session::MySQL> - MySQLテーブルにセッションを格納します。
必要物L<DBI|DBI>及びL<DBD::mysql|DBD::mysql>。フルネーム: B<CGI::Session::MySQL>

=back

Note: You can also write your own driver for the library. Consult respective
section of this manual for details.

Note: あなたは本ライブラリのためにドライバを自身で書くことも可能です。
このマニュアルの詳細の各セクションを隅々まで御覧下さい。

=head1 CREATING NEW SESSION

=head1 新しいセッションの作成

To generate a brand new session for a user, just pass an undefined value as the second argument to the constructor - new():

ユーザーに対する新しいセッションと言う焼き印を生成するためには、コンストラクタ
- new()に未定義の値を２つ目の引数に渡すだけで構いません。

    $session = new CGI::Session("driver:File", undef, {Directory=>"/tmp"});

Directory refers to a place where the session files and their locks will be stored in the form of separate files. When you generate the session object, as we did above, you will have:

ディレクトリはセッション分散したファイルの形で格納されるであろうファイル及び
そのロックの場所を示します。セッションオブジェクトを生成する際には、
私が上記に示したことをするために、次の手順が踏まれるでしょう:

=over 4

=item 1

Session ID generated for you and

あなたのためにセッションIDは生成され

=item 2

Storage file associated with the id in the directory you specified.

あなたが指定したディレクトリ中からidによって格納されたファイルが連想されます。

=back

From now on, in case you want to access the newly generated session id just do:

これからは、あなたが新しく生成されたセッションidにアクセスしたい場合は
ただこうすれば良いのです。

    $sid = $session->id();

It returns a string something similar to B<a983c8302e7a678a2e53c65e8bd3316> which you can now send as a cookie or use as a query string or in your forms' hidden fields. Using standard L<CGI> library we can send the session id as a cookie to the user's browser like so:

クッキーとして送信される、あるいはクエリ文字列やフォーム内の隠しフィールドと
してそのまま用いられることが可能なB<a983c8302e7a678a2e53c65e8bd3316>と言った
文字列を返します。

    $cookie = $cgi->cookie(CGISESSID => $session->id);
    print $cgi->header( -cookie=>$cookie );

If anything in the above example doesn't make sense, please consult L<CGI> for the details.

もし上記の方法ではダメだと言うのであれば、L<CGI>の詳細とを御覧下さい。

=head2 INITIALIZING EXISTING SESSIONS

=head2 既存のセッションを初期化する

When a user clicks another link or re-visits the site after a short while should we be creating a new session again? Absolutely not. This would defeat the whole purpose of state maintenance. Since we already send the id as a cookie, all we need is to pass that id as the seconds argument while creating a session object:

ユーザーが他のリンクやちょっと間を置いてサイトを再訪問した際、我々は再び
新しいセッションを作成しなくてはならないのでしょうか？もちろん違います。
これではセッションの維持と言う目的を打ち負かしてしまうことになるのですから。
我々がクッキーとして既にidを送信していたら、我々が皆必要とするものは
セッションオブジェクトが生成されている間２つ目の引数としてそのidを渡すこと
のみです。

    $sid = $cgi->cookie("CGISESSID") || undef;
    $session    = new CGI::Session(undef, $sid, {Directory=>'/tmp'});

The above syntax will first try to initialize an existing session data, if it fails ( if the session doesn't exist ) creates a new session: just what we want. But what if the user doesn't support cookies? In that case we would need to append the session id to all the urls as a query string, and look for them in addition to cookie:

下記の文法ではまずはじめに既存のセッションデータを初期化しようとし、もし
新しいセッションファイルを生成する場合(セッションが存在しない場合)でも、
我々が意図した結果となります。しかし、もしユーザーがクッキーをサポート
していない場合はどうなるのでしょうか？その場合我々はクエリ文字列として全ての
urlに追加する必要があります。クッキーを追加する方法を御覧下さい:

    $sid = $cgi->cookie('CGISESSID') || $cgi->param('CGISESSID') || undef;
    $session = new CGI::Session(undef, $sid, {Directory=>'/tmp'});

Assuming you have CGI object handy, you can minimize the above two lines into one:

あなたがCGIオブジェクトの扱いがお手のものと仮定して、上記の２行を１行に
納めることが可能です:

    $session = new CGI::Session(undef, $cgi, {Directory=>"/tmp"});

If you pass an object, instead of a string as the second argument, as we did above, CGI::Session will try to retrieve the session id from either the cookie or query string and initialize the session accordingly. Name of the cookie and query string parameters are assumed to be B<CGISESSID> by default. To change this setting, you will need to invoke C<name()> class method on either CGI::Session or its object:

もし２つ目の引数として文字列の代わりにオブジェクトを渡すと、CGI::Sessionは
クッキーあるいはクエリ文字列からセッションidを取得しようと試み、適宣に
セッションを初期化します。クッキー及びクエリ文字列のパラメータはデフォルトで
B<CGISESSID>であると仮定します。この設定を変更するためには、CGI::Session
あるいはそのオブジェクトのうちいずれかのC<name()>クラスメソッドを呼び出す
必要があるでしょう:

    CGI::Session->name("MY_SID");
    # or

    # 又は

    $session->name("MY_SID");

    $session = new CGI::Session(undef, $cgi, {Directory=>'/tmp'});

=head2 STORING DATA IN THE SESSION

=head2 セッションにデータを格納する

To store a single variable in the object use C<param()> method:

C<param()>メソッドを用いてオブジェクト内に値を一つ格納するためには:

    $session->param("my_name", $name);

You can use C<param()> method to store complex data such as arrays, hashes, objects and so forth. While storing arrays and hashes, make sure to pass them as a reference:

あなたは配列や、ハッシュやオブジェクトなどのような複雑なデータを格納するために
C<param()>メソッドを用いることが可能です。配列及びハッシュを格納する際は、
リファレンスとして渡さなければなりません:

    @my_array = ("apple", "grapes", "melon", "casaba");
    $session->param("fruits", \@my_array);

You can store objects as well:

同様にオブジェクトも格納することが可能です: 

    $session->param("cgi", $cgi);   # stores CGI.pm object

    $session->param("cgi", $cgi);   # CGI.pmオブジェクトを格納します

Sometimes you wish there was a way of storing all the CGI parameters in the session object. You would start dreaming of this feature after having to save dozens of query parameters from each form element to your session object. Consider the following syntax:

あなたが望むセッションオブジェクト内にCGIのパラメータを全て格納する方法も
存在します。あなたはセッションオブジェクトに各フォームの要素からの
あなたは後で多数のクエリパラメータを格納しなければならないためににこの形式を
望むことだと思われます。以下の文法を御覧下さい:

    $session->save_param($cgi, ["keyword", "category", "author", "orderby"]);

save_param() makes sure that all the above CGI parameters get saved in the session object. It's the same as saying:

save_param()は上記の全CGIパラメータをセッションオブジェクトに格納させる
でしょう。これは以下と同様のことを言っています。

    $session->param("keyword",  $cgi->param("keyword"));
    $session->param("category", $cgi->param("category"));
    # etc... for all the form elements

    # などなど全てのフォーム要素に対して

In case you want to save all the CGI parameters. Just omit the second argument to C<save_param()>:

全CGIパラメータを保存したい場合ですが、C<save_param()>の２つ目の引数を省略
するだけです:

    $session->save_param($cgi);

The above syntax saves all the available/accessible CGI parameters

上記の文法は全ての使用可能/アクセス可能なCGIパラメータを保存します。

=head2 ACCESSING STORED DATA

=head2 保存されたデータへのアクセス

There's no point of storing data if you cannot access it. You can access stored session data by using the same C<param()> method you once used to store them:

もしあなたがデータにアクセスできないならば、保存されたデータに接点がないの
です。あなたは一度データを保存するのに用いた同じC<param()>で保存されたデータに
アクセスすることが可能です。

    $name = $session->param("my_name");

Above form of param() retrieves session parameter previously stored as "my_name". To retrieve previously stored @my_array:

上記のparam()の形式では"my_name"として過去に保存されたセッションのパラメータを
取得します。過去に保存された@my_arrayを取り出すには:

    $my_array = $session->param("fruits");

It will return a reference to the array, and can be dereferenced as @{$my_array}.

配列へのリファレンスが戻って来るでしょう。そして、@{$my_array}として参照する
事が可能です。

Very frequently, you may find yourself having to create a pre-filled and pre-selected forms, like radio buttons, checkboxes and drop down menus according to the user's preferences or previous action. With text and textareas it's not a big deal: you can simply retrieve a single parameter from the session and hardcode the value into the text field. But how would you do it when you have a group of radio buttons, checkboxes and scrolling lists? For this purpose, CGI::Session provides load_param() method, which loads given session parameters to a CGI object (assuming they have been previously saved with save_param() method or alternative):

あなたはユーザーの好みや以前のアクションに応じた入力済、あるいは選択済の
ラジオボタンやチェックボックス、ドロップダウンメニューなどのフォームを
とても頻繁に作らなくてはならないだろうことに気づいているかと思われます。
textやtextareasならそれほど大したことではありません: 単に一つのパラメータを
セッションから取得し、textフィールドにハードコーディングすれば良いのですから。」しかしラジオボタンやチェックボタン、スクロールするリストのグループを
扱うとき、あなたはどうするでしょう？この目的のため、CGI::Sessionはload_param()
メソッドを提供しており、CGIオブジェクトに与えられたセッションパラメータを
読み出します (save_param()メソッドあるいはその他の選択肢で過去に保存されている
と仮定して):

    $session->load_param($cgi, ["fruits"]);

Now you can use CGI.pm to generate those preselected checkboxes:

さて、CGI.pmを使って選択済のチェックボックスを生成するには:

    print $cgi->checkbox_group(fruits=>['apple', 'banana', 'appricot']);

If you're making use of HTML::Template to separate the code from the skins, you can as well associate CGI::Session object with HTML::Template and access all the parameters from within HTML files. We love this trick!

もしあなたがHTML::Templateを用いることでスキンからコードを分離させる場合、
HTML::Templateを用いてCGI::Sessionオブジェクトをassociateすることによって
同様のことが可能になります。我々はこのトリックが大好きです。

    $template = new HTML::Template(filename=>"some.tmpl", associate=>$session);
    print $template->output();

Assuming the session object stored "first_name" and "email" parameters while being associated with HTML::Template, you can access those values from within your "some.tmpl" file now:

HTML::Templateでassociateする間、セッションオブジェクトに"first_name"及び
"email"パラメータが格納されていると仮定すると、"some.tmpl"ファイルを用いて
それらの値にアクセスできます:

    Hello <a href="mailto:<TMPL_VAR email>"> <TMPL_VAR first_name> </a>!

For more tricks with HTML::Template, please refer to the library's manual (L<HTML::Template>) and L<CGI Session CookBook|CGI::Session::CookBook>.

HTML::Templateによるさらなるトリックを知りたい場合はライブラリマニュアル
(L<HTML::Template>及びL<CGI Session CookBook|CGI::Session::CookBook>。

=head2 CLOSING THE SESSION

=head2 セッションを閉じる

Normally you don't have to close the session explicitly. It gets closed when your program terminates or session object goes out of scope. However in some few instances you might want to close the session explicitly by calling CGI::Session's C<close()> method or undefining the object. What is closing all about - you'd ask. While session is active, updates to session object doesn't get stored in the disk right away. It stores them in the memory until you either choose to flush the buffer by calling C<flush()> method or destroy the session object by either terminating the program or calling close() method explicitly.

通常あなたは明示的にセッションを閉じる必要はありません。プログラムが終了する
か、あるいはセッションオブジェクトがスコープからはずれた際、セッションが閉じ
られます。しかしながら時にはCGI::Sessionの<close()>メソッドあるいはオブジェ
クトを未定義にすることによってセッションを明示的に閉じたい場合があるかもしれ
ません。セッションを閉じるとは一体全体何なのでしょう？ - あなたは尋ねるでしょ
う。セッションがアクティブな間、ディスク内のセッションオブジェクトの更新が
すぐに行われるわけではありません。C<flush()>メソッドでバッファをフラッシュさ
せると言う選択肢をとるかあるいはプログラムを終了させるかあるいはclose()メソッ
ドを明示的に呼び出してセッションを破棄するまではメモリ内に保存されます。

In some circumstances you might want to close the session but at the same time don't want to terminate the process for a while. Might be the case with GUI and in daemon applications. In this case close() is what you want. Note: we prefer simpl undefing the session rather than calling close() method. close() is less efficient):

状況によってはセッションを閉じたいもののプロセスをしばらくの間終了させたくない
場合もあるかと思われます。おそらくそのようなケースはGUI及びデーモンアプリケー
ションによるものだと思われます。この場合close()こそがあなたが求めていたもの
なのです。Note: 我々はclose()よりもシンプルな開放ようのメソッドを好みます。
(close()は機能面で劣ります。)

    undef($session);

If you want to keep the session object but for any reason want to synchronize the data in the buffer with the one in the disk, C<flush()> method is what you need.

もしあなたがセッションをオブジェクトを何らかの理由でバッファ内のデータと
ディスク内のデータを同期させたいならば、C<flush()>こそあなたの求めるものです。

Note: close() calls flush() as well. So there's no need to call flush() before calling close()

Note: close()も同様にflush()を呼び出します。したがってclose()を呼び出す前に
flush()を呼び出す必要は全く無いのです。

=head2 CLEARING SESSION DATA

=head2 セッションデータのクリア

You store session data, you access session data and at some point you will want to clear certain session data, if not all. For this purpose CGI::Session provides C<clear()> method which optionally takes one argument as an arrayref indicating which session parameters should be deleted from the session object:

セッションデータを保存し、セッションデータにアクセスすると、ある時点で
全てでなくとも、特定のセッションデータをクリアしたくなるでしょう。この目的の
ためにCGI::Sessionはセッションパラメータをオブジェクトから消すべきパラメータ
名を指示した配列のリファレンスの表現で引数を一つ取るC<clear()>メソッド
をオプショナルで提供しています。

    $session->clear(["~logged-in", "email"]);

Above line deletes "~logged-in" and "email" session parameters from the session. And next time you say:

上記の行ではセッションパラメータ"~logged-in"及び"email"をセッションから消去し
ます。そして次にこうすると:

    $email = $session->param("email");

it returns undef. If you omit the argument to C<clear()>, be warned that all the session parameters you ever stored in the session object will get deleted. Note that it does not delete the session itself. Session stays open and accessible. It's just the parameters you stored in it gets deleted

undefが戻ります。もしC<clear()>の引数を省略した場合、あなたが今までにセッショ
ンオブジェクトに格納したセッションパラメータが削除されてしまうのでお気を付け
下さい。セッションそのものを消してしまうのではないことを念頭に置いて下さい。
セッションはまだ開いていてアクセス可能です。中に格納されたパラメータが消去
されただけなのです。

=head2 DELETING A SESSION

=head2 セッションを削除する

If there's a start there's an end. If session could be created, it should be possible to delete it from the disk for good:

もし始まりが存在し終わりが存在するならば。もしセッションが作られれば、それは
ディスクから削除することが可能である方が良いに決まっています。

    $session->delete();

The above call to C<delete()> deletes the session from the disk for good. Do not confuse it with C<clear()>, which only clears certain session parameters but keeps the session open.

上記のようにC<delete()>を呼び出すことによってディスクからセッションを削除
した方が好ましいと言えます。C<clear()>と混同しないように、これは特定のセッシ
ョンパラメータをクリアしますが、セッションは開いたままです。

=head2 EXPIRATION

=head2 期限切れ

CGI::Session also provides limited means to expire session data. Expiring session is the same as deleting it via delete(), but deletion takes place automaticly. To expire a session, you need to tell the library how long the session would be valid after the last access time. When that time is met, CGI::Session refuses to retrieve the session. It deletes the session and returns a brand new one. To assign expiration ticker for a session, use the expire() method:

CGI::Sessionは期限切れの表現を目的に限られた機能を提供します。セッションの
期限切れはdelete()経由で消去することと同等ですが、削除は自動的に行われます。
セッションを期限切れにするためには、ライブラリに最終アクセス時からどれだけ
長く有効であるかを教える必要があります。時間が来れば、CGI::Sessionはセッション
を取得することを拒否します。そのことによりセッションは削除され、真新しいセッ
ションが返って来ます。セッションに対する期限切れを示す時計を割り当てるためには
expire()メソッドを用います。

    $session->expire(3600);     # expire after 3600 seconds
    $session->expire('+1h');    # expire after 1 hour
    $session->expire('+15m');   # expire after 15 minutes
    $session->expire('+1M');    # expire after a month and so on.

    $session->expire(3600);     # 3600秒後に期限切れになります
    $session->expire('+1h');    # 1時間後に期限切れになります
    $session->expire('+15m');   # 15分後に期限切れになります
    $session->expire('+1M');    # 1ヵ月後に期限切れになります


But sometimes, it makes perfect sense to expire a certain session parameter, instead of the whole session. The author usually does this in his login/authentication enabled sites, where after the user logs in successfully, sets a "_logged_in" flag to true, and assigns an expiration ticker on that flag to something like 30 minutes. It means, after 30 idle minutes CGI::Session will clear() "_logged_in" flag, indicating the user should log in over again. I aggree, the same effect can be achieved by simply expiring() the session itself, but in thise we would loose other session parameters, such as user's shopping cart, session-preferences and the like.

# これはtypo?  (thise -> these?)

しかし時には、セッション全体に対する有効期限の代わりに完全に特定パラメータ
のみに限定した有効期限を設定することもできます。作者はログイン成功後に
"_logged_in"フラグを真に設定し、30分間と言ったある有効期限をフラグに割り当てる
ようなログイン/認証可能なサイトでこのことは大抵行われています。これは30分間
アイドルした後、CGI::Sessionが"_logged_in"フラグをclear()し、もう一度ユーザー
はログインしなおさなくてはならないことを示しています。私は単にexpiring()を
セッションそのものによって成し遂げられ得るのと同じであることを認めますが、
これらの方法ではその他のセッションパラメータが失われるでしょう。ショッピング
カートなどのセッションではこちらの方が好ましいと言えます。


This feature can also be used to simulate layered security/authentication, such as, you can keep the user's access to his/her personal profile information for as long as 10 idle hours after successful login, but expire his/her access to his credit card information after 10 idle minutes. To achieve this effect, we will use expire() method again, but with a slightly different syntax:

この形式では個人のプロフィール情報に対するログインに成功してから10時間まで
放っておいてもアクセスし続けることが可能ですが、10分間放っておくとクレジット
カードへのアクセスの期限が切れると言った、階層化されたセキュリティ認証をシミ
ュレートするのに用いることも可能です。

    $session->expire(_profile_access, '+10h');
    $session->expire(_cc_access, '+10m');

With the above syntax, the person will still have access to his personal information even after 5 idle hours. But when he tries to access or update his/her credit card information, he may be displayed a "login again, please" screen.

上記の文法によって、5時間放ったらかしにしておいてもまだ個人情報にはアクセス
できます。しかし、クレジットカード情報にアクセス、あるいは更新しようとしても、
おそらく「もう一度ログインして下さい」とスクリーンに表示されることでしょう。

This concludes our discussion of CGI::Session programming style for now (at least till the new releases of the library ). The rest of the manual covers some L<"SECUIRITY"> issues and L<"DRIVER SPECIFICATIONS"> for those want to implement their own drivers or understand the library architecture.

このことによってはCGI::Sessionのプログラミングスタイルの議論に対するさしあた
りの結論を下します(少なくとも新しくライブラリをリリースするには至りました)。
マニュアルの最後にはドライバを実装する、あるいはライブラリの構造について理解
したい方々のためにL<"セキュリティ">問題及びL<"ドライバの特性">をカバーしてい
ます。

=head1 SECURITY

=head1 セキュリティ

"How secure is using CGI::Session?", "Can others hack down people's sessions using another browser if they can get the session id of the user?", "Are the session ids guessable?" are the questions I find myself answering over and over again.

「どうやったらCGI::Sessionをセキュアに使えるの？」、「もしセッションユーザーの
セッションidを取られてしまったら他の人が別のブラウザを使ってセッションを
乗っ取ることができてしまうの？」、「セッションidは推測可能なの？」と言った
私自身何度も何度も答えていることに気づいた質問群です。

=head2 STORAGE

=head2 記憶装置

Security of the library does in many aspects depend on the implementation. After making use of this library, you no longer have to send all the information to the user's cookie except for the session id. But, you still have to store the data in the server side. So another set of questions arise, can an evil person have access to session data in your server, even if they do, can they make sense out of the data in the session file, and even if they can, can they reuse the information against a person who created that session. As you see, the answer depends on yourself who is implementing it.

ライブラリのセキュリティは実装に依存する局面が多いと言えます。このライブラリを
利用した後は、あなたはもうセッションidに関するユーザーのクッキーに対する情報を
送らなくても良いのです。しかし、あなたはまだサーバー側にデータを保存しなくては
なりません。よってもう一つの疑問が挙がって来るのですが、それは悪意のある人が
サーバー内のセッションデータにアクセスできやしないか、さらに想定外のデータが
含まれるセッションデータを作れやしないか、そしてさらにセッションを作った人に
対する情報が不正流用されやしないかと言うことです。いいですか、その答えはそれ
を実装するあなたによるのです。

First rule of thumb, do not save the users' passwords or other sensitive data in the session. If you can persuade yourself that this is necessary, make sure that evil eyes don't have access to session files in your server. If you're using RDBMS driver such as MySQL, the database will be protected with a username/password pair. But if it will be storing in the file system in the form of plain files, make sure no one except you can have access to those files.

最初のルールの概要ですが、セッションの中にはパスワードやその他きわどいデータを
保存しないことです。もしあなたが自分でこれが重要であると認識したらば、きっと
悪の目玉はサーバー内のセッションファイルにアクセスすることもないでしょう。もし
あなたがMySQLのようなRDBMSドライバを使っているのであれば、データベースは
ユーザー名/パスワードのペアで保護されているでしょう。しかしもしそれが平文の
形でファイルシステムに保存されているとしても、きっとあなたを除く誰しもがそれ
らのファイルへアクセスできないでしょう。

Default configuration of the driver makes use of Data::Dumper class to serialize data to make it possible to save it in the disk. Data::Dumper's result is a human readable data structure, which if opened, can be interpreted against you. If you configure your session object to use either Storable or FreezeThaw as a serializer, this would make more difficult for bad guys to make sense out of session data. But don't use this as the only precaution for security. Since evil fingers can type a quick program using Storable or FreezeThaw which deciphers that session file very easily.

デフォルトのドライバの設定ではディスク内に保存することを可能にするために
データをシリアライズするData::Dumperクラスを使用させることになります。
Data::Dumperの出力結果は人間が可読であるデータ構造なのですが、
このデータをオープンすればあなたが解読することができるのです。
もしStorableか又はFreezeThawのいずれかをシリアライザとして用いるために
セッションオブジェクトを設定した場合は、悪い奴らのために
セッションデータからはとは無関係な意味をなすより複雑なデータを生成する
でしょう。しかしこれはセキュリティのための警戒として用いては
なりません。悪の指がセッションファイルを復号するStorableあるいは
FreezeThawを用いた速いプログラムをいとも簡単に打ち込むことが
できてしまうからです。

Also, do not allow sick minds to update the contents of session files. Of course CGI::Session makes sure it doesn't happen, but your cautiousness does no harm either.

セッションファイルの中身を更新することに気を病むのも良くないことです。
勿論CGI::Sessionは

Do not keep sessions open with sensitive information for very long period. This will increase the possibility that some bad guy may have someone's valid session id at a given time (acquired somehow).

ALWAYS USE "-ip-match" SWITCH!!!

Read on for the details of "-ip-match".

=head2 SESSION IDs

Session ids are not easily guessable (unless you're using Incr Id generator)! Default configuration of CGI::Session uses Digest::MD5 which takes process id, time in seconds since epoch and a random number, generates a 32 character long digest out of it. Although this string cannot be guessable by others, if they find it out somehow, can they use this identifier against the other person?

Consider the scenario, where you just give someone either via email or an instant messaging a link to your online-account profile, where you're currently logged in. The URL you give to that person contains a session id as part of a query string. If the site was initializing the session solely using query string parameter, after clicking on that link that person now appears to that site as you, and might have access to all of your private data instantly. How scary and how unwise implementation. And what a poor kid who didn't know that pasting URLs with session ids could be an accident waiting to happen.

Even if you're solely using cookies as the session id transporters, it's not that difficult to plant a cookie in the cookie file with the same id and trick the web browser to send that particular session id to the server. So key for security is to check if the person who's asking us to retrieve a session data is indeed the person who initially created the session data. CGI::Session helps you to watch out for such cases by enabling "-ip_match" switch while "use"ing the library:

    use CGI::Session qw/-ip-match/;

or alternatively, setting $CGI::Session::IP_MATCH to a true value, say to 1. This makes sure that before initializing a previously stored session, it checks if the ip address stored in the session matches the ip address of the user asking for that session. In which case the library returns the session, otherwise it dies with a proper error message.

=head1 DRIVER SPECIFICATIONS

This section is for driver authors who want to implement their own storing mechanism for the library. Those who enjoy sub-classing stuff should find this section useful as well. Here we discuss the architecture of CGI::Session and its drivers.

=head2 LIBRARY OVERVIEW

Library provides all the base methods listed in the L<METHODS> section. The only methods CGI::Session doesn't bother providing are the ones that need to deal with writing the session data in the disk, retrieving the data from the disk, and deleting the data. These are the methods specific to the driver, so that's where they should belong.

In other words, driver is just another Perl library which uses CGI::Session as a base class, and provides several additional methods that deal with disk access.

=head2 SERIALIZATION

Before getting to driver specs, let's talk about how the data should be stored. When flush() is called, or the program terminates, CGI::Session asks a driver to store the data somewhere in the disk, and passes the data in the form of a hash reference. Then it's the driver's obligation to serialize the data so that it can be stored in the disk.

Although you are free to implement your own serializing engine for your driver, CGI::Session distribution comes with several libraries you can inherit from and call freeze() method on the object to serialize the data and store it. Those libraries are:

=over 4

=item L<CGI::Session::Serialize::Default|CGI::Session::Serialize::Default>

=item L<CGI::Session::Serialize::Storable|CGI::Session::Serialize::Storable>

=item L<CGI::Session::Serialize::FreezeThaw|CGI::Session::Serialize::FreezeThaw>

=back

Example:

    # $data is a hashref that needs to be stored
    my $storable_data = $self->freeze($data)

$storable_data can now be saved in the disk safely.

When the driver is asked to retrieve the data from the disk, that serialized data should be accordingly de-serialized. The aforementioned serializers also provides thaw() method, which takes serialized data as the first argument and returns Perl data structure, as it was before saved. Example:

    my $hashref =  $self->thaw($stored_data);

=head2 DRIVER METHODS

Driver is just another Perl library, which uses CGI::Session as a base class and is required to provide the following methods:

=over 4

=item C<retrieve($self, $sid, $options)>

retrieve() is called by CGI::Session with the above 3 arguments when it's asked to retrieve the session data from the disk. $self is the session object, $sid is the session id, and $options is the list of the arguments passed to new() in the form of a hashref. Method should return un-serialized session data, or undef indicating the failure. If an error occurs, instead of calling die() or croak(), we suggest setting the error message to error() and returning undef:

    unless ( sysopen(FH, $options->{FileName}, O_RDONLY) ) {
        $self->error("Couldn't read from $options->{FileName}: $!");
        return undef;
    }

If the driver detects that it's been asked for a non-existing session, it should not generate any error message, but simply return undef. This will signal CGI::Session to create a new session id.

=item C<store($self, $sid, $options, $data)>

store() is called by CGI::Session when session data needs to be stored. Data to be stored is passed as the third argument to the method, and is a reference to a hash. Should return any true value indicating success, undef otherwise. Error message should be passed to error().

=item C<remove($self, $sid, $options)>

remove() called when CGI::Session is asked to remove the session data from the disk via delete() method. Should return true indicating success, undef otherwise, setting the error message to error()

=item C<teardown($self, $sid, $options)>

called when session object is about to get destroyed, either explicitly via close() or implicitly when the program terminates

=back

=head2 GENERATING ID

CGI::Session also requires the driver to provide a generate_id() method, which returns an id for a new session. Again, you are welcome to re-invent your own wheel, but note, that CGI::Session distribution comes with couple of id generating libraries that provide you with generate_id(). You should simply inherit from them. Following ID generators are available:

=over 4

=item L<CGI::Session::ID::MD5|CGI::Session::ID::MD5>

=item L<CGI::Session::ID::Incr|CGI::Session::ID::Incr>

=back

Refer to their respective manuals for more details.

In case you want to have your own style of ids, you can define a generate_id() method explicitly without inheriting from the above libraries. Or write your own B<CGI::Session::ID::YourID> library, that simply defines "generate_id()" method, which returns a session id, then give the name to the constructor as part of the DSN:

    $session = new CGI::Session("id:YourID", undef, {Neccessary=>Attributes});

=head2 BLUEPRINT

=head2 設計図

Your CGI::Session distribution comes with a Session/Blueprint.pm file
which can be used as a starting point for your driver:

あなたのCGI::Sessionディストリビューションは
あなたのドライバのための出発点として使用される
Session/Blueprint.pmファイルともに配付されることになります。

    package CGI::Session::BluePrint;

    use strict;
    use base qw(
        CGI::Session
        CGI::Session::ID::MD5
        CGI::Session::Serialize::Default
    );

    # Load neccessary libraries below

    use vars qw($VERSION);

    $VERSION = '0.1';

    sub store {
        my ($self, $sid, $options, $data) = @_;

        my $storable_data = $self->freeze($data);

        #now you need to store the $storable_data into the disk
    }

    sub retrieve {
        my ($self, $sid, $options) = @_;

        # you will need to retrieve the stored data, and
        # deserialize it using $self->thaw() method
    }

    sub remove {
        my ($self, $sid, $options) = @_;

        # you simply need to remove the data associated
        # with the id
    }



    sub teardown {
        my ($self, $sid, $options) = @_;

        # this is called just before session object is destroyed
    }

    1;

    __END__;


After filling in the above blanks, you can do:

上記の空白を埋めることで、あなたは

    $session = new CGI::Session("driver:MyDriver", $sid, {Option=>"Value"});

and follow CGI::Session manual.

とすることがき、CGI::Sessionのマニュアルにある通りです。

=head1 COPYRIGHT

=head1 著作権

Copyright (C) 2002 Sherzod Ruzmetov. All rights reserved.

This library is free software. You can modify and distribute it under the same terms as Perl itself.

=head1 AUTHOR

=head1 作者

Sherzod Ruzmetov <sherzodr@cpan.org>. Suggestions, feedbacks and patches are welcome.

Sherzod Ruzmetov <sherzodr@cpan.org>. 提案、コメント及びパッチは歓迎します。

=head1 SEE ALSO

=head1 参考文献

=over 4

=item *

L<CGI::Session|CGI::Session> - CGI::Session manual

L<CGI::Session|CGI::Session> - CGI::Sessionマニュアル

=item *

L<CGI::Session::CookBook|CGI::Session::CookBook> - practical solutions for real life problems

L<CGI::Session::CookBook|CGI::Session::CookBook> - 実生活における実践的な解決方法

=item *

B<RFC 2965> - "HTTP State Management Mechanism" found at ftp://ftp.isi.edu/in-notes/rfc2965.txt

B<RFC 2965> - "HTTP State Management Mechanism" は ftp://ftp.isi.edu/in-notes/rfc2965.txt で見付かります。

=item *

L<CGI|CGI> - standard CGI library

L<CGI|CGI> - 標準のCGIライブラリ

=item *

L<Apache::Session|Apache::Session> - another fine alternative to CGI::Session

L<Apache::Session|Apache::Session> - もう一つのCGI::Sessionに対する素晴らしき選択肢

=back

=head1 翻訳者

三浦真磁<snj@users.sourceforge.jp>

=cut
=pod

=head1 NAME

=head1 名前

Tutorial - extended CGI::Session manual

Tutorial - CGI::Sessionのさらに広範囲に渡って記述されたマニュアル

=head1 STATE MAINTANANCE OVERVIEW

=head1 状態メンテナンスの大要

Since HTTP is a stateless protocol, each subsequent click to a web site is treated as new by the web server. The server does not relate the visits with previous one, thus all the state information from the previous requests are lost. This makes creating such applications as shopping carts, login/authentication routines, secure restricted services in the web impossible. So people had to do something against this despair situation HTTP was putting us in.

HTTPはステートレスなプロトコルですので、WEBサイトに対するそれぞれの
webサイトに対するクリックはwebサーバーによって新しい訪問として扱われます。
サーバーは直前の訪問とは無関係です。したがって全てのそれ以前のリクエスト
からの状態は失われます。このことによってショッピングカートや、
ログイン認証ルーチン、セキュリティー上の制限を設けるようなサービスなどは
web上で不可能になります。よって人々はHTTPが我々を絶望的な状況に投げ入れる
ことに対して何らかの対策を取らなければなりませんでした。

For our rescue come such technologies as HTTP Cookies and QUERY_STRINGs that help us save the users' session for a certain period. Since cookies and query_strings alone cannot take us too far B<RFC 2965, Section 5, "Implementation Limitations">, several other libraries/technologies have been developed to extend their capabilities and promise a more reliable and a more persistent system. CGI::Session is one of them.

我々を救うべく、一定期間ユーザーのセッションを保つHTTPクッキーや
クエリ文字列と言った技術が誕生しました。クッキー及びクエリ文字列だけでは
B<RFC 2965, Sesctoin 5, "Implementation Limitations">に記述されている通り
我々を救うにはほど遠いものがあり、いくつか別のライブラリ/技術がさらなる
機能とさらなる信頼性、及び継続性を保つシステムを約束するために
開発されています。CGI::Sessionはそれらの中の一つです

Before we discuss this library, let's look at some alternative solutions.

このライブラリを議論する前に、代わりの解決方法を見てみることにしましょう。

=head2 COOOKIE

=head2 クッキー

Cookie is a piece of text-information that a web server is entitled to place in the user's hard disk, assuming a user agent (i.e.. Web Browser) is compatible with the specification. After the cookie being placed, user agents are required to send these cookies back to the server as part of the HTTP request. This way the server application ( CGI ) will have a way of relating previous requests by the same user agent, thus overcoming statelessness of HTTP.

Although cookies seem to be promising solutions for the statelessness of HTTP, they do carry certain limitations, such as limited number of cookies per domain and per user agent and limited size on each cookie. User Agents are required to store at least 300 cookies at a time, 20 cookies per domain and allow 4096 bytes of storage for each cookie. They also rise several Privacy and Security concerns, the lists of which can be found on the sections 6-B<"Privacy"  and 7-"Security Considerations"> of B<RFC 2965> respectively.

=head2 QUERY STRING

=head2 クエリ文字列

Query string is a string appended to URL following a question mark (?) such as:

クエリ文字列とはこのようなURLのクエスチョンマーク(?)に続く文字列です。

    http://my.dot.com/login.cgi?user=sherzodr&password=topSecret

As you probably guessed already, it can also help you to pass state information from a click to another, but how secure is it do you think? Considering these URLs tend to get cached by most of the user agents and also logged in the servers access log, to which everyone can have access to, it is not secure.

おそらくあなたは既にこの解法を使っていたのではないかと思われます。
クエリ文字列でも別の場所へのクリックによる状態を渡すのを助けますが、
あなたはどれだけ安全なものかと言うことを考えていますか？これらのURLが
大半のユーザーエージェントによって誰もがアクセスできるサーバーのアクセスログに
残しがちだと言うことを念頭に置くと、安全であるとは言いがたいです。

=head2 HIDDEN FIELDS

=head2 隠しフィールド

Hidden field is another alternative to using query strings and they come in two flavors: hidden fields used in POST methods and the ones in GET. The ones used in GET methods will turn into a true query string once submitted, so all the disadvantages of QUERY_STRINGs do apply. Although POST requests do not have limitations of its sister-GET, the pages that hold them do the cached by web browser, and are available within the source code of the page (obviously). They also become unwieldily to manage when one has oodles of state information to keep track of ( for instance, a shopping cart or an advanced search engine).

隠しフィールドはクエリ文字列の代わりに使用されるもう一つの選択肢であり、
隠しフィールドはPOSTメソッド及びGETメソッドの両方で用いられると言う
特性があります。GETメソッドで用いられる隠しフィールドは一度サブミットされると
本物のクエリ文字列に返信してしまうため、クエリ文字列を送信するのと比べて
何の進歩もありません。しかしながらPOSTリクエストは姉貴分であるGETのような
制限が無いのですが、それらを持つページをブラウザによってキャッシュさせる
ことができ、(もちろん)ページのソースコードの範囲で有効になってしまいます。
多数のステート情報を記憶させておくとなる際にも扱いにくくなります。
(例えばショッピングカートや優れたサーチエンジンです。)

Query strings and hidden fields are also lost easily by closing the browser, or by clicking the browser's "Back" button.

クエリ文字列及び隠しフィールドはブラウザを閉じるか、さもなくばブラウザの
"戻る"ボタンをクリックすることで簡単に失われてしまいます。

=head2 SERVER SIDE SESSION MANAGEMENT

=head2 サーバーサイドセッション管理

This technique is built upon the aforementioned technologies plus a server-side storage device, which saves the state data for a particular session. Each session has a unique id associated with the data in the server. This id is also associated with the user agent in either the form of a cookie, a query_string parameter, a hidden field or all at the same time.

このテクニックは前述した技術にサーバーサイドでのストレージデバイスを
プラスしたものを基に構築されており、状態のデータを特定のセッションとして
保存します。それぞれのセッションはサーバー内のデータによって連想された
ユニークなidを所持しています。このidはユーザーエージェンと側でクッキーや、
クエリ文字列や隠しフィールド、又はその全てを同時に行う言ういずれかの形でも
連想されます。

Advantages:

進展した箇所:

=over 4

=item *

We no longer need to depend on the User Agent constraints in cookie amounts and sizes

私達はもはやクッキーの量やサイズと言ったユーザーエージェントの制限に
依存する必要が無くなったのです。

=item *

Sensitive data like user's username, email address, preferences and such no longer need to be traveling across the network at each request (which is the case with query strings, cookies and hidden_fields). Only thing that travels across the network is the unique id generated for the session ("ID-1234", for instance), which should make no sense to bad guys whatsoever.

ユーザーのユーザー名やEメールアドレス、嗜好のような敏感なデータ類は
もうそれぞれのリクエストごとにネットワーク上を行き来する必要がなくなったの
です。(クエリ文字列、クッキー及び隠しフィールドに対してのことを言っています)。
ネットワーク上を行き来するのはセッションのために生成されたユニークなidのみで
(例えば"ID-1234"です)、例えどんな悪い奴にとっても意味をなさないはずです。


=item *

User will not have sensitive data stored in his computer in an unsecured plain text format (which is a cookie file).

ユーザーはセキュアでない平文型式のデータ(クッキーファイルのことです。)が
コンピュータ内に保存されていることに神経を尖らせる必要が無くなるのです。

=item *

It's possible to handle very big and even complex (in-memory) data structures transparently.

巨大で複雑でさえもある(メモリ内の)データ構造を透過的に扱うことが可能と
なります。

=back

That's what CGI::Session is all about - implementing server side session management. Now is a very good time to get the feet wet.

これがCGI::Sessionに関する全てです - サーバーサイドセッション管理の実装。
今こそそのぬかるみから足を踏み出す好機なのです。

=head1 PROGRAMMING STYLE

=head1 プログラミングスタイル

Server side session management system might be seeming awfully convoluted if you have never dealt with it.  Fortunately, with CGI::Session this cumbersome task can be achieved in much elegent way, all the complexity being handled by the library transparently. This section of the manual can be treated as an introductory tutorial to  both logic behind session management, and to CGI::Session programming style.

もしあなたがサーバーサイドセッション管理システムを扱ったことが無ければ
それが凄まじく入り組んだ物のように思えるのかもしれません。好運なことに、
CGI::Sessionこの扱いにくい処理はエレガントな手法によって、全ての複雑さを
ライブラリを用いることで透過的に扱うことを可能にするのです。マニュアルの
このセクションはセッション管理の背後にあるロジックと、CGI::Sessionの
プログラミングスタイルについての両方の導入チュートリアルとして扱ってもらって
不遜はありません。

=head1 WHAT YOU NEED TO KNOW FIRST

=head1 最初にあなたが知るべき事

The syntax of the CGI::Session 3.x has changed from previous releases. But we still keep supporting the old syntax for backward compatibility. To help us do this, in the initial releases of 3.x interface we introduced an '-api3' switch:

CGI::Session 3.xの文法は以前のリリースから変貌を遂げました。しかし我々はまだ
前バージョンと互換を取るために、継続して古い文法をサポートし続けています。
そのため、3.xインターフェースの初期のリリースに関して我々は'-api3'スイッチを
導入しました:

    use CGI::Session qw/-api3/;

It tells the library that you will be using the new syntax. But in latest releases of the library, it will detect and turn it out automaticly. So no "-api3" switch is necessary any longer. Please don't ask us anything about the old, 2.x api if you have never used it. We won't tell you!

これによってライブラリに新しい文法を使うことを伝えるのです。しかしライブラリの
最新リリースでは、自動的に探知するでしょう。つまり"-api3"スイッチをもはや
呼び出す必要が無くなるのです。あなたが古い2.xのapiをもう使わないというならば、
我々にそのことを尋ねるのはどうかお止め下さい。我々はあなたに何も教えない
でしょう。

But before you start using the library, you will need to decide where and how you want the session data to be stored in disk. In other words, you will need to tell what driver to use. You can choose either of "File", "DB_File" and "MySQL" drivers, which are shipped with the distribution by default. Examples in this document will be using "File" driver exclusively to make sure the examples are accessible in all machines with the least requirements. To do this, we create the session object like so:

しかし本ライブラリを使い始める前に、どこにどうやってセッションデータを
ディスクに保存するのかを決断する必要があるでしょう。言い替えればどのドライバ
を使うのかを伝えなければなりません。あなたはデフォルトでディストリビュー
ションに搭載されている"File", "DB_File"及び"MySQL"ドライバのいずれかを選択
することが可能です。このドキュメントでは要求するものがもっとも少ないため
理解しやすい"File"ドライバを用いた例を示します。実行するには次のように
セッションオブジェクトを作成して下さい。

    use CGI::Session;
    $session = new CGI::Session("driver:File", undef, {Directory=>'/tmp'});

The first argument is called Data Source Name (DSN in short). If it's undef, the library will use the default driver, which is "File". So instead of being explicit about the driver as in the above example, we could simply say:

一つ目の引数は呼び出されるデータソース(略してDSN)の名前です。undefであれば、
ライブラリはデフォルトのドライバ、「File」を使用するでしょう。よって、
下記の例のようにドライバに関しては明示的に示す代わりにこのように表現する
ことも可能です:

    $session = new CGI::Session(undef, undef, {Directory=>'/tmp'});

and we're guaranteed it will fall back to default settings.

これにより、デフォルトの設定になることが保証されます。

The second argument is session id to be initialized. If it's undef, it will force CGI::Session to create a new session. Instead of passing a session id, you can also pass a CGI.pm object, or any other object that can implement either of cookie() or param() methods. In this case, the library will try to retrieve the session id from either B<CGISESSID> cookie or B<CGISESSID> CGI parameter (query string)

２つ目の引数は初期化用のセッションidです。もしundefであれば、CGI::Sessionに
新しいセッションを強制的に作らせます。session idを渡す代わりに、CGI.pm
オブジェクトを渡すか、さもなくばcookie()あるいはparam()メソッドのいずれかを
実装したオブジェクトを渡すことも可能です。このケースでは、ライブラリは
B<CGISESSID>クッキーあるいはB<CGISESSID>CGIパラメータ(クエリ文字列)の
いずれかよりセッションidを取得しようと試みるでしょう。

The third argument should be in the form of hashref. This will be used by specific CGI::Session driver only. For the list of all the available attributes, consult respective CGI::Session driver:

３番目の引数はハッシュのリファレンスと言う形であるべきです。これは特定の
CGI::Sessionドライバにのみ適用されます。使用可能な全属性の一覧を見たい場合は
それぞれのCGI::Sessionドライバを参照願います。

=over 4

=item *

L<File|CGI::Session::File> - default driver for storing session data in plain files. Full name: B<CGI::Session::File>

L<File|CGI::Session::File> - 平文でセッションデータを格納するためのデフォルトの
ドライバです。フルネーム: B<CGI::Session::File>

=item *

L<DB_File|CGI::Session::DB_File> - for storing session data in BerkelyDB. Requires: L<DB_File>. Full name: B<CGI::Session::DB_File>

L<DB_File|CGI::Session::DB_File> - BerkelyDBにセッションデータを格納します。
必要物: L<DB_File>。フルネーム: B<CGI::Session::DB_File>

=item *

L<MySQL|CGI::Session::MySQL> - for storing session data in MySQL tables. Requires L<DBI|DBI> and L<DBD::mysql|DBD::mysql>. Full name: B<CGI::Session::MySQL>

L<MySQL|CGI::Session::MySQL> - MySQLテーブルにセッションを格納します。
必要物L<DBI|DBI>及びL<DBD::mysql|DBD::mysql>。フルネーム: B<CGI::Session::MySQL>

=back

Note: You can also write your own driver for the library. Consult respective
section of this manual for details.

Note: あなたは本ライブラリのためにドライバを自身で書くことも可能です。
このマニュアルの詳細の各セクションを隅々まで御覧下さい。

=head1 CREATING NEW SESSION

=head1 新しいセッションの作成

To generate a brand new session for a user, just pass an undefined value as the second argument to the constructor - new():

ユーザーに対する新しいセッションと言う焼き印を生成するためには、コンストラクタ
- new()に未定義の値を２つ目の引数に渡すだけで構いません。

    $session = new CGI::Session("driver:File", undef, {Directory=>"/tmp"});

Directory refers to a place where the session files and their locks will be stored in the form of separate files. When you generate the session object, as we did above, you will have:

ディレクトリはセッション分散したファイルの形で格納されるであろうファイル及び
そのロックの場所を示します。セッションオブジェクトを生成する際には、
私が上記に示したことをするために、次の手順が踏まれるでしょう:

=over 4

=item 1

Session ID generated for you and

あなたのためにセッションIDは生成され

=item 2

Storage file associated with the id in the directory you specified.

あなたが指定したディレクトリ中からidによって格納されたファイルが連想されます。

=back

From now on, in case you want to access the newly generated session id just do:

これからは、あなたが新しく生成されたセッションidにアクセスしたい場合は
ただこうすれば良いのです。

    $sid = $session->id();

It returns a string something similar to B<a983c8302e7a678a2e53c65e8bd3316> which you can now send as a cookie or use as a query string or in your forms' hidden fields. Using standard L<CGI> library we can send the session id as a cookie to the user's browser like so:

クッキーとして送信される、あるいはクエリ文字列やフォーム内の隠しフィールドと
してそのまま用いられることが可能なB<a983c8302e7a678a2e53c65e8bd3316>と言った
文字列を返します。

    $cookie = $cgi->cookie(CGISESSID => $session->id);
    print $cgi->header( -cookie=>$cookie );

If anything in the above example doesn't make sense, please consult L<CGI> for the details.

もし上記の方法ではダメだと言うのであれば、L<CGI>の詳細とを御覧下さい。

=head2 INITIALIZING EXISTING SESSIONS

=head2 既存のセッションを初期化する

When a user clicks another link or re-visits the site after a short while should we be creating a new session again? Absolutely not. This would defeat the whole purpose of state maintenance. Since we already send the id as a cookie, all we need is to pass that id as the seconds argument while creating a session object:

ユーザーが他のリンクやちょっと間を置いてサイトを再訪問した際、我々は再び
新しいセッションを作成しなくてはならないのでしょうか？もちろん違います。
これではセッションの維持と言う目的を打ち負かしてしまうことになるのですから。
我々がクッキーとして既にidを送信していたら、我々が皆必要とするものは
セッションオブジェクトが生成されている間２つ目の引数としてそのidを渡すこと
のみです。

    $sid = $cgi->cookie("CGISESSID") || undef;
    $session    = new CGI::Session(undef, $sid, {Directory=>'/tmp'});

The above syntax will first try to initialize an existing session data, if it fails ( if the session doesn't exist ) creates a new session: just what we want. But what if the user doesn't support cookies? In that case we would need to append the session id to all the urls as a query string, and look for them in addition to cookie:

下記の文法ではまずはじめに既存のセッションデータを初期化しようとし、もし
新しいセッションファイルを生成する場合(セッションが存在しない場合)でも、
我々が意図した結果となります。しかし、もしユーザーがクッキーをサポート
していない場合はどうなるのでしょうか？その場合我々はクエリ文字列として全ての
urlに追加する必要があります。クッキーを追加する方法を御覧下さい:

    $sid = $cgi->cookie('CGISESSID') || $cgi->param('CGISESSID') || undef;
    $session = new CGI::Session(undef, $sid, {Directory=>'/tmp'});

Assuming you have CGI object handy, you can minimize the above two lines into one:

あなたがCGIオブジェクトの扱いがお手のものと仮定して、上記の２行を１行に
納めることが可能です:

    $session = new CGI::Session(undef, $cgi, {Directory=>"/tmp"});

If you pass an object, instead of a string as the second argument, as we did above, CGI::Session will try to retrieve the session id from either the cookie or query string and initialize the session accordingly. Name of the cookie and query string parameters are assumed to be B<CGISESSID> by default. To change this setting, you will need to invoke C<name()> class method on either CGI::Session or its object:

もし２つ目の引数として文字列の代わりにオブジェクトを渡すと、CGI::Sessionは
クッキーあるいはクエリ文字列からセッションidを取得しようと試み、適宣に
セッションを初期化します。クッキー及びクエリ文字列のパラメータはデフォルトで
B<CGISESSID>であると仮定します。この設定を変更するためには、CGI::Session
あるいはそのオブジェクトのうちいずれかのC<name()>クラスメソッドを呼び出す
必要があるでしょう:

    CGI::Session->name("MY_SID");
    # or

    # 又は

    $session->name("MY_SID");

    $session = new CGI::Session(undef, $cgi, {Directory=>'/tmp'});

=head2 STORING DATA IN THE SESSION

=head2 セッションにデータを格納する

To store a single variable in the object use C<param()> method:

C<param()>メソッドを用いてオブジェクト内に値を一つ格納するためには:

    $session->param("my_name", $name);

You can use C<param()> method to store complex data such as arrays, hashes, objects and so forth. While storing arrays and hashes, make sure to pass them as a reference:

あなたは配列や、ハッシュやオブジェクトなどのような複雑なデータを格納するために
C<param()>メソッドを用いることが可能です。配列及びハッシュを格納する際は、
リファレンスとして渡さなければなりません:

    @my_array = ("apple", "grapes", "melon", "casaba");
    $session->param("fruits", \@my_array);

You can store objects as well:

同様にオブジェクトも格納することが可能です: 

    $session->param("cgi", $cgi);   # stores CGI.pm object

    $session->param("cgi", $cgi);   # CGI.pmオブジェクトを格納します

Sometimes you wish there was a way of storing all the CGI parameters in the session object. You would start dreaming of this feature after having to save dozens of query parameters from each form element to your session object. Consider the following syntax:

あなたが望むセッションオブジェクト内にCGIのパラメータを全て格納する方法も
存在します。あなたはセッションオブジェクトに各フォームの要素からの
あなたは後で多数のクエリパラメータを格納しなければならないためににこの形式を
望むことだと思われます。以下の文法を御覧下さい:

    $session->save_param($cgi, ["keyword", "category", "author", "orderby"]);

save_param() makes sure that all the above CGI parameters get saved in the session object. It's the same as saying:

save_param()は上記の全CGIパラメータをセッションオブジェクトに格納させる
でしょう。これは以下と同様のことを言っています。

    $session->param("keyword",  $cgi->param("keyword"));
    $session->param("category", $cgi->param("category"));
    # etc... for all the form elements

    # などなど全てのフォーム要素に対して

In case you want to save all the CGI parameters. Just omit the second argument to C<save_param()>:

全CGIパラメータを保存したい場合ですが、C<save_param()>の２つ目の引数を省略
するだけです:

    $session->save_param($cgi);

The above syntax saves all the available/accessible CGI parameters

上記の文法は全ての使用可能/アクセス可能なCGIパラメータを保存します。

=head2 ACCESSING STORED DATA

=head2 保存されたデータへのアクセス

There's no point of storing data if you cannot access it. You can access stored session data by using the same C<param()> method you once used to store them:

もしあなたがデータにアクセスできないならば、保存されたデータに接点がないの
です。あなたは一度データを保存するのに用いた同じC<param()>で保存されたデータに
アクセスすることが可能です。

    $name = $session->param("my_name");

Above form of param() retrieves session parameter previously stored as "my_name". To retrieve previously stored @my_array:

上記のparam()の形式では"my_name"として過去に保存されたセッションのパラメータを
取得します。過去に保存された@my_arrayを取り出すには:

    $my_array = $session->param("fruits");

It will return a reference to the array, and can be dereferenced as @{$my_array}.

配列へのリファレンスが戻って来るでしょう。そして、@{$my_array}として参照する
事が可能です。

Very frequently, you may find yourself having to create a pre-filled and pre-selected forms, like radio buttons, checkboxes and drop down menus according to the user's preferences or previous action. With text and textareas it's not a big deal: you can simply retrieve a single parameter from the session and hardcode the value into the text field. But how would you do it when you have a group of radio buttons, checkboxes and scrolling lists? For this purpose, CGI::Session provides load_param() method, which loads given session parameters to a CGI object (assuming they have been previously saved with save_param() method or alternative):

あなたはユーザーの好みや以前のアクションに応じた入力済、あるいは選択済の
ラジオボタンやチェックボックス、ドロップダウンメニューなどのフォームを
とても頻繁に作らなくてはならないだろうことに気づいているかと思われます。
textやtextareasならそれほど大したことではありません: 単に一つのパラメータを
セッションから取得し、textフィールドにハードコーディングすれば良いのですから。」しかしラジオボタンやチェックボタン、スクロールするリストのグループを
扱うとき、あなたはどうするでしょう？この目的のため、CGI::Sessionはload_param()
メソッドを提供しており、CGIオブジェクトに与えられたセッションパラメータを
読み出します (save_param()メソッドあるいはその他の選択肢で過去に保存されている
と仮定して):

    $session->load_param($cgi, ["fruits"]);

Now you can use CGI.pm to generate those preselected checkboxes:

さて、CGI.pmを使って選択済のチェックボックスを生成するには:

    print $cgi->checkbox_group(fruits=>['apple', 'banana', 'appricot']);

If you're making use of HTML::Template to separate the code from the skins, you can as well associate CGI::Session object with HTML::Template and access all the parameters from within HTML files. We love this trick!

もしあなたがHTML::Templateを用いることでスキンからコードを分離させる場合、
HTML::Templateを用いてCGI::Sessionオブジェクトをassociateすることによって
同様のことが可能になります。我々はこのトリックが大好きです。

    $template = new HTML::Template(filename=>"some.tmpl", associate=>$session);
    print $template->output();

Assuming the session object stored "first_name" and "email" parameters while being associated with HTML::Template, you can access those values from within your "some.tmpl" file now:

HTML::Templateでassociateする間、セッションオブジェクトに"first_name"及び
"email"パラメータが格納されていると仮定すると、"some.tmpl"ファイルを用いて
それらの値にアクセスできます:

    Hello <a href="mailto:<TMPL_VAR email>"> <TMPL_VAR first_name> </a>!

For more tricks with HTML::Template, please refer to the library's manual (L<HTML::Template>) and L<CGI Session CookBook|CGI::Session::CookBook>.

HTML::Templateによるさらなるトリックを知りたい場合はライブラリマニュアル
(L<HTML::Template>及びL<CGI Session CookBook|CGI::Session::CookBook>。

=head2 CLOSING THE SESSION

=head2 セッションを閉じる

Normally you don't have to close the session explicitly. It gets closed when your program terminates or session object goes out of scope. However in some few instances you might want to close the session explicitly by calling CGI::Session's C<close()> method or undefining the object. What is closing all about - you'd ask. While session is active, updates to session object doesn't get stored in the disk right away. It stores them in the memory until you either choose to flush the buffer by calling C<flush()> method or destroy the session object by either terminating the program or calling close() method explicitly.

通常あなたは明示的にセッションを閉じる必要はありません。プログラムが終了する
か、あるいはセッションオブジェクトがスコープからはずれた際、セッションが閉じ
られます。しかしながら時にはCGI::Sessionの<close()>メソッドあるいはオブジェ
クトを未定義にすることによってセッションを明示的に閉じたい場合があるかもしれ
ません。セッションを閉じるとは一体全体何なのでしょう？ - あなたは尋ねるでしょ
う。セッションがアクティブな間、ディスク内のセッションオブジェクトの更新が
すぐに行われるわけではありません。C<flush()>メソッドでバッファをフラッシュさ
せると言う選択肢をとるかあるいはプログラムを終了させるかあるいはclose()メソッ
ドを明示的に呼び出してセッションを破棄するまではメモリ内に保存されます。

In some circumstances you might want to close the session but at the same time don't want to terminate the process for a while. Might be the case with GUI and in daemon applications. In this case close() is what you want. Note: we prefer simpl undefing the session rather than calling close() method. close() is less efficient):

状況によってはセッションを閉じたいもののプロセスをしばらくの間終了させたくない
場合もあるかと思われます。おそらくそのようなケースはGUI及びデーモンアプリケー
ションによるものだと思われます。この場合close()こそがあなたが求めていたもの
なのです。Note: 我々はclose()よりもシンプルな開放ようのメソッドを好みます。
(close()は機能面で劣ります。)

    undef($session);

If you want to keep the session object but for any reason want to synchronize the data in the buffer with the one in the disk, C<flush()> method is what you need.

もしあなたがセッションをオブジェクトを何らかの理由でバッファ内のデータと
ディスク内のデータを同期させたいならば、C<flush()>こそあなたの求めるものです。

Note: close() calls flush() as well. So there's no need to call flush() before calling close()

Note: close()も同様にflush()を呼び出します。したがってclose()を呼び出す前に
flush()を呼び出す必要は全く無いのです。

=head2 CLEARING SESSION DATA

=head2 セッションデータのクリア

You store session data, you access session data and at some point you will want to clear certain session data, if not all. For this purpose CGI::Session provides C<clear()> method which optionally takes one argument as an arrayref indicating which session parameters should be deleted from the session object:

セッションデータを保存し、セッションデータにアクセスすると、ある時点で
全てでなくとも、特定のセッションデータをクリアしたくなるでしょう。この目的の
ためにCGI::Sessionはセッションパラメータをオブジェクトから消すべきパラメータ
名を指示した配列のリファレンスの表現で引数を一つ取るC<clear()>メソッド
をオプショナルで提供しています。

    $session->clear(["~logged-in", "email"]);

Above line deletes "~logged-in" and "email" session parameters from the session. And next time you say:

上記の行ではセッションパラメータ"~logged-in"及び"email"をセッションから消去し
ます。そして次にこうすると:

    $email = $session->param("email");

it returns undef. If you omit the argument to C<clear()>, be warned that all the session parameters you ever stored in the session object will get deleted. Note that it does not delete the session itself. Session stays open and accessible. It's just the parameters you stored in it gets deleted

undefが戻ります。もしC<clear()>の引数を省略した場合、あなたが今までにセッショ
ンオブジェクトに格納したセッションパラメータが削除されてしまうのでお気を付け
下さい。セッションそのものを消してしまうのではないことを念頭に置いて下さい。
セッションはまだ開いていてアクセス可能です。中に格納されたパラメータが消去
されただけなのです。

=head2 DELETING A SESSION

=head2 セッションを削除する

If there's a start there's an end. If session could be created, it should be possible to delete it from the disk for good:

もし始まりが存在し終わりが存在するならば。もしセッションが作られれば、それは
ディスクから削除することが可能である方が良いに決まっています。

    $session->delete();

The above call to C<delete()> deletes the session from the disk for good. Do not confuse it with C<clear()>, which only clears certain session parameters but keeps the session open.

上記のようにC<delete()>を呼び出すことによってディスクからセッションを削除
した方が好ましいと言えます。C<clear()>と混同しないように、これは特定のセッシ
ョンパラメータをクリアしますが、セッションは開いたままです。

=head2 EXPIRATION

=head2 期限切れ

CGI::Session also provides limited means to expire session data. Expiring session is the same as deleting it via delete(), but deletion takes place automaticly. To expire a session, you need to tell the library how long the session would be valid after the last access time. When that time is met, CGI::Session refuses to retrieve the session. It deletes the session and returns a brand new one. To assign expiration ticker for a session, use the expire() method:

CGI::Sessionはセッションデータの期限切れを実現するための限られた機能を提供
します。セッションの期限切れはdelete()経由で消去することと同等ですが、削除は
自動的に行われます。セッションを期限切れにするためには、ライブラリに最終アク
セス時からどれだけ長く有効であるかを教える必要があります。時間が来れば、
CGI::Sessionはセッションを取得することを拒否します。そのことによりセッション
は削除され、真新しいセッションが返って来ます。セッションに対する期限切れを
示す時計を割り当てるためにはexpire()メソッドを用います。

    $session->expire(3600);     # expire after 3600 seconds
    $session->expire('+1h');    # expire after 1 hour
    $session->expire('+15m');   # expire after 15 minutes
    $session->expire('+1M');    # expire after a month and so on.

    $session->expire(3600);     # 3600秒後に期限切れになります
    $session->expire('+1h');    # 1時間後に期限切れになります
    $session->expire('+15m');   # 15分後に期限切れになります
    $session->expire('+1M');    # 1ヵ月後に期限切れになります


But sometimes, it makes perfect sense to expire a certain session parameter, instead of the whole session. The author usually does this in his login/authentication enabled sites, where after the user logs in successfully, sets a "_logged_in" flag to true, and assigns an expiration ticker on that flag to something like 30 minutes. It means, after 30 idle minutes CGI::Session will clear() "_logged_in" flag, indicating the user should log in over again. I aggree, the same effect can be achieved by simply expiring() the session itself, but in thise we would loose other session parameters, such as user's shopping cart, session-preferences and the like.

# これはtypo?  (thise -> these?)

しかし時には、セッション全体に対する有効期限の代わりに完全に特定パラメータ
のみに限定した有効期限を設定することもできます。作者はログイン成功後に
"_logged_in"フラグを真に設定し、30分間と言ったある有効期限をフラグに割り当てる
ようなログイン/認証可能なサイトでこのことは大抵行われています。これは30分間
アイドルした後、CGI::Sessionが"_logged_in"フラグをclear()し、もう一度ユーザー
はログインしなおさなくてはならないことを示しています。私は単にexpiring()を
セッションそのものによって成し遂げられ得るのと同じであることを認めますが、
これらの方法ではその他のセッションパラメータが失われるでしょう。ショッピング
カートなどのセッションではこちらの方が好ましいと言えます。


This feature can also be used to simulate layered security/authentication, such as, you can keep the user's access to his/her personal profile information for as long as 10 idle hours after successful login, but expire his/her access to his credit card information after 10 idle minutes. To achieve this effect, we will use expire() method again, but with a slightly different syntax:

この形式では個人のプロフィール情報に対するログインに成功してから10時間まで
放っておいてもアクセスし続けることが可能ですが、10分間放っておくとクレジット
カードへのアクセスの期限が切れると言った、階層化されたセキュリティ認証をシミ
ュレートするのに用いることも可能です。

    $session->expire(_profile_access, '+10h');
    $session->expire(_cc_access, '+10m');

With the above syntax, the person will still have access to his personal information even after 5 idle hours. But when he tries to access or update his/her credit card information, he may be displayed a "login again, please" screen.

上記の文法によって、5時間放ったらかしにしておいてもまだ個人情報にはアクセス
できます。しかし、クレジットカード情報にアクセス、あるいは更新しようとしても、
おそらく「もう一度ログインして下さい」とスクリーンに表示されることでしょう。

This concludes our discussion of CGI::Session programming style for now (at least till the new releases of the library ). The rest of the manual covers some L<"SECUIRITY"> issues and L<"DRIVER SPECIFICATIONS"> for those want to implement their own drivers or understand the library architecture.

このことによってはCGI::Sessionのプログラミングスタイルの議論に対するさしあた
りの結論を下します(少なくとも新しくライブラリをリリースするには至りました)。
マニュアルの最後にはドライバを実装する、あるいはライブラリの構造について理解
したい方々のためにL<"セキュリティ">問題及びL<"ドライバの特性">をカバーしてい
ます。

=head1 SECURITY

=head1 セキュリティ

"How secure is using CGI::Session?", "Can others hack down people's sessions using another browser if they can get the session id of the user?", "Are the session ids guessable?" are the questions I find myself answering over and over again.

「どうやったらCGI::Sessionをセキュアに使えるの？」、「もしセッションユーザーの
セッションidを取られてしまったら他の人が別のブラウザを使ってセッションを
乗っ取ることができてしまうの？」、「セッションidは推測可能なの？」と言った
私自身何度も何度も答えていることに気づいた質問群です。

=head2 STORAGE

=head2 記憶装置

Security of the library does in many aspects depend on the implementation. After making use of this library, you no longer have to send all the information to the user's cookie except for the session id. But, you still have to store the data in the server side. So another set of questions arise, can an evil person have access to session data in your server, even if they do, can they make sense out of the data in the session file, and even if they can, can they reuse the information against a person who created that session. As you see, the answer depends on yourself who is implementing it.

ライブラリのセキュリティは実装に依存する局面が多いと言えます。このライブラリを
利用した後は、あなたはもうセッションidに関するユーザーのクッキーに対する情報を
送らなくても良いのです。しかし、あなたはまだサーバー側にデータを保存しなくては
なりません。よってもう一つの疑問が挙がって来るのですが、それは悪意のある人が
サーバー内のセッションデータにアクセスできやしないか、さらに想定外のデータが
含まれるセッションデータを作れやしないか、そしてさらにセッションを作った人に
対する情報が不正流用されやしないかと言うことです。いいですか、その答えはそれ
を実装するあなたによるのです。

First rule of thumb, do not save the users' passwords or other sensitive data in the session. If you can persuade yourself that this is necessary, make sure that evil eyes don't have access to session files in your server. If you're using RDBMS driver such as MySQL, the database will be protected with a username/password pair. But if it will be storing in the file system in the form of plain files, make sure no one except you can have access to those files.

最初のルールの概要ですが、セッションの中にはパスワードやその他きわどいデータを
保存しないことです。もしあなたが自分でこれが重要であると認識したらば、きっと
悪の目玉はサーバー内のセッションファイルにアクセスすることもないでしょう。もし
あなたがMySQLのようなRDBMSドライバを使っているのであれば、データベースは
ユーザー名/パスワードのペアで保護されているでしょう。しかしもしそれが平文の
形でファイルシステムに保存されているとしても、きっとあなたを除く誰しもがそれ
らのファイルへアクセスできないでしょう。

Default configuration of the driver makes use of Data::Dumper class to serialize data to make it possible to save it in the disk. Data::Dumper's result is a human readable data structure, which if opened, can be interpreted against you. If you configure your session object to use either Storable or FreezeThaw as a serializer, this would make more difficult for bad guys to make sense out of session data. But don't use this as the only precaution for security. Since evil fingers can type a quick program using Storable or FreezeThaw which deciphers that session file very easily.

デフォルトのドライバの設定ではディスク内に保存することを可能にするために
データをシリアライズするData::Dumperクラスを使用させることになります。
Data::Dumperの出力結果は人間が可読であるデータ構造なのですが、
このデータをオープンすればあなたが解読することができるのです。
もしStorableか又はFreezeThawのいずれかをシリアライザとして用いるために、
セッションオブジェクトを設定した場合は悪い奴らに対抗してセッションデータとは
無関係で意味なさないような複雑なデータを生成するでしょう。しかしこのことを
セキュリティのための警戒として用いてはなりません。悪の指はセッションファイル
を復号するStorableあるいはFreezeThawを用いた速いセッションデータ復元
プログラムをたやすく書いてしまうのです。

Also, do not allow sick minds to update the contents of session files. Of course CGI::Session makes sure it doesn't happen, but your cautiousness does no harm either.

Do not keep sessions open with sensitive information for very long period. This will increase the possibility that some bad guy may have someone's valid session id at a given time (acquired somehow).

貴重なデータを伴うセッションを長期間保持してはなりません。このことにより、
悪い奴が時間内に誰かの有効なセッションidを盗む可能性が増大します(なんらかの
方法で知って)。

ALWAYS USE "-ip-match" SWITCH!!!

常に"-ip-match"スイッチを使いなさい！！！

Read on for the details of "-ip-match".

詳細は"-ip-match"にあるので読みましょう。

=head2 SESSION IDs

=head2 SESSION ID

Session ids are not easily guessable (unless you're using Incr Id generator)! Default configuration of CGI::Session uses Digest::MD5 which takes process id, time in seconds since epoch and a random number, generates a 32 character long digest out of it. Although this string cannot be guessable by others, if they find it out somehow, can they use this identifier against the other person?

セッションidが簡単に推測されることはありません(Incr Idジェネレータを用いない
限りは)!CGI::Sessionにおけるデフォルトの設定ではDigest::MD5はプロセスid、
エポックからの秒数およびランダムな数字を用いて32文字長のダイジェストを
生成します。しかしながらこの文字列は他人が推測することは不可能で、もし
何らかの方法で見付けることができたとしても、他人の識別子を使うことなど
できるのでしょうか？

Consider the scenario, where you just give someone either via email or an instant messaging a link to your online-account profile, where you're currently logged in. The URL you give to that person contains a session id as part of a query string. If the site was initializing the session solely using query string parameter, after clicking on that link that person now appears to that site as you, and might have access to all of your private data instantly. How scary and how unwise implementation. And what a poor kid who didn't know that pasting URLs with session ids could be an accident waiting to happen.

あなたはただ誰かにemailかインスタントメッセージ経由でオンラインアカウントの
プロファイルへのリンクを提供するところで現在ログインしていると言う
シナリオを考えてみましょう。あなたがその人に提供するURLはクエリ文字列の一部
としてセッションidを含んでいます。もしそのサイトがセッションを初期化して、
ただクエリ文字列のパラメータを用い、今サイトに現れた人があなたであることを
示すリンクをクリックすると、ただちにあなたの機密データの全てにアクセス
したかもしれません。なんと恐ろしく無知な実装なのでしょう。セッションidを
伴ったURLを貼り付けることが、事故が起こるのを待つようなものであることを
知らないなんと哀れなお子様なのでしょう。

Even if you're solely using cookies as the session id transporters, it's not that difficult to plant a cookie in the cookie file with the same id and trick the web browser to send that particular session id to the server. So key for security is to check if the person who's asking us to retrieve a session data is indeed the person who initially created the session data. CGI::Session helps you to watch out for such cases by enabling "-ip_match" switch while "use"ing the library:

もしあなたが単にクッキーをセッションidの転送役として用いた場合でさえも、
同じクッキーファイルの中に同じセッションidを伴うクッキーを植え込み、webブラウザ
に適切なセッションidをサーバーに送信するよう細工することは難しいことでは
ないのです。よって、もし私達にセッションデータを取得するよう依頼している人が
実際にセッションデータを最初に初期化した人であるかどうか、セキュリティ用の
キーをチェックすべきです。CGI::Sessionではライブラリを「使って」いる間、
"-ip_match"スイッチを使用加納にすることによってこのようなケースにあなたが注意を
注ぐことを手助けします。

    use CGI::Session qw/-ip-match/;

or alternatively, setting $CGI::Session::IP_MATCH to a true value, say to 1. This makes sure that before initializing a previously stored session, it checks if the ip address stored in the session matches the ip address of the user asking for that session. In which case the library returns the session, otherwise it dies with a proper error message.

=head1 DRIVER SPECIFICATIONS

This section is for driver authors who want to implement their own storing mechanism for the library. Those who enjoy sub-classing stuff should find this section useful as well. Here we discuss the architecture of CGI::Session and its drivers.

=head2 LIBRARY OVERVIEW

Library provides all the base methods listed in the L<METHODS> section. The only methods CGI::Session doesn't bother providing are the ones that need to deal with writing the session data in the disk, retrieving the data from the disk, and deleting the data. These are the methods specific to the driver, so that's where they should belong.

In other words, driver is just another Perl library which uses CGI::Session as a base class, and provides several additional methods that deal with disk access.

=head2 SERIALIZATION

=head2 シリアライズ

Before getting to driver specs, let's talk about how the data should be stored. When flush() is called, or the program terminates, CGI::Session asks a driver to store the data somewhere in the disk, and passes the data in the form of a hash reference. Then it's the driver's obligation to serialize the data so that it can be stored in the disk.

ドライバの使用の話に入る前に、データがどうやって格納されるかについてお話しして
おきましょう。flush()が呼び出されるか、さもなくばプログラムが終了した際に、
CGI::Sessionはディスクのどこに格納するのかを尋ね、そしてハッシュのリファレンス
の形でデータが渡されます。それからデータをディスクに格納するデータをシリアラ
イズ化するのはドライバーの責任です。

Although you are free to implement your own serializing engine for your driver, CGI::Session distribution comes with several libraries you can inherit from and call freeze() method on the object to serialize the data and store it. Those libraries are:

あなたはドライバに独自のシリアライズ化の実装を組み込んでも構わないのですが、
CGI::Sessionのディストリビューションではあなたが継承し、そのオブジェクトにおけ
るデータをシリアライズ化し、格納するためのfreeze()メソッドを呼び出すことが
できるいくつかのライブラリを提供しています:

=over 4

=item L<CGI::Session::Serialize::Default|CGI::Session::Serialize::Default>

=item L<CGI::Session::Serialize::Storable|CGI::Session::Serialize::Storable>

=item L<CGI::Session::Serialize::FreezeThaw|CGI::Session::Serialize::FreezeThaw>

=back

Example:

例:

    # $data is a hashref that needs to be stored

    # $dataは格納される必要があるハッシュのリファレンスです。

    my $storable_data = $self->freeze($data)

$storable_data can now be saved in the disk safely.

今、$storable_dataはディスクへ安全に保存することができます。

When the driver is asked to retrieve the data from the disk, that serialized data should be accordingly de-serialized. The aforementioned serializers also provides thaw() method, which takes serialized data as the first argument and returns Perl data structure, as it was before saved. Example:

ドライバがディスクからデータを取得するために尋ねられる際には、シリアライズ化
されたデータはデシリアライズされるべきです。前述のシリアライザはthaw()メソッド
も提供しており、１番目の引数としてデータをシリアライズ化されたデータを渡すと
保存される前の形でPerlのデータ構造を返します。例:

    my $hashref =  $self->thaw($stored_data);

=head2 DRIVER METHODS

=head2 ドライバメソッド

Driver is just another Perl library, which uses CGI::Session as a base class and is required to provide the following methods:

ドライバはもう一つのPerlライブラリで、CGI::Sessionを基底クラスとして用い、
以下のメソッドを提供することが要求されます:

=over 4

=item C<retrieve($self, $sid, $options)>

retrieve() is called by CGI::Session with the above 3 arguments when it's asked to retrieve the session data from the disk. $self is the session object, $sid is the session id, and $options is the list of the arguments passed to new() in the form of a hashref. Method should return un-serialized session data, or undef indicating the failure. If an error occurs, instead of calling die() or croak(), we suggest setting the error message to error() and returning undef:

retrieve()はディスクからデータを取得する際に上記3つの引数を伴いCGI::Sessionに
よって呼び出されます。$selfはセッションオブジェクトで、$sidはセッションid、
そして$optionsはハッシュのリファレンスの形で引数の一覧をnew()に渡すのである。
メソッドはアンシリアライズ化されたセッションデータを返すか、さもなくば失敗を
示すundefを返すべきである。もしエラーが発生した場合、die()を呼んだりcroak()を
呼ぶ代わりにerror()にエラーメッセージをセットし、undefを返すことを提案する:

    unless ( sysopen(FH, $options->{FileName}, O_RDONLY) ) {
        $self->error("Couldn't read from $options->{FileName}: $!");
        return undef;
    }

If the driver detects that it's been asked for a non-existing session, it should not generate any error message, but simply return undef. This will signal CGI::Session to create a new session id.

=item C<store($self, $sid, $options, $data)>

store() is called by CGI::Session when session data needs to be stored. Data to be stored is passed as the third argument to the method, and is a reference to a hash. Should return any true value indicating success, undef otherwise. Error message should be passed to error().

=item C<remove($self, $sid, $options)>

remove() called when CGI::Session is asked to remove the session data from the disk via delete() method. Should return true indicating success, undef otherwise, setting the error message to error()

=item C<teardown($self, $sid, $options)>

called when session object is about to get destroyed, either explicitly via close() or implicitly when the program terminates

=back

=head2 GENERATING ID

CGI::Session also requires the driver to provide a generate_id() method, which returns an id for a new session. Again, you are welcome to re-invent your own wheel, but note, that CGI::Session distribution comes with couple of id generating libraries that provide you with generate_id(). You should simply inherit from them. Following ID generators are available:

CGI::Sessionはgドライバにenerate_id()メソッドを提供することも要求し、それは
新たなセッションのためのidを返します。繰り返しますが、自分自身で車輪を再発明
することは歓迎されます。しかし、覚えておいてほしいのですが、CGI::Sessionの
ディストリビューションには対となる２つのgenerate_id()を提供するライブラリが
含まれます。あなたは単純にそれらを継承すべきです。以下に挙げるIDジェネレータ
が使用可能です:

=over 4

=item L<CGI::Session::ID::MD5|CGI::Session::ID::MD5>

=item L<CGI::Session::ID::Incr|CGI::Session::ID::Incr>

=back

Refer to their respective manuals for more details.

In case you want to have your own style of ids, you can define a generate_id() method explicitly without inheriting from the above libraries. Or write your own B<CGI::Session::ID::YourID> library, that simply defines "generate_id()" method, which returns a session id, then give the name to the constructor as part of the DSN:

    $session = new CGI::Session("id:YourID", undef, {Neccessary=>Attributes});

=head2 BLUEPRINT

=head2 設計図

Your CGI::Session distribution comes with a Session/Blueprint.pm file
which can be used as a starting point for your driver:

あなたのCGI::Sessionディストリビューションは
ともにあなたのドライバのための出発点として使用される
Session/Blueprint.pmファイルともに配付されることになります。

    package CGI::Session::BluePrint;

    use strict;
    use base qw(
        CGI::Session
        CGI::Session::ID::MD5
        CGI::Session::Serialize::Default
    );

    # Load neccessary libraries below

    use vars qw($VERSION);

    $VERSION = '0.1';

    sub store {
        my ($self, $sid, $options, $data) = @_;

        my $storable_data = $self->freeze($data);

        #now you need to store the $storable_data into the disk
    }

    sub retrieve {
        my ($self, $sid, $options) = @_;

        # you will need to retrieve the stored data, and
        # deserialize it using $self->thaw() method
    }

    sub remove {
        my ($self, $sid, $options) = @_;

        # you simply need to remove the data associated
        # with the id
    }



    sub teardown {
        my ($self, $sid, $options) = @_;

        # this is called just before session object is destroyed
    }

    1;

    __END__;


After filling in the above blanks, you can do:

上記の空白を埋めることで、あなたは

    $session = new CGI::Session("driver:MyDriver", $sid, {Option=>"Value"});

and follow CGI::Session manual.

とすることがき、CGI::Sessionのマニュアルにある通りです。

=head1 COPYRIGHT

=head1 著作権

Copyright (C) 2002 Sherzod Ruzmetov. All rights reserved.

This library is free software. You can modify and distribute it under the same terms as Perl itself.

=head1 AUTHOR

=head1 作者

Sherzod Ruzmetov <sherzodr@cpan.org>. Suggestions, feedbacks and patches are welcome.

Sherzod Ruzmetov <sherzodr@cpan.org>. 提案、コメント及びパッチは歓迎します。

=head1 SEE ALSO

=head1 参考文献

=over 4

=item *

L<CGI::Session|CGI::Session> - CGI::Session manual

L<CGI::Session|CGI::Session> - CGI::Sessionマニュアル

=item *

L<CGI::Session::CookBook|CGI::Session::CookBook> - practical solutions for real life problems

L<CGI::Session::CookBook|CGI::Session::CookBook> - 実生活における実践的な解決方法

=item *

B<RFC 2965> - "HTTP State Management Mechanism" found at ftp://ftp.isi.edu/in-notes/rfc2965.txt

B<RFC 2965> - "HTTP State Management Mechanism" は ftp://ftp.isi.edu/in-notes/rfc2965.txt で見付かります。

=item *

L<CGI|CGI> - standard CGI library

L<CGI|CGI> - 標準のCGIライブラリ

=item *

L<Apache::Session|Apache::Session> - another fine alternative to CGI::Session

L<Apache::Session|Apache::Session> - もう一つのCGI::Sessionに対する素晴らしき選択肢

=back

=head1 翻訳者

三浦真磁<snj@users.sourceforge.jp>

=cut
