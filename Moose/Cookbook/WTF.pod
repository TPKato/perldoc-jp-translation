=encoding utf8

=head1 題名

Moose::Cookbook::WTF - Mooseがうまく動かないときは

=head1 ありがちな問題

=head2 速度

=head3 私のコードがこんなにロードが遅いのはなぜですか

Mooseがコンパイル時にパフォーマンスが悪くなるのは本当です（これはClass::MOPに由来するものです）。ロード／コンパイル時間が問題になるアプリケーションの場合は、Mooseは最適のツールではないかもしれません。

私たちはL<Module::Compile>を使ってこの問題を軽減する方法を探していますが、いまのところまだ準備はできていません。

=head3 オブジェクトの生成にこんなに時間がかかるのはなぜですか

Mooseはインスタンスを生成する際に大量のイントロスペクションを利用しているのですが、イントロスペクションには時間がかかることがあるためです。この問題はクラスを不変化することで解決できます。これは、このようなコードで実現できます。

  MyClass->meta->make_immutable();

こうすると、Mooseはメタレベルのさまざまなメソッドをメモ化したコンストラクタをインライン展開してくれます。詳しくは次のL<コンストラクタ>のセクションや、L<Moose::Cookbook::FAQ>をご覧ください。

=head2 コンストラクタと不変化

=head3 クラスを不変化したけれど、まだC<new>が遅い!

クラスに独自のC<new>メソッドがありませんか。Mooseは独自のC<new>メソッドがあると上書きしませんので、おそらくC<BUILD>メソッドを使って書き換えるか、もしかするとアトリビュート宣言でC<default>値を指定した方がよいかもしれません。

=head3 クラスを不変化したら、(before | after | around) C<new>が呼ばれなくなってしまった

C<new>メソッドをI<before>やI<after>、I<around>でラップすると、クラスにC<new>メソッドが作られてしまいます。すると、クラスを不変化しようとしても、Mooseが自前のC<new>メソッドを作れなくなってしまうのです。

=head2 アクセサ

=head3 アトリビュートは作ったけれど、アクセサはどこにあるの

アクセサは何もしなくても作られるものではB<ありません>。Mooseにアクセサを作るよう指示するB<必要があるのです>。おそらくこんなコードになっているのではありませんか。

  has 'foo' => (isa => 'Bar');

本当はこうしたかったのでしょう。

  has 'foo' => (isa => 'Bar', is => 'rw');

このようになっている理由は、アクセサが「なくても」使い方としてはまったく問題ないからです。もっとも単純なのは、自前のアクセサを書きたい場合です。Mooseが自動的にアクセサを作ってしまうと、クラスの生成順序の都合で、自前のアクセサが上書きされてしまうのです。それでは困りますよね。

=head2 メソッドモディファイア

=head3 C<before>モディファイアの中でC<@_>を変更できないのはなぜですか

C<before>モディファイアはメインのメソッドが呼ばれる「前に」呼ばれますが、返り値は単に無視されて、メインのメソッド本体にはB<渡らない>からです。

こうなっている理由はいろいろありますが、このドキュメントで説明するには話が長すぎるので、かわりにC<around>モディファイアを使うことをおすすめします。サンプルコードはこのようになります。

  around 'foo' => sub {
      my $next = shift;
      my ($self, @args) = @_;
      # do something silly here to @args 
      $next->($self, reverse(@args));  
  };

=head3 C<after>モディファイアの中で返り値が見られないのはなぜですか

C<before>モディファイアと同様に、C<after>モディファイアも単にメインメソッドの「あとに」呼ばれるだけです。渡されるのはもともとのC<@_>の中身であって、メインメソッドの返り値ではB<ありません>。

これもなぜこうなっているかの議論は長すぎるので割愛しますが、C<before>の場合と同じく、C<around>モディファイアを使うことをおすすめします。サンプルコードはこのようになります。

  around 'foo' => sub {
      my $next = shift;
      my ($self, @args) = @_;
      my @rv = $next->($self, @args);  
      # do something silly with the return values
      return reverse @rv;
  };

=head2 Mooseとサブルーチンアトリビュート

=head3 スーパークラスから継承したサブルーチンアトリビュートが動かないのはなぜですか

いまのところC<extends>キーワードを使ったモジュールのサブクラス化は実行時に行われますが、アトリビュートはコンパイル時にチェックされるため、アトリビュートを有効にするにはC<extends>をC<BEGIN>ブロックの中に入れて、コンパイル時にアトリビュートハンドラを利用できるようにしなければなりません。

  BEGIN { extends qw/Foo/ }

念のため、ここで話題にしているのはPerlのサブルーチンアトリビュートについてです。Mooseのアトリビュートについてではありません。

  sub foo : Bar(27) { ... }

=head2 Mooseとその他のモジュール

=head3 CatalystとMooseがうまく動かないのはなぜですか

L<Mooseとアトリビュート>をご覧ください。

=head2 ロール

=head3 合成したロールでBUILDが呼ばれないのはなぜですか

BUILDは合成したロールでは決して呼ばれません。そのおもな理由は、ロールは順番の影響をB<受けない>からです（ロールは合成の順序が影響しないような形で合成されます。詳しい理論はL<http://www.iam.unibe.ch/~scg/Research/Traits/>にある大本の論文をご覧ください）。

ロールには本質的に順序がないため、BUILDメソッドを実行する順序を決めることはできません。

ただし、それ以外の解決策はいくつかあります。

=over 4

=item *

アトリビュートに遅延評価とデフォルト値を組み合わせておくと、初期化を遅らせることができます（遅延評価やデフォルトの使い方についてはクックブックのL<Moose::Cookbook::Basics::Recipe3>にあるバイナリ木の例が好例なのでご覧ください）。

=item *

アトリビュートのトリガを使うと（これはアトリビュートの値が設定されたときに実行されます）初期化を簡単にできます。これについてはL<Moose>のドキュメントに説明されているほか、テストスイートに例があります。

=back

一般的に、ロールは初期化をB<必要>とすべきではありません。まともなデフォルト値を用意しておくか、具体的に初期化が必要であるとドキュメント化しておくべきです。「ドキュメント化」のひとつの方法としては、アトリビュートの初期化メソッドを別に用意して、ロールの必須メソッドとすることです。例としてはこのようになります。

  package My::Role;
  use Moose::Role;

  has 'height' => (
      is      => 'rw',
      isa     => 'Int',
      lazy    => 1,
      default => sub {
          my $self = shift;
          $self->init_height;
      } 
  );

  requires 'init_height';

この場合、このロールはC<init_height>メソッドを用意しているクラスにしか合成できません。

このような解決策でもうまくいかない場合、ロールは問題を解決するのに最適なツールではないのかもしれません（本当にクラスを使う必要があるのかもしれません）。少なくとも、問題のロールの機能を削って、初期化を必要としないようにした方がよいでしょう。

=head1 作者

Stevan Little E<lt>stevan@iinteractive.comE<gt>

Anders Nor Berle E<lt>debolaz@gmail.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2006-2009 by Infinity Interactive, Inc.

L<http://www.iinteractive.com>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

