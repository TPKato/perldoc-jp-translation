=encoding utf8

=head1 題名

Moose::Cookbook::FAQ - Mooseについてのよくある質問

=head1 よくある質問

=head2 モジュールの安定度

=head3 Mooseは「実用レベルに達して」いますか

はい。私はMooseを使った中規模から大規模に近いウェブアプリケーションをいくつか実戦投入していますが、もう1年以上問題なく稼働しています。

また、会社の業務で自社のコア製品をMooseを使って書き換えているところですから、開発が続くことも保証できます。

#mooseチャンネルにはほかにも何人かMooseを使ったアプリケーションを実戦投入していたり、Mooseを使ったサイトを本番環境に移行しようとしている人がいます。

=head3 MooseのAPIは安定していますか

答えはイエスであり、ノーでもあります。90％のユーザが利用する外部向けのAPIについては「非常に安定」していますし、変更があってもB<100％後方互換性を保つつもりです>。イントロスペクション用のAPIは「ほぼ」安定していますが、必要があればまだ微調整する権利は留保しています（もっとも、ここでも後方互換性を保つようできる限りの努力は払うつもりです）。

=head3 Mooseは遅いと聞きましたが本当ですか

これも答えづらい質問ですが、答えはイエスであり、ノーでもあります。

最初にお断りしておくと、世の中にタダで手に入るものは「ありません」。また、Mooseの機能の中には、たしかにほかの機能よりコストのかかるものもあります。ただし、B<使った機能の分しかコストを請求しない>のがMooseのポリシーでもあります。私たちはできる限りの努力を払って、コードを実行するときに使っていない機能のせいで余計な負荷がかかることはないようにしています。もちろんMooseを使うこと自体いくらかのオーバーヘッドをともなうことですが（もっとも、そのほとんどはコンパイル時のものです）、いまのところ速度が必要な方にはいくつかのオプションがあります。

現在利用できるオプションとしては、クラスを不変化して高速化するという方法があります。こうするとコンパイル時のコストは多少大きくなりますが、実行時の速度（特にオブジェクトの生成時）はかなり速くなります。これについてはあまりドキュメントに書かれていませんので、詳細はメーリングリストや#mooseでおたずねください。

また、L<Module::Compile>を使って、高度に最適化されたC<.pmc>ファイルをコンパイルするという案についても議論や実験が進められているほか、いくつかのコアメソッドについてはXSで書き直す計画があります。

=head3 Moose 1.0はいつ出ますか

もう出ています。私は0.18を「実用可能」と宣言しました。

=head2 コンストラクタ

=head3 Mooseで独自のコンストラクタを書くにはどうすればよいですか

理想的には、決して独自のC<new>メソッドは書かないようにしてください（オブジェクト生成時に特別な処理が必要な場合は、Mooseのほかの機能を使って対処してください）。ここではいくつかのシナリオと、Mooseではどのように解決するかを紹介します。

インスタンス生成後に初期化コードを呼ぶ必要がある場合はC<BUILD>メソッドを使ってください（この機能はPerl 6から直接持ってきたものです）。インスタンスを生成すると、すぐにインスタンスチェーンにあるすべてのC<BUILD>メソッドが（正しい順序で）呼ばれるので、スーパークラスもすべて適切に、また確実に初期化することができます。これはクラスのサブクラス化が非常に簡単になりますので、（可能なときは）最善のアプローチです。

インスタンスが実際に生成される前にコンストラクタのパラメータをいじる必要がある場合は、いくつかのオプションがあります。

パラメータ処理をまるごと変更したい場合は、C<BUILDARGS>メソッドを利用できます。デフォルトの実装ではキー／値のペアか、ハッシュリファレンスを受け取るようになっていますが、オーバーライドすれば、順番通りに引数を受け取ったり、別のフォーマットの引数を受け取ったりできるようになります。

個々のパラメータの扱いを変える場合は「型変換」があります（型変換の完全な例や説明についてはL<Moose::Cookbook::Basics::Recipe5>をご覧ください）。型変換を利用すると引数の値を期待された通りの型に変換できます。このアプローチはもっとも柔軟で頑丈ですが、学習曲線はややきつくなってしまいます。

=head3 Mooseを使っていないコンストラクタをMooseで利用するにはどうすればよいですか

ふつうMooseを使っていないクラスをサブクラス化するときの正しいアプローチは委譲することです（これはC<handles>キーワードや型変換、C<lazy_build>を使えば簡単にできます）。だから、サブクラス化するのは往々にして理想的なやり方ではありません。

とはいえ、MooseのデフォルトのコンストラクタはL<Moose::Object>から継承しているので、Mooseを使っていないクラスから継承するとL<Moose::Object>への継承チェーンが壊れてしまいます。この問題を解決するもっとも簡単な方法は、単に明示的にL<Moose::Object>を継承してしまうことです。

もっとも、これでは実際にはMooseのコンストラクタが呼ばれてしまうという問題を常に解決できるとは限らないのですが、さいわい、L<Class::MOP::Class/new_object>という低レベルのコンストラクタの方は特殊なC<__INSTANCE__>というパラメータを受け取りますので、これを使えばMooseのアトリビュートも初期化できるようになります。

  package My::HTML::Template;
  use Moose;

  # explicit inheritance 
  extends 'HTML::Template', 'Moose::Object';

  # explicit constructor
  sub new {
      my $class = shift;
      # call HTML::Template's constructor
      my $obj = $class->SUPER::new(@_);
      return $class->meta->new_object(
          # pass in the constructed object
          # using the special key __INSTANCE__
          __INSTANCE__ => $obj,
          @_, # pass in the normal args
      );
  }

もちろんこれがうまく行くのは、Mooseで書いたクラスと、Mooseを使っていない継承元のクラスのインスタンスの種類（ふつうはハッシュリファレンス）が同じ場合のみです。

なお、こうするとC<BUILDALL>は自動的には呼ばれなくなります（自分で呼ばなければなりません）。

別のテクニックを使うこともできます。たとえば、オブジェクトの生成にはC<Moose::Object::new>を使いつつも、（あれば）Mooseを使っていない継承元のクラスの初期化メソッドを呼ぶという手があります。

また、Mooseベースのアトリビュートが必要とするスロット作成をハッシュの自動生成機能だけにまかせてしまうことも十分可能です（ただし、その場合オブジェクト生成時のアトリビュート機能にいささかの使用制限がついてしまいます）。

要するにやり方はいくつかありますので、拡張したいクラス、利用したい機能に応じて向き不向きを評価するのが一番です。最善のアプローチを知りたいのであれば、例によってIRCやメーリングリストが大いに役に立ちます。

=head2 アクセサ

=head3 Mooseにgetアクセサとsetアクセサを使うよう指示するにはどうすればよいですか

もっとも簡単なのはC<reader>とC<writer>というアトリビュートオプションを使う方法です。サンプルコードはこのようになります。

  has 'bar' => (
      isa    => 'Baz',
      reader => 'get_bar', 
      writer => 'set_bar',
  );

これらのメソッドを生成しても型制約やトリガなどは利用できます。

こんなにたくさんタイプしたくないし、このようなget/setアクセサをデフォルトにしたいという方は、L<MooseX::FollowPBP>をご覧ください。このモジュールを使うとこのように書けるようになります。

  has 'bar' => (
      isa => 'Baz',
      is  => 'rw',
  );

これで、MooseはC<bar>という単一のメソッドを作るかわりに、C<get_bar>とC<set_bar>という別々のメソッドを生成するようになります。

注意：これをグローバルに設定することはB<できません>。そうしてしまうとMooseで作られたほかのクラスを壊してしまうからです。

=head3 アクセサの中で値をオブジェクトにしたり、その逆を行うにはどうすればよいですか

まず、最初に確認したいのは、本当に値からオブジェクトへの変換とオブジェクトから値への変換の双方が必要なのか、ということ。

値からオブジェクトに変換できればよいのであれば、型変換を使うことをおすすめします。L<DateTime>オブジェクトに変換する基本的なサンプルコードはこうなります。

  subtype 'DateTime'
      => as 'Object'
      => where { $_->isa('DateTime') };

  coerce 'DateTime'
      => from 'Str'
        => via { DateTime::Format::MySQL->parse_datetime($_) };

  has 'timestamp' => (is => 'rw', isa => 'DateTime', coerce => 1);

ここではL<DateTime>オブジェクト用に独自のサブタイプを作成して、そのサブタイプに型変換を追加しています。C<timestamp>アトリビュートが期待しているのはC<DateTime>型の値ですが、型変換も試すよう指示されているので、C<timestamp>アクセサにC<Str>型の値が渡されると、C<via>ブロックにあるコードを使ってC<DateTime>オブジェクトへの型変換を行おうとします。

より包括的な型変換の例についてはL<Moose::Cookbook::Basics::Recipe5>をご覧ください。

アトリビュートに渡されたオブジェクトを値に変換する必要がある場合、いまのところベストプラクティスはアクセサにC<around>モディファイアを追加することです。サンプルコードはこうなります。

  # a timestamp which stores as 
  # seconds from the epoch
  has 'timestamp' => (is => 'rw', isa => 'Int');

  around 'timestamp' => sub {
      my $next = shift;
      my ($self, $timestamp) = @_;
      # assume we get a DateTime object ...
      $next->($self, $timestamp->epoch);
  };

型変換を使ってオブジェクトを値に変換することもできるのですが、これは概して非常に複雑で、多くのサブタイプがを必要とするものになります。こちらの例はこのドキュメントで扱う範囲を越えていますので、#mooseでたずねるか、メーリングリストに投稿してください。

さらにもうひとつ、独自のアトリビュートメタクラスを書くというオプションがあります。これもこのドキュメントで扱う範囲を超えていますが、#mooseやメーリングリストでなら喜んで説明します。

=head2 メソッドモディファイア

=head3 C<before>を使ってC<@_>の値を変更するにはどうすればよいですか

実はできないのです。C<before>が実行されるのはメインメソッドの前だけなので、メソッド本体の実行にはおいそれと影響を与えられないのです。そのようなことをしたいのであればC<around>メソッドを使ってください。

=head3 C<before>を使ってメソッドの実行を中断できますか

できますが、止められるのは例外を発生させたときだけです。それでは過激すぎるということであれば、かわりにC<around>を使うことをおすすめします（メインメソッドの実行を余裕を持って中断できるのはC<around>メソッドモディファイアだけです）。例はこうなります。

  around 'baz' => sub {
      my $next = shift;
      my ($self, %options) = @_;
      unless ($options->{bar} eq 'foo') {
	return 'bar';
      }
      $next->($self, %options);
  };

C<$next>メソッドを呼ばないようにすれば、メインメソッドの実行を中断できます。

=head2 型制約

=head3 型制約に独自のエラーメッセージを用意するにはどうすればよいですか

このように、サブタイプを作成するときにC<message>オプションを利用してください。

  subtype 'NaturalLessThanTen' 
      => as 'Natural'
      => where { $_ < 10 }
      => message { "This number ($_) is not less than ten!" };

値がC<NaturalLessThanTen>の型チェックに失敗すると、このメッセージが呼ばれます。

=head3 型制約のチェックを無効にすることはできますか

まだできませんが、すぐにできるようになります（次のリリースではできるようになりそうです）。

=head2 ロール

=head3 合成したロールすべてでBUILDを呼ぶようにするにはどのようにすればよいですか

L<Moose::Cookbook::WTF>、とりわけ「B<ロール>」セクションの「B<合成したロールでBUILDが呼ばれないのはなぜですか>」をご覧ください。

=head3 トレートとはなんですか。ロールとはどう違うのですか

Mooseのトレートはロールとほとんど同じものです。ただし、トレートの方は通常登録されているので（「MyApp::Role::Big」を「Big」という風に）短い名前で呼ぶことができます。

Mooseの文脈では、「ロール」はふつうコンパイル時に「クラス」に合成されます。一方の「トレート」は、ふつうは実行時にクラスのインスタンスに合成して、B<そのインスタンスだけ>に振る舞いを追加したり修正を加えたりするものです。

Mooseの文脈を離れると、トレートとロールは一般的にはまったく同じ意味です。元々の論文ではトレートと呼ばれていましたが、Perl 6ではロールと呼ぶことになっています。

=head1 作者

Stevan Little E<lt>stevan@iinteractive.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2006-2009 by Infinity Interactive, Inc.

L<http://www.iinteractive.com>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

