=encoding utf8

=pod

=head1 題名

Moose::Manual::Delegation - アトリビュートの委譲

=head1 委譲とはなにか

委譲というのは、アトリビュートの別のメソッドを呼ぶだけという「影のような」メソッドを作成できるようにする機能です。この非常に便利な機能を使うと、複雑な「has-a」の関係を単純化して、APIをひとつのクラスに統合してしまうことができるようになります。

また、委譲を使うと、クラスを使う側はそのクラスが持つすべてのオブジェクトを知る必要がなくなるので、覚えなければならないAPIの数も減ります。

委譲の定義は、「本当の」クラス（委譲元のクラス）が提供するひとつ以上のメソッドと、移譲先のクラスに用意するメソッドのマッピングという形で行います。移譲先のクラスでは、委譲元のクラスが提供するメソッド名を再利用することもできますし、独自の名前を用意することもできます。

また、委譲は、既存のクラス（特に、Mooseを使っていないクラスや、サブクラスしづらい（あるいはできない）クラス）をラップするときにも便利です。

=head1 マッピングを定義する

Mooseは委譲のマッピングを定義するために、簡単なものから複雑なものまで、さまざまなオプションを提供しています。

もっとも簡単なのは、単にメソッドのリストを指定する方法です。

  package Website;

  use Moose;

  has 'uri' => (
      is      => 'ro',
      isa     => 'URI',
      handles => [qw( host path )],
  );

こう定義しておくと、C<< $website->host >>を呼べば「とにかく動きます」（裏では、MooseがC<< $website->uri->host >>を呼んでくれます）。

ハッシュリファレンスを使ってマッピングを定義することもできます。こうすると、マッピングの一部でメソッドをリネームできるようになります。

  package Website;

  use Moose;

  has 'uri' => (
      is      => 'ro',
      isa     => 'URI',
      handles => {
          hostname => 'host',
          path     => 'path',
      },
  );

この例ではC<URI.pm>のC<host>というメソッド名を使うかわりに、C<< $website->hostname >>というメソッドを作成しています。

この2つがもっともよく使うマッピングです。残りの方法はもう少し複雑で、あまり一般的でもありません。

  has 'uri' => (
      is      => 'ro',
      isa     => 'URI',
      handles => qr/^(?:host|path|query.*)/,
  );

これは配列の場合と似ていますが、正規表現を使って委譲元が提供しているすべてのメソッドに対してマッチするか調べる点が異なります。これを正しく動作させるためには、アトリビュートのC<isa>パラメータを指定しなければなりません、また、そのパラメータはクラスでなければなりません。Mooseはこのパラメータを利用して委譲元のクラスのイントロスペクションを行い、どんなメソッドを提供しているか判断します。

C<handles>の値にはロールの名前を使うこともできます。

  has 'uri' => (
      is      => 'ro',
      isa     => 'URI',
      handles => 'HasURI',
  );

Mooseはこのロールのイントロスペクションを行ってどんなメソッドを提供しているか判断し、そのそれぞれのメソッドについてマッピングを生成します。

最後に、マッピングを「生成」するサブルーチンリファレンスを指定することもできます。おそらくこのバージョンを使う必要は（あったとしても）めったにないでしょうが、実際にどう動作するのかについての詳細はL<Moose>のドキュメントをご覧ください。

=head1 PERL DATA STRUCTURES

Handles also will allow you to delegate to "helper" methods that work on
common Perl data structures. If you remember or have ever used
L<MooseX::AttributeHelpers|MooseX::AttributeHelpers> the mechanism is very
similar.

  has 'queue' => (
      isa     => 'ArrayRef[Item]',
      traits  => ['Array'],
      default => sub { [ ] },
      handles => {
          add_item  => 'push',
          next_item => 'shift',
      },
  )

By providing the C<Array> trait to the C<traits> parameter you signal to
Moose that you would like to use the set of Array helpers. Moose will then
create C<add_item> and C<next_item> method that "just works". Behind the
scenes C<add_item> is something like

  sub add_item {
      my ($self, @items) = @_;

      for my $item (@items) {
          $Item_TC->validate($item);
      }

      push @{ $self->queue }, @items;
  }

There are traits for not only C<Array> but also C<Hash>, C<Bool>, C<String>,
C<Number>, and C<Counter>. For more information see the documentation in
L<Moose::Meta::Attribute::Native|Moose::Meta::Attribute::Native>.

=head1 CURRYING

Currying is a way of creating a method or function from another method or
function with some of the parameters pre-defined. Moose provides the ability to
curry methods when creating delegates.

    package Spider;
    use Moose;

    has request => (
        is      => 'ro'
        isa     => 'HTTP::Request',
        handles => {
            set_user_agent => [ header => 'UserAgent' ],
        },
    )

With this definition, calling C<< $spider->set_user_agent('MyClient') >> will
behind the scenes call C<< $spider->request->header('UserAgent', 'MyClient') >>.

=head1 アトリビュートが見つからない場合

必須でなかったり未定義になりうるアトリビュートのメソッドを委譲すること自体はまったく問題ありませんが、委譲したメソッドが呼ばれたときにアトリビュートにオブジェクトが入っていなかった場合は実行時エラーが発生します。

=head1 作者

Dave Rolsky E<lt>autarch@urth.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2009 by Infinity Interactive, Inc.

L<http://www.iinteractive.com>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

