=head1 NAME

perldebug - Perl debugging

=head1 DESCRIPTION

=begin original

First of all, have you tried using the B<-w> switch?

=end original

まず最初に一言「もう B<-w> スイッチはお使いになりましたか。」

=head1 The Perl Debugger

=begin original

If you invoke Perl with the B<-d> switch, your script runs under the
Perl source debugger.  This works like an interactive Perl
environment, prompting for debugger commands that let you examine
source code, set breakpoints, get stack backtraces, change the values of
variables, etc.  This is so convenient that you often fire up
the debugger all by itself just to test out Perl constructs
interactively to see what they do.  For example:

=end original

Perl を -d スイッチを付けて起動すれば、スクリプトは Perl ソースデバッガ
上で実行されることになります。
これは対話的な Perl 環境のように動作し、
ソースコードの表示、ブレークポイントの設定、スタックのバックトレース、
変数の値の変更、などを実行するデバッガコマンドを入力できます。
これはとても便利なので、単にやりたいことを対話的に試すために
デバッガを起動するようになるでしょう。以下は例です。

    $ perl -d -e 42

=begin original

In Perl, the debugger is not a separate program the way it usually is in the
typical compiled environment.  Instead, the B<-d> flag tells the compiler
to insert source information into the parse trees it's about to hand off
to the interpreter.  That means your code must first compile correctly
for the debugger to work on it.  Then when the interpreter starts up, it
preloads a special Perl library file containing the debugger.

=end original

しかし、Perl デバッガは典型的なコンパイルされた環境の様に独立した
プログラムではありません。　その代わりに、
-d フラグによって、コンパイラがインタプリタに渡すパース木にソース情報を
埋め込むようにしています。これは、ソースがデバッガ上で動作できるためには、
一度正常にコンパイルできないといけないということです。
それからインタプリタが起動され、デバッガを含む
特別な Perl ライブラリをロードします。

=begin original

The program will halt I<right before> the first run-time executable
statement (but see below regarding compile-time statements) and ask you
to enter a debugger command.  Contrary to popular expectations, whenever
the debugger halts and shows you a line of code, it always displays the
line it's I<about> to execute, rather than the one it has just executed.

=end original

プログラムは、最初の実行時実行文のI<直前>で停止し
(ただし、以下コンパイル時実行文については後述します)、以下に示すいずれかの
コマンドが入力されるのを待ちます。
よくある期待とは逆に、
デバッガが停止してある行のコードを表示しているときは、
直前に実行した行ではなく、常にI<今から実行する>行を表示します。

=begin original

Any command not recognized by the debugger is directly executed
(C<eval>'d) as Perl code in the current package.  (The debugger
uses the DB package for keeping its own state information.)

=end original

デバッガが認識できないコマンドは現在のパッケージ内で Perl のコードとして
実行(C<eval>)されます。
(デバッガは自分自身の状態を保存するために DB パッケージを使います。)

=begin original

For any text entered at the debugger prompt, leading and trailing whitespace
is first stripped before further processing.  If a debugger command
coincides with some function in your own program, merely precede the
function with something that doesn't look like a debugger command, such
as a leading C<;> or perhaps a C<+>, or by wrapping it with parentheses
or braces.

=end original

デバッガコマンドとして入力された文字列は、まず先頭と末尾の
空白が切り詰められます。
デバッガコマンドがプログラムの関数名と一致する場合、
関数名の前に C<;> や C<+> のような、デバッガコマンドに見えない文字を
付け加えるか、括弧でくくってください。

=head2 Debugger Commands

(デバッガコマンド)

=begin original

The debugger understands the following commands:

=end original

デバッガは以下のコマンドを理解します。

=over 12

=item h [command]

=begin original

Prints out a help message.

=end original

ヘルプメッセージを表示します。

=begin original

If you supply another debugger command as an argument to the C<h> command,
it prints out the description for just that command.  The special
argument of C<h h> produces a more compact help listing, designed to fit
together on one screen.

=end original

他のデバッガコマンドを C<h> コマンドの引数として渡すと、
そのコマンドの説明を表示します。
C<h h> という特別なコマンドは、一画面で収まるようにデザインされた
よりコンパクトなヘルプリストを表示します。

=begin original

If the output of the C<h> command (or any command, for that matter) scrolls
past your screen, precede the command with a leading pipe symbol so
that it's run through your pager, as in

=end original

C<h> コマンド(や他のコマンドでも)の出力で画面がスクロールしてしまう場合、
以下のようにコマンドの前にパイプ記号をつけるとページャーを呼び出します:

    DB> |h

=begin original

You may change the pager which is used via C<O pager=...> command.

=end original

使用されるページャーは C<O pager=...> コマンドで変更できます。

=item p expr

=begin original

Same as C<print {$DB::OUT} expr> in the current package.  In particular,
because this is just Perl's own C<print> function, this means that nested
data structures and objects are not dumped, unlike with the C<x> command.

=end original

現在のパッケージでの C<print {$DB::OUT} expr> と同じです。
特に、これは Perl 自身の C<print> 関数なので、
C<x> コマンドと違って、ネストしたデータ構造やオブジェクトはダンプしません。

=begin original

The C<DB::OUT> filehandle is opened to F</dev/tty>, regardless of
where STDOUT may be redirected to.

=end original

STDOUT がどこにリダイレクトされていても、
ファイルハンドル C<DB::OUT> は F</dev/tty> に対して
オープンされています。

=item x expr

=begin original

Evaluates its expression in list context and dumps out the result
in a pretty-printed fashion.  Nested data structures are printed out
recursively, unlike the real C<print> function in Perl.
See L<Dumpvalue> if you'd like to do this yourself.

=end original

式をリストコンテキストで評価し、結果を多少読みやすい形で表示します。
ネストしたデータは再帰的に表示します。
これは Perl の実際の C<print> 関数とは異なります。
これを自分自身で行いたい場合は L<Dumpvalue> を参照して下さい。

=begin original

The output format is governed by multiple options described under
L<"Configurable Options">.

=end original

出力フォーマットは L<"Configurable Options"> に記された
様々なオプションの影響を受けます。

=item V [pkg [vars]]

=begin original

Display all (or some) variables in package (defaulting to C<main>) 
using a data pretty-printer (hashes show their keys and values so
you see what's what, control characters are made printable, etc.).
Make sure you don't put the type specifier (like C<$>) there, just
the symbol names, like this:

=end original

package (デフォルトは C<main>) 内のすべて (または、一部) の
変数 (variable) をデータプリティプリンタを使って表示します
(ハッシュは何が何か解るように、key と value を表示し、
コントロール文字は表示できる形にします)。
以下に示すように、symbol は名前だけを示し、(C<$> などの) 型識別子を
付けないようにしてください:

    V DB filename line

=begin original

Use C<~pattern> and C<!pattern> for positive and negative regexes.

=end original

正と逆の正規表現のためには C<~pattern> と C<!pattern> を使ってください。

=begin original

This is similar to calling the C<x> command on each applicable var.

=end original

これは有効な変数のそれぞれについて C<x> を呼び出すのと似ています。

=item X [vars]

=begin original

Same as C<V currentpackage [vars]>.

=end original

C<V 現在のパッケージ [vars]> と同じです。

=item T

=begin original

Produce a stack backtrace.  See below for details on its output.

=end original

スタックのバックトレースを行います。出力についての詳細は後述します。

=item s [expr]

=begin original

Single step.  Executes until the beginning of another
statement, descending into subroutine calls.  If an expression is
supplied that includes function calls, it too will be single-stepped.

=end original

シングルステップ実行します。
サブルーチンをたどりながら、別の実行文の先頭に到達するまで実行します。
関数呼び出しを含む式が与えられた場合、これもシングルステップ実行します。

=item n [expr]

=begin original

Next.  Executes over subroutine calls, until the beginning
of the next statement.  If an expression is supplied that includes
function calls, those functions will be executed with stops before
each statement.

=end original

ネクスト。次の実行文の先頭に到達するまで、サブルーチンにまたがって実行します。
関数呼び出しを含む式が与えられた場合、
各行毎に停止しながら関数を実行します。

=item r

=begin original

Continue until the return from the current subroutine.
Dump the return value if the C<PrintRet> option is set (default).

=end original

現在のサブルーチンから戻るまで実行します。
C<PrintRet> がセットされていれば(デフォルトではセットされています)
返り値をダンプします。

=item <CR>

=begin original

Repeat last C<n> or C<s> command.

=end original

最後の C<n> または C<s> を繰り返します。

=item c [line|sub]

=begin original

Continue, optionally inserting a one-time-only breakpoint
at the specified line or subroutine.

=end original

続きを実行します。
オプションとして、1 回限りのブレークポイントを
指定された行またはサブルーチンに設定します。

=item l

=begin original

List next window of lines.

=end original

次の 1 画面分をリスト表示します。

=item l min+incr

=begin original

List C<incr+1> lines starting at C<min>.

=end original

C<min> から C<incr+1> 行をリスト表示します。

=item l min-max

=begin original

List lines C<min> through C<max>.  C<l -> is synonymous to C<->.

=end original

C<min> 行から C<max> 行をリスト表示します。
C<l -> は C<-> と同じです。

=item l line

=begin original

List a single line.

=end original

指定行をリスト表示します。

=item l subname

=begin original

List first window of lines from subroutine.  I<subname> may
be a variable that contains a code reference.

=end original

サブルーチンの最初の一画面分をリスト表示します。
I<subname> は コードリファレンスが入った変数でも構いません。

=item -

=begin original

List previous window of lines.

=end original

前の 1 画面分をリスト表示します。

=item w [line]

=begin original

List window (a few lines) around the current line.

=end original

指定行付近のウィンドウ (数行以上のコード) をリスト表示します。

=item .

=begin original

Return the internal debugger pointer to the line last
executed, and print out that line.

=end original

最後に実行した行への内部デバッガポインタを返し、
その行を表示します。

=item f filename

=begin original

Switch to viewing a different file or C<eval> statement.  If I<filename>
is not a full pathname found in the values of %INC, it is considered 
a regex.

=end original

異なるファイルまたは C<eval> 行に表示を切り替えます。
もし I<filename> が %INC にあるフルパス名でなければ、
正規表現として扱われます。

=begin original

C<eval>ed strings (when accessible) are considered to be filenames:
C<f (eval 7)> and C<f eval 7\b> access the body of the 7th C<eval>ed string
(in the order of execution).  The bodies of the currently executed C<eval>
and of C<eval>ed strings that define subroutines are saved and thus
accessible.

=end original

C<eval> した文字列は(アクセス可能なら)ファイル名として扱われます:
C<f (eval 7)> と C<f eval 7\b> は (実行した順で) 7 番目に C<eval> した
文字列の中身にアクセスします。
現在実行した C<eval> の中身と、サブルーチンを定義する C<eval> した
中身は保存されるので、アクセス可能です。

=item /pattern/

=begin original

Search forwards for pattern (a Perl regex); final / is optional.

=end original

pattern を用いて Perl 正規表現による前方検索を行います。
最後の / はなくてもかまいません。

=item ?pattern?

=begin original

Search backwards for pattern; final ? is optional.

=end original

pattern を用いて後方検索を行います。
最後の ? はなくてもかまいません。

=item L

=begin original

List all breakpoints and actions.

=end original

全てのブレークポイントやアクションをリストアップします。

=item S [[!]regex]

=begin original

List subroutine names [not] matching the regex.

=end original

regex に一致する(または一致しない)サブルーチン名をリストアップします。

=item t

=begin original

Toggle trace mode (see also the C<AutoTrace> option).

=end original

トレースモードの on/off を切り替えます。(C<AutoTrace>
オプションも参照して下さい)

=item t expr

=begin original

Trace through execution of C<expr>.
See L<perldebguts/"Frame Listing Output Examples"> for examples.

=end original

C<expr> の実行をトレースします。
例については L<perldebguts/"Frame Listing Output Examples"> を
参照して下さい。

=item b [line] [condition]

=begin original

Set a breakpoint before the given line.  If I<line> is omitted, set a
breakpoint on the line about to be executed.  If a condition
is specified, it's evaluated each time the statement is reached: a
breakpoint is taken only if the condition is true.  Breakpoints may
only be set on lines that begin an executable statement.  Conditions
don't use C<if>:

=end original

与えられた行の直前にブレークポイントを設定します。
C<line> を省略するとまさに実行しようとしている行に
ブレークポイントを設定します。
condition が指定されると、その文にさしかかる度に評価されます。
condition が真となったときにだけブレークポイントが働きます。
ブレークポイントは、実行可能な文で始まる行にだけ、
設定できます。　condition には C<if> を使いません:

    b 237 $x > 30
    b 237 ++$count237 < 11
    b 33 /pattern/i

=item b subname [condition]

=begin original

Set a breakpoint before the first line of the named subroutine.  I<subname> may
be a variable containing a code reference (in this case I<condition>
is not supported).

=end original

サブルーチンの最初の実行可能文にブレークポイントを設定します。
I<subname> は コードリファレンスが入った変数でも構いません
(この場合は I<condition> は非対応です)。

=item b postpone subname [condition]

=begin original

Set a breakpoint at first line of subroutine after it is compiled.

=end original

コンパイル後、サブルーチンの最初の行にブレークポイントをセットします。

=item b load filename

=begin original

Set a breakpoint before the first executed line of the I<filename>,
which should be a full pathname found amongst the %INC values.

=end original

I<filename> の最初に実行される行の手前にブレークポイントをセットします。
これは %INC の値に含まれるフルパス名であるべきです。

=item b compile subname

=begin original

Sets a breakpoint before the first statement executed after the specified
subroutine is compiled.

=end original

指定されたサブルーチンがコンパイルされた後、最初に実行される文の手前に
ブレークポイントをセットします。

=item d [line]

=begin original

Delete a breakpoint from the specified I<line>.  If I<line> is omitted, deletes
the breakpoint from the line about to be executed.

=end original

I<line>で指定されたブレークポイントを削除します。
I<line> が省略されると、
まさに実行しようとしている行のブレークポイントを削除します。

=item D

=begin original

Delete all installed breakpoints.

=end original

すべてのブレークポイントを削除します。

=item a [line] command

=begin original

Set an action to be done before the line is executed.  If I<line> is
omitted, set an action on the line about to be executed.
The sequence of steps taken by the debugger is

=end original

その行を実行する前に行うアクションを設定します。
I<line> が省略されると、いままさに実行しようとしていた行に
アクションを設定します。
デバッガが実行する処理の順番は以下の通りです。

=begin original

  1. check for a breakpoint at this line
  2. print the line if necessary (tracing)
  3. do any actions associated with that line
  4. prompt user if at a breakpoint or in single-step
  5. evaluate line

=end original

  1. この行のブレークポイントをチェックします
  2. 必要なら行を表示します(トレース)
  3. この行に結び付けられたアクションを実行します
  4. ブレークポイントやシングルステップの場合はユーザーに確認します
  5. 行を評価します

=begin original

For example, this will print out $foo every time line
53 is passed:

=end original

例えば、以下のコードは 53 行を通過する毎に $foo を表示します。

    a 53 print "DB FOUND $foo\n"

=item a [line]

=begin original

Delete an action from the specified line.  If I<line> is omitted, delete
the action on the line that is about to be executed.

=end original

指定された行に設定されたアクションを削除します。
I<line> が省略されると、いままさに実行しようとしている行に設定されている
アクションが削除されます。

=item A

=begin original

Delete all installed actions.

=end original

設定されたすべてのアクションを削除します。

=item W expr

=begin original

Add a global watch-expression.  We hope you know what one of these
is, because they're supposed to be obvious.  B<WARNING>: It is far
too easy to destroy your watch expressions by accidentally omitting
the I<expr>.

=end original

グローバルなウォッチ式を追加します。この機能はよくあるものなので、
どういうものかはわかってもらえると思います。
B<警告>: 間違えて I<expr> を指定しないでこのコマンドを実行してしまうと、
あっさりと設定が消えてしまいます。

=item W

=begin original

Delete all watch-expressions.

=end original

全てのウォッチ式を削除します。

=item O booloption ...

=begin original

Set each listed Boolean option to the value C<1>.

=end original

リストされた各真偽値オプションの値を C<1> に設定します。

=item O anyoption? ...

=begin original

Print out the value of one or more options.

=end original

1 つ、あるいは複数のオプションの値を表示します。

=item O option=value ...

Set the value of one or more options.  If the value has internal
whitespace, it should be quoted.  For example, you could set C<O
pager="less -MQeicsNfr"> to call B<less> with those specific options.
You may use either single or double quotes, but if you do, you must
escape any embedded instances of same sort of quote you began with,
as well as any escaping any escapes that immediately precede that
quote but which are not meant to escape the quote itself.  In other
words, you follow single-quoting rules irrespective of the quote;
eg: C<O option='this isn\'t bad'> or C<O option="She said, \"Isn't
it?\"">.

For historical reasons, the C<=value> is optional, but defaults to
1 only where it is safe to do so--that is, mostly for Boolean
options.  It is always better to assign a specific value using C<=>.
The C<option> can be abbreviated, but for clarity probably should
not be.  Several options can be set together.  See L<"Configurable Options"> 
for a list of these.

=item < ? 

=begin original

List out all pre-prompt Perl command actions.

=end original

プロンプト表示前に実行するアクションを全て表示します。

=item < [ command ]

=begin original

Set an action (Perl command) to happen before every debugger prompt.
A multi-line command may be entered by backslashing the newlines.  
B<WARNING> If C<command> is missing, all actions are wiped out!

=end original

デバッガがプロンプトを出す直前に、毎回実行するアクション
(Perl のコマンド)を設定します。
複数行の command は、バックスラッシュと改行で書くことができます。
B<警告> もし C<command> がないと、全てのアクションが消えてしまいます!

=item << command

=begin original

Add an action (Perl command) to happen before every debugger prompt.
A multi-line command may be entered by backwhacking the newlines.

=end original

デバッガがプロンプトを出す直前に、毎回実行するアクション
(Perl のコマンド)を追加します。
複数行の command は、バックスラッシュと改行で書くことができます。

=item > ?

=begin original

List out post-prompt Perl command actions.

=end original

プロンプト表示後に実行するアクションを全て表示します。

=item > command

=begin original

Set an action (Perl command) to happen after the prompt when you've
just given a command to return to executing the script.  A multi-line
command may be entered by backslashing the newlines (we bet you
couldn't've guessed this by now).  B<WARNING> If C<command> is
missing, all actions are wiped out!

=end original

スクリプトの実行に戻るコマンドを入力した時に、デバッガが
プロンプトを出した後で、毎回実行するアクション(Perl のコマンド)を設定します。
複数行の command は、バックスラッシュと改行で書くことができます
(きっとあなたは今までこのことを知らなかったはずです)。
B<警告> もし C<command> がないと、全てのアクションが消えてしまいます!

=item >> command

=begin original

Adds an action (Perl command) to happen after the prompt when you've
just given a command to return to executing the script.  A multi-line
command may be entered by backslashing the newlines.

=end original

スクリプトの実行に戻るコマンドを入力した時に、デバッガが
プロンプトを出した後で、毎回実行するアクション(Perl のコマンド)を追加します。
複数行の command は、バックスラッシュと改行で書くことができます。

=item { ?

=begin original

List out pre-prompt debugger commands.

=end original

プロンプト表示前に実行するデバッガコマンドを表示します。

=item { [ command ]

Set an action (debugger command) to happen before every debugger prompt.
A multi-line command may be entered in the customary fashion.  
B<WARNING> If C<command> is missing, all actions are wiped out!

Because this command is in some senses new, a warning is issued if
you appear to have accidentally entered a block instead.  If that's
what you mean to do, write it as with C<;{ ... }> or even 
C<do { ... }>.

=item {{ command

=begin original

Add an action (debugger command) to happen before every debugger prompt.
A multi-line command may be entered, if you can guess how: see above.

=end original

毎回デバッガプロンプトを表示する前に実行するアクション(デバッガコマンド)を
追加します。予測可能な方法な方法で複数行コマンドも登録できます:
上記を参照してください。

=item ! number

=begin original

Redo a previous command (defaults to the previous command).

=end original

以前のコマンドを再実行します。(number が省略されると、直前のコマンドを実行します)

=item ! -number

=begin original

Redo number'th previous command.

=end original

指定数値分前のコマンドを実行します。

=item ! pattern

=begin original

Redo last command that started with pattern.
See C<O recallCommand>, too.

=end original

pattern で始まるうち、最も最近に実行されたコマンドを
再実行します。
C<O recallCommand> も参照して下さい。

=item !! cmd

=begin original

Run cmd in a subprocess (reads from DB::IN, writes to DB::OUT) See
C<O shellBang>, also.  Note that the user's current shell (well,
their C<$ENV{SHELL}> variable) will be used, which can interfere
with proper interpretation of exit status or signal and coredump
information.

=end original

cmd をサブプロセスとして実行します(DB::IN から読み込み、DB::OUT に書き出します)。
C<O shellBang> も参照してください。
ユーザーの現在のシェル(つまり、 C<$ENV{SHELL}> 変数)が使われるので、
終了コードの適切な解釈やシグナルとコアダンプの情報が妨害されるかもしれない
ことに注意してください。

=item H -number

=begin original

Display last n commands.  Only commands longer than one character are
listed.  If I<number> is omitted, list them all.

=end original

最近の指定数値分のコマンドを表示します。
2 文字以上のコマンドのみが表示されます。I<number> が省略
されると、全てを表示します。

=item q or ^D

=begin original

Quit.  ("quit" doesn't work for this, unless you've made an alias)
This is the only supported way to exit the debugger, though typing
C<exit> twice might work.

=end original

デバッガを終了します。
(エイリアスを設定しない限り、"quit" はこの目的には使えません。)
これはデバッガを終了する唯一の方法ですが、C<exit> を2回
入力しても動作します。

=begin original

Set the C<inhibit_exit> option to 0 if you want to be able to step
off the end the script.  You may also need to set $finished to 0 
if you want to step through global destruction.

=end original

スクリプトの最後にステップ実行できるようにしたい場合は、
C<inhibit_exit> オプションに 0 を設定してください。
グローバルなデストラクタを実行してステップ実行したい場合は、
$finished に 0 を設定する必要があります。

=item R

=begin original

Restart the debugger by C<exec()>ing a new session.  We try to maintain
your history across this, but internal settings and command-line options
may be lost.

=end original

新しいセッションを C<exec()> することでデバッガを再起動します。
履歴は残そうと努力しますが、内部設定やコマンドラインオプションは
失われるかもしれません。

=begin original

The following setting are currently preserved: history, breakpoints,
actions, debugger options, and the Perl command-line
options B<-w>, B<-I>, and B<-e>.

=end original

今のところ、以下の設定は保存されます: 履歴、ブレークポイント、アクション、
デバッガオプション、Perl コマンドラインオプション B<-w>, B<-I>, B<-e>。

=item |dbcmd

=begin original

Run the debugger command, piping DB::OUT into your current pager.

=end original

デバッガコマンドを実行し、DB::OUT をパイプであなたの現在のページャと繋ぎます。

=item ||dbcmd

=begin original

Same as C<|dbcmd> but DB::OUT is temporarily C<select>ed as well.

=end original

C<|dbcmd> と同様ですが、 DB::OUT は一時的に C<select> で
選択されているものになります。

=item = [alias value]

=begin original

Define a command alias, like

=end original

以下のようにコマンドエイリアスを定義する:

    = quit q

=begin original

or list current aliases.

=end original

または現在のエイリアスの一覧を表示します。

=item command

=begin original

Execute command as a Perl statement.  A trailing semicolon will be
supplied.  If the Perl statement would otherwise be confused for a
Perl debugger, use a leading semicolon, too.

=end original

command を Perl の文として実行します。文末のセミコロンはなくてもかまいません。
Perl の文が Perl デバッガにとって紛らわしい場合は
先頭にセミコロンをつけてください。

=item m expr

List which methods may be called on the result of the evaluated
expression.  The expression may evaluated to a reference to a 
blessed object, or to a package name.

=item man [manpage]

Despite its name, this calls your system's default documentation
viewer on the given page, or on the viewer itself if I<manpage> is
omitted.  If that viewer is B<man>, the current C<Config> information
is used to invoke B<man> using the proper MANPATH or S<B<-M>
I<manpath>> option.  Failed lookups of the form C<XXX> that match
known manpages of the form I<perlXXX> will be retried.  This lets
you type C<man debug> or C<man op> from the debugger.

On systems traditionally bereft of a usable B<man> command, the
debugger invokes B<perldoc>.  Occasionally this determination is
incorrect due to recalcitrant vendors or rather more felicitously,
to enterprising users.  If you fall into either category, just
manually set the $DB::doccmd variable to whatever viewer to view
the Perl documentation on your system.  This may be set in an rc
file, or through direct assignment.  We're still waiting for a
working example of something along the lines of:

    $DB::doccmd = 'netscape -remote http://something.here/';

=back

=head2 Configurable Options

(設定可能なオプション)

=begin original

The debugger has numerous options settable using the C<O> command,
either interactively or from the environment or an rc file.
(./.perldb or ~/.perldb under Unix.)

=end original

デバッガには C<O> コマンドで設定できるさまざまなオプションがあります。
これは対話的、環境変数、rc ファイル (Unix では ./.perldb または
~/.perldb) で設定できます。

=over 12

=item C<recallCommand>, C<ShellBang>

The characters used to recall command or spawn shell.  By
default, both are set to C<!>, which is unfortunate.

=item C<pager>

Program to use for output of pager-piped commands (those beginning
with a C<|> character.)  By default, C<$ENV{PAGER}> will be used.
Because the debugger uses your current terminal characteristics
for bold and underlining, if the chosen pager does not pass escape
sequences through unchanged, the output of some debugger commands
will not be readable when sent through the pager.

=item C<tkRunning>

Run Tk while prompting (with ReadLine).

=item C<signalLevel>, C<warnLevel>, C<dieLevel>

Level of verbosity.  By default, the debugger leaves your exceptions
and warnings alone, because altering them can break correctly running
programs.  It will attempt to print a message when uncaught INT, BUS, or
SEGV signals arrive.  (But see the mention of signals in L<BUGS> below.)

To disable this default safe mode, set these values to something higher
than 0.  At a level of 1, you get backtraces upon receiving any kind
of warning (this is often annoying) or exception (this is
often valuable).  Unfortunately, the debugger cannot discern fatal
exceptions from non-fatal ones.  If C<dieLevel> is even 1, then your
non-fatal exceptions are also traced and unceremoniously altered if they
came from C<eval'd> strings or from any kind of C<eval> within modules
you're attempting to load.  If C<dieLevel> is 2, the debugger doesn't
care where they came from:  It usurps your exception handler and prints
out a trace, then modifies all exceptions with its own embellishments.
This may perhaps be useful for some tracing purposes, but tends to hopelessly
destroy any program that takes its exception handling seriously.

=item C<AutoTrace>

Trace mode (similar to C<t> command, but can be put into
C<PERLDB_OPTS>).

=item C<LineInfo>

File or pipe to print line number info to.  If it is a pipe (say,
C<|visual_perl_db>), then a short message is used.  This is the
mechanism used to interact with a slave editor or visual debugger,
such as the special C<vi> or C<emacs> hooks, or the C<ddd> graphical
debugger.

=item C<inhibit_exit>

If 0, allows I<stepping off> the end of the script.

=item C<PrintRet>

Print return value after C<r> command if set (default).

=item C<ornaments>

Affects screen appearance of the command line (see L<Term::ReadLine>).
There is currently no way to disable these, which can render
some output illegible on some displays, or with some pagers.
This is considered a bug.

=item C<frame>

Affects the printing of messages upon entry and exit from subroutines.  If
C<frame & 2> is false, messages are printed on entry only. (Printing
on exit might be useful if interspersed with other messages.)

If C<frame & 4>, arguments to functions are printed, plus context
and caller info.  If C<frame & 8>, overloaded C<stringify> and
C<tie>d C<FETCH> is enabled on the printed arguments.  If C<frame
& 16>, the return value from the subroutine is printed.

The length at which the argument list is truncated is governed by the
next option:

=item C<maxTraceLen>

Length to truncate the argument list when the C<frame> option's
bit 4 is set.

=back

=begin original

The following options affect what happens with C<V>, C<X>, and C<x>
commands:

=end original

以下のオプションは C<V>, C<X>, C<x> コマンドに影響を与えます。

=over 12

=item C<arrayDepth>, C<hashDepth>

=begin original

Print only first N elements ('' for all).

=end original

最初の N 要素だけを表示します('' を指定すると全て表示します)。

=item C<compactDump>, C<veryCompact>

=begin original

Change the style of array and hash output.  If C<compactDump>, short array
may be printed on one line.

=end original

配列とハッシュの出力スタイルを変更します。
C<compactDump> の場合は、短い配列は 1 行で表示します。

=item C<globPrint>

=begin original

Whether to print contents of globs.

=end original

グロブの内容を表示するかどうかです。

=item C<DumpDBFiles>

=begin original

Dump arrays holding debugged files.

=end original

デバッグしていているファイルが保持している配列をダンプします。

=item C<DumpPackages>

=begin original

Dump symbol tables of packages.

=end original

パッケージのシンボルテーブルをダンプします。

=item C<DumpReused>

=begin original

Dump contents of "reused" addresses.

=end original

「再利用された」アドレスの内容をダンプします。

=item C<quote>, C<HighBit>, C<undefPrint>

Change the style of string dump.  The default value for C<quote>
is C<auto>; one can enable double-quotish or single-quotish format
by setting it to C<"> or C<'>, respectively.  By default, characters
with their high bit set are printed verbatim.

=item C<UsageOnly>

Rudimentary per-package memory usage dump.  Calculates total
size of strings found in variables in the package.  This does not
include lexicals in a module's file scope, or lost in closures.

=back

=begin original

After the rc file is read, the debugger reads the C<$ENV{PERLDB_OPTS}>
environment variable and parses this as the remainder of a `O ...'
line as one might enter at the debugger prompt.  You may place the
initialization options C<TTY>, C<noTTY>, C<ReadLine>, and C<NonStop>
there.

=end original

rc ファイルが読み込まれた後、デバッガは C<$ENV{PERLDB_OPTS}> 環境変数を
読み込み、デバッガのプロンプトから `O ...' として入力されたかのように
パーズします。
初期化オプション C<TTY>, C<noTTY>, C<ReadLine>, C<NonStop> も
ここで設定できます。

=begin original

If your rc file contains:

=end original

rc ファイルに以下のように書くと:

  parse_options("NonStop=1 LineInfo=db.out AutoTrace");

=begin original

then your script will run without human intervention, putting trace
information into the file I<db.out>.  (If you interrupt it, you'd
better reset C<LineInfo> to F</dev/tty> if you expect to see anything.)

=end original

スクリプトは人間の介入なしに実行され、トレース情報を
I<db.out> ファイルに出力します。
(中断して、何も表示されない場合は、C<LineInfo> を F</dev/tty> に
リセットしたほうがよいでしょう。)

=over 12

=item C<TTY>

The TTY to use for debugging I/O.

=item C<noTTY>

If set, the debugger goes into C<NonStop> mode and will not connect to a TTY.  If
interrupted (or if control goes to the debugger via explicit setting of
$DB::signal or $DB::single from the Perl script), it connects to a TTY
specified in the C<TTY> option at startup, or to a tty found at
runtime using the C<Term::Rendezvous> module of your choice.

This module should implement a method named C<new> that returns an object
with two methods: C<IN> and C<OUT>.  These should return filehandles to use
for debugging input and output correspondingly.  The C<new> method should
inspect an argument containing the value of C<$ENV{PERLDB_NOTTY}> at
startup, or C<"/tmp/perldbtty$$"> otherwise.  This file is not 
inspected for proper ownership, so security hazards are theoretically
possible.

=item C<ReadLine>

If false, readline support in the debugger is disabled in order
to debug applications that themselves use ReadLine.

=item C<NonStop>

If set, the debugger goes into non-interactive mode until interrupted, or
programmatically by setting $DB::signal or $DB::single.

=back

=begin original

Here's an example of using the C<$ENV{PERLDB_OPTS}> variable:

=end original

以下に C<$ENV{PERLDB_OPTS}> 変数を使った例を示します。

    $ PERLDB_OPTS="NonStop frame=2" perl -d myprogram

That will run the script B<myprogram> without human intervention,
printing out the call tree with entry and exit points.  Note that
C<NonStop=1 frame=2> is equivalent to C<N f=2>, and that originally,
options could be uniquely abbreviated by the first letter (modulo
the C<Dump*> options).  It is nevertheless recommended that you
always spell them out in full for legibility and future compatibility.

Other examples include

    $ PERLDB_OPTS="NonStop frame=2" perl -d myprogram

which runs script non-interactively, printing info on each entry
into a subroutine and each executed line into the file named F<listing>.
(If you interrupt it, you would better reset C<LineInfo> to something
"interactive"!)

Other examples include (using standard shell syntax to show environment
variable settings):

  $ ( PERLDB_OPTS="NonStop frame=1 AutoTrace LineInfo=tperl.out"
      perl -d myprogram )

which may be useful for debugging a program that uses C<Term::ReadLine>
itself.  Do not forget to detach your shell from the TTY in the window that
corresponds to F</dev/ttyXX>, say, by issuing a command like

  $ sleep 1000000

See L<perldebguts/"Debugger Internals"> for details.

=head2 Debugger input/output

(デバッガの入出力)

=over 8

=item Prompt

The debugger prompt is something like

    DB<8>

or even

    DB<<17>>

where that number is the command number, and which you'd use to
access with the built-in B<csh>-like history mechanism.  For example,
C<!17> would repeat command number 17.  The depth of the angle
brackets indicates the nesting depth of the debugger.  You could
get more than one set of brackets, for example, if you'd already
at a breakpoint and then printed the result of a function call that
itself has a breakpoint, or you step into an expression via C<s/n/t
expression> command.

=item Multiline commands

If you want to enter a multi-line command, such as a subroutine
definition with several statements or a format, escape the newline
that would normally end the debugger command with a backslash.
Here's an example:

      DB<1> for (1..4) {         \
      cont:     print "ok\n";   \
      cont: }
      ok
      ok
      ok
      ok

Note that this business of escaping a newline is specific to interactive
commands typed into the debugger.

=item Stack backtrace

Here's an example of what a stack backtrace via C<T> command might
look like:

    $ = main::infested called from file `Ambulation.pm' line 10
    @ = Ambulation::legs(1, 2, 3, 4) called from file `camel_flea' line 7
    $ = main::pests('bactrian', 4) called from file `camel_flea' line 4

The left-hand character up there indicates the context in which the
function was called, with C<$> and C<@> meaning scalar or list
contexts respectively, and C<.> meaning void context (which is
actually a sort of scalar context).  The display above says
that you were in the function C<main::infested> when you ran the
stack dump, and that it was called in scalar context from line
10 of the file I<Ambulation.pm>, but without any arguments at all,
meaning it was called as C<&infested>.  The next stack frame shows
that the function C<Ambulation::legs> was called in list context
from the I<camel_flea> file with four arguments.  The last stack
frame shows that C<main::pests> was called in scalar context,
also from I<camel_flea>, but from line 4.

If you execute the C<T> command from inside an active C<use>
statement, the backtrace will contain both a C<require> frame and
an C<eval>) frame.

=item Line Listing Format

This shows the sorts of output the C<l> command can produce:

    DB<<13>> l
  101:                @i{@i} = ();
  102:b               @isa{@i,$pack} = ()
  103                     if(exists $i{$prevpack} || exists $isa{$pack});
  104             }
  105
  106             next
  107==>              if(exists $isa{$pack});
  108
  109:a           if ($extra-- > 0) {
  110:                %isa = ($pack,1);

Breakable lines are marked with C<:>.  Lines with breakpoints are
marked by C<b> and those with actions by C<a>.  The line that's
about to be executed is marked by C<< ==> >>.

Please be aware that code in debugger listings may not look the same
as your original source code.  Line directives and external source
filters can alter the code before Perl sees it, causing code to move
from its original positions or take on entirely different forms.

=item Frame listing

When the C<frame> option is set, the debugger would print entered (and
optionally exited) subroutines in different styles.  See L<perldebguts>
for incredibly long examples of these.

=back

=head2 Debugging compile-time statements

(コンパイル時に実行される文のデバッグ)

=begin original

If you have compile-time executable statements (such as code within
BEGIN and CHECK blocks or C<use> statements), these will I<not> be
stopped by debugger, although C<require>s and INIT blocks will, and
compile-time statements can be traced with C<AutoTrace> option set
in C<PERLDB_OPTS>).  From your own Perl code, however, you can
transfer control back to the debugger using the following statement,
which is harmless if the debugger is not running:

=end original

コンパイル時に実行される文 (BEGIN と CHECK のブロック内のコードや
C<use> 文) があれば、それらはデバッガによってI<止めることができま
せん>。C<require> と INIT ブロックは可能です。
また、コンパイル時実行文は C<PERLDB_OPTS> で C<AutoTrace> オプションを
設定することでトレースできます。
しかし、以下のような文を自分で Perl コードに含めれば、
デバッガに制御を渡すことができます。
この文は、デバッガを起動していないときには、何もしません:

    $DB::single = 1;

=begin original

If you set C<$DB::single> to 2, it's equivalent to having
just typed the C<n> command, whereas a value of 1 means the C<s>
command.  The C<$DB::trace>  variable should be set to 1 to simulate
having typed the C<t> command.

=end original

C<$DB::single> に 2 をセットすると、C<n>コマンドをタイプしたのと
等価になります。
1 を設定すると C<s> コマンドとなります。
C<$DB::trace> 変数は C<t> コマンドをタイプした状態をシミュレートするために
1 にセットするべきです。

=begin original

Another way to debug compile-time code is to start the debugger, set a
breakpoint on the I<load> of some module:

=end original

コンパイル時に実行されるコードをデバッグするもう一つの方法は、
モジュールの I<load> にブレークポイントを設定して:

    DB<7> b load f:/perllib/lib/Carp.pm
  Will stop on load of `f:/perllib/lib/Carp.pm'.

=begin original

and then restart the debugger using the C<R> command (if possible).  One can use C<b
compile subname> for the same purpose.

=end original

(可能なら) C<R> コマンドを使ってデバッガを再起動することです。
C<b compile subname> も同じ目的に使えます。

=head2 Debugger Customization

(デバッガのカスタマイズ)

The debugger probably contains enough configuration hooks that you
won't ever have to modify it yourself.  You may change the behaviour
of debugger from within the debugger using its C<O> command, from
the command line via the C<PERLDB_OPTS> environment variable, and
from customization files.

=begin original

You can do some customization by setting up a F<.perldb> file, which
contains initialization code.  For instance, you could make aliases
like these (the last one is one people expect to be there):

=end original

初期化コードを入れたファイル .perldb を設定することでも、
いくらかのカスタマイズができます。
たとえば、以下のようなエイリアスが行えます (最後のものは、
人々があると思っているものです):

    $DB::alias{'len'}  = 's/^len(.*)/p length($1)/';
    $DB::alias{'stop'} = 's/^stop (at|in)/b/';
    $DB::alias{'ps'}   = 's/^ps\b/p scalar /';
    $DB::alias{'quit'} = 's/^quit(\s*)/exit/';

You can change options from F<.perldb> by using calls like this one;

    parse_options("NonStop=1 LineInfo=db.out AutoTrace=1 frame=2");

The code is executed in the package C<DB>.  Note that F<.perldb> is
processed before processing C<PERLDB_OPTS>.  If F<.perldb> defines the
subroutine C<afterinit>, that function is called after debugger
initialization ends.  F<.perldb> may be contained in the current
directory, or in the home directory.  Because this file is sourced
in by Perl and may contain arbitrary commands, for security reasons,
it must be owned by the superuser or the current user, and writable
by no one but its owner.

=begin original

If you want to modify the debugger, copy F<perl5db.pl> from the
Perl library to another name and hack it to your heart's content.
You'll then want to set your C<PERL5DB> environment variable to say
something like this:

=end original

デバッガを変更したい場合には、perl5db.pl を Perl ライブラリから
別の名前にコピーし、修正してください。それから
環境変数 C<PERL5DB> には、以下のように設定する必要があるでしょう:

    BEGIN { require "myperl5db.pl" }

=begin original

As a last resort, you could also use C<PERL5DB> to customize the debugger
by directly setting internal variables or calling debugger functions.

=end original

最後の手段として、 C<PERL5DB> を、直接内部変数を設定したり
デバッガ関数を呼び出すことでデバッガをカスタマイズすることもできます。

=begin original

Note that any variables and functions that are not documented in
this document (or in L<perldebguts>) are considered for internal
use only, and as such are subject to change without notice.

=end original

このドキュメント(や L<perldebguts>)に記述されていない変数や
関数は内部使用専用として扱われ、予告なく変更されることがあります。

=head2 Readline Support

(readline 対応)

As shipped, the only command-line history supplied is a simplistic one
that checks for leading exclamation points.  However, if you install
the Term::ReadKey and Term::ReadLine modules from CPAN, you will
have full editing capabilities much like GNU I<readline>(3) provides.
Look for these in the F<modules/by-module/Term> directory on CPAN.
These do not support normal B<vi> command-line editing, however.

A rudimentary command-line completion is also available.
Unfortunately, the names of lexical variables are not available for
completion.

=head2 Editor Support for Debugging

(デバッグのためのエディタ対応)

If you have the FSF's version of B<emacs> installed on your system,
it can interact with the Perl debugger to provide an integrated
software development environment reminiscent of its interactions
with C debuggers.

Perl comes with a start file for making B<emacs> act like a
syntax-directed editor that understands (some of) Perl's syntax.
Look in the I<emacs> directory of the Perl source distribution.

A similar setup by Tom Christiansen for interacting with any
vendor-shipped B<vi> and the X11 window system is also available.
This works similarly to the integrated multiwindow support that
B<emacs> provides, where the debugger drives the editor.  At the
time of this writing, however, that tool's eventual location in the
Perl distribution was uncertain.

Users of B<vi> should also look into B<vim> and B<gvim>, the mousey
and windy version, for coloring of Perl keywords.  

Note that only perl can truly parse Perl, so all such CASE tools
fall somewhat short of the mark, especially if you don't program
your Perl as a C programmer might.

=head2 The Perl Profiler

(Perl プロファイラ)

If you wish to supply an alternative debugger for Perl to run, just
invoke your script with a colon and a package argument given to the
B<-d> flag.  The most popular alternative debuggers for Perl is the
Perl profiler.  Devel::DProf is now included with the standard Perl
distribution.  To profile your Perl program in the file F<mycode.pl>,
just type:

    $ perl -d:DProf mycode.pl

When the script terminates the profiler will dump the profile
information to a file called F<tmon.out>.  A tool like B<dprofpp>,
also supplied with the standard Perl distribution, can be used to
interpret the information in that profile.

=head1 Debugging regular expressions

(正規表現のデバッグ)

=begin original

C<use re 'debug'> enables you to see the gory details of how the
Perl regular expression engine works.  In order to understand this
typically voluminous output, one must not only have some idea about
about how regular expression matching works in general, but also
know how Perl's regular expressions are internally compiled into
an automaton.  These matters are explored in some detail in
L<perldebguts/"Debugging regular expressions">.

=end original

C<use re 'debug'> を指定すると、Perl 正規表現エンジンがどのように
動作するかの詳細を見ることができます。
この、典型的には大量の出力を理解するためには、
一般的に正規表現マッチがどのように行われるかだけでなく、
Perl の正規表現が内部的にどのようにオートマトンにコンパイルされるかを
知らなければなりません。
これらの事柄は詳細は L<perldebguts/"Debugging regular expressions"> にあります。

=head1 Debugging memory usage

(メモリ使用のデバッグ)

=begin original

Perl contains internal support for reporting its own memory usage,
but this is a fairly advanced concept that requires some understanding
of how memory allocation works.
See L<perldebguts/"Debugging Perl memory usage"> for the details.

=end original

Perl には自身のメモリ使用状況を報告するための内部機能があります。
しかしこれはかなり上級の概念で、メモリ割り当てがどのように行われるかに
ついての理解が必要となります。
詳細については L<perldebguts/"Debugging Perl memory usage"> を参照して下さい。

=head1 SEE ALSO

=begin original

You did try the B<-w> switch, didn't you?

=end original

B<-w> スイッチはもう使いましたよね?

L<perldebguts>,
L<re>,
L<DB>,
L<Devel::Dprof>,
L<dprofpp>,
L<Dumpvalue>,
and
L<perlrun>.

=head1 BUGS

=begin original

You cannot get stack frame information or in any fashion debug functions
that were not compiled by Perl, such as those from C or C++ extensions.

=end original

C や C++ 拡張のような、Perl でコンパイルされていないものに対して
スタックフレーム情報やあらゆるデバッグ関数を使うことはできません。

=begin original

If you alter your @_ arguments in a subroutine (such as with C<shift>
or C<pop>, the stack backtrace will not show the original values.

=end original

サブルーチン内で(C<shift> や C<pop> を使って) @_ 引数を変更した場合、
スタックバックトレースで元の値を表示することはできません。

=begin original

The debugger does not currently work in conjunction with the B<-W>
command-line switch, because it itself is not free of warnings.

=end original

デバッガは現在のところ B<-W> コマンドラインスイッチと同時に
使うことはできません。これ自身が警告から逃れられないからです。

=begin original

If you're in a slow syscall (like C<wait>ing, C<accept>ing, or C<read>ing
from your keyboard or a socket) and haven't set up your own C<$SIG{INT}>
handler, then you won't be able to CTRL-C your way back to the debugger,
because the debugger's own C<$SIG{INT}> handler doesn't understand that
it needs to raise an exception to longjmp(3) out of slow syscalls.

=end original

(キーボードやソケットからの C<wait>, C<accept>, C<read>などの)
遅いシステムコールを実行中で、独自の C<$SIG{INT}> ハンドラを設定していない場合、
デバッガに戻ってくるために CTRL-C を使うことはできません。
これは、デバッガ自身の C<$SIG{INT}> ハンドラが
遅いシステムコールから longjmp(3) で出るための例外を発生させる必要性を
理解しないからです。
