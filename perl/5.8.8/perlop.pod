=head1 NAME
X<operator>

=begin original

perlop - Perl operators and precedence

=end original

Perl の演算子と優先順位

=head1 DESCRIPTION

=head2 Operator Precedence and Associativity 
X<operator, precedence> X<precedence> X<associativity>

=begin original

Operator precedence and associativity work in Perl more or less like
they do in mathematics.

=end original

Operator precedence and associativity work in Perl more or less like
they do in mathematics.
(TBT)

=begin original

I<Operator precedence> means some operators are evaluated before
others.  For example, in C<2 + 4 * 5>, the multiplication has higher
precedence so C<4 * 5> is evaluated first yielding C<2 + 20 ==
22> and not C<6 * 5 == 30>.

=end original

I<Operator precedence> means some operators are evaluated before
others.  For example, in C<2 + 4 * 5>, the multiplication has higher
precedence so C<4 * 5> is evaluated first yielding C<2 + 20 ==
22> and not C<6 * 5 == 30>.
(TBT)

=begin original

I<Operator associativity> defines what happens if a sequence of the
same operators is used one after another: whether the evaluator will
evaluate the left operations first or the right.  For example, in C<8
- 4 - 2>, subtraction is left associative so Perl evaluates the
expression left to right.  C<8 - 4> is evaluated first making the
expression C<4 - 2 == 2> and not C<8 - 2 == 6>.

=end original

I<Operator associativity> defines what happens if a sequence of the
same operators is used one after another: whether the evaluator will
evaluate the left operations first or the right.  For example, in C<8
- 4 - 2>, subtraction is left associative so Perl evaluates the
expression left to right.  C<8 - 4> is evaluated first making the
expression C<4 - 2 == 2> and not C<8 - 2 == 6>.
(TBT)

=begin original

Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.  Operators borrowed from
C keep the same precedence relationship with each other, even where
C's precedence is slightly screwy.  (This makes learning Perl easier
for C folks.)  With very few exceptions, these all operate on scalar
values only, not array values.

=end original

Perl の演算子には、以下のような結合性と優先順位 (高い優先順位から
低いものへ並べている) があります。
C から持ってきた演算子の優先順位は、C での優先順位が多少おかしくても、
そのままにしてあります。
(これによって、C を使っている方が Perl に移りやすくなっています。)
ごく僅かな例外を別として、全ての演算子はスカラ値のみを持ち、
配列値を持ちません。

=begin original

    left	terms and list operators (leftward)
    left	->
    nonassoc	++ --
    right	**
    right	! ~ \ and unary + and -
    left	=~ !~
    left	* / % x
    left	+ - .
    left	<< >>
    nonassoc	named unary operators
    nonassoc	< > <= >= lt gt le ge
    nonassoc	== != <=> eq ne cmp
    left	&
    left	| ^
    left	&&
    left	||
    nonassoc	..  ...
    right	?:
    right	= += -= *= etc.
    left	, =>
    nonassoc	list operators (rightward)
    right	not
    left	and
    left	or xor

=end original

    左結合      項  リスト演算子 (左方向に対して)
    左結合      ->
    非結合      ++ --
    右結合      **
    右結合      ! ~ \ 単項の+ 単項の-
    左結合      =~ !~
    左結合      * / % x
    左結合      + - .
    左結合      << >>
    非結合      名前付き単項演算子
    非結合      < > <= >= lt gt le ge
    非結合      == != <=> eq ne cmp
    左結合      &
    左結合      | ^
    左結合      &&
    左結合      ||
    非結合      .. ...
    右結合      ?:
    右結合      = += -= *= などの代入演算子
    左結合      , =>
    非結合      リスト演算子 (右方向に対して)
    右結合      not
    左結合      and
    左結合      or xor

=begin original

In the following sections, these operators are covered in precedence order.

=end original

以下の節では、これらの演算子を優先順位に従って紹介します。

=begin original

Many operators can be overloaded for objects.  See L<overload>.

=end original

多くの演算子はオブジェクトでオーバーロードできます。
L<overload> を参照して下さい。

=head2 Terms and List Operators (Leftward)
X<list operator> X<operator, list> X<term>

=begin original

A TERM has the highest precedence in Perl.  They include variables,
quote and quote-like operators, any expression in parentheses,
and any function whose arguments are parenthesized.  Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.  These are all documented in L<perlfunc>.

=end original

「項」は Perl でもっとも優先順位が高いものです。
これには、変数、クォートとクォート的な演算子、括弧で括った任意の式、
引数を括弧で括った任意の関数が含まれます。
実際には、この意味では本当の関数はなく、リスト演算子と関数のように働く
単項演算子が、引数を括弧で括るためそのように見えます。
これらはすべて L<perlfunc> に記述しています。

=begin original

If any list operator (print(), etc.) or any unary operator (chdir(), etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.

=end original

もし、リスト演算子 (print() など) や単項演算子 (chdir() など)の
名前の後に開き括弧が続く場合には、その演算子と括弧内の引数は、
通常の関数呼び出しのように、もっとも高い優先順位で処理されます。

=begin original

In the absence of parentheses, the precedence of list operators such as
C<print>, C<sort>, or C<chmod> is either very high or very low depending on
whether you are looking at the left side or the right side of the operator.
For example, in

=end original

括弧が無い場合には、C<print>、C<sort>、C<chmod> のようなリスト演算子の
優先順位は、演算子の左側をからすると非常に高く、右側からすると
非常に低く見えます。たとえば、

    @ary = (1, 3, sort 4, 2);
    print @ary;		# prints 1324

=begin original

the commas on the right of the sort are evaluated before the sort,
but the commas on the left are evaluated after.  In other words,
list operators tend to gobble up all arguments that follow, and
then act like a simple TERM with regard to the preceding expression.
Be careful with parentheses:

=end original

では、sort の右のコンマは sort よりも前に評価されます (右側から
見ると sort の優先順位が低い) が、左側のコンマは sort のあとに
評価されます (左側から見ると sort の方が優先順位が高く
なっている)。
言い方を変えると、リスト演算子は自分の後にある引数をすべて使って処理を行ない、
その結果を自分の前の式に対する「項」であるかのように見せるということです。
ただし、括弧には気を付けないといけません:

=begin original

    # These evaluate exit before doing the print:
    print($foo, exit);	# Obviously not what you want.
    print $foo, exit;	# Nor is this.

=end original

    # 以下は print を行なう前に exit を評価します:
    print($foo, exit);  # 明らかにやりたいことではないでしょう。
    print $foo, exit;   # これでもない。

=begin original

    # These do the print before evaluating exit:
    (print $foo), exit;	# This is what you want.
    print($foo), exit;	# Or this.
    print ($foo), exit;	# Or even this.

=end original

    # 以下は exit を評価する前に print を行ないます:
    (print $foo), exit; # これがしたかった。
    print($foo), exit;  # これでもいい。
    print ($foo), exit; # これも OK。

=begin original

Also note that

=end original

また、

    print ($foo & 255) + 1, "\n";

=begin original

probably doesn't do what you expect at first glance.  The parentheses
enclose the argument list for C<print> which is evaluated (printing
the result of C<$foo & 255>).  Then one is added to the return value
of C<print> (usually 1).  The result is something like this:

=end original

の動作を一目見ただけで判断するのは、難しいでしょう。
The parentheses
enclose the argument list for C<print> which is evaluated (printing
the result of C<$foo & 255>).  Then one is added to the return value
of C<print> (usually 1).  The result is something like this:
(TBT)

    1 + 1, "\n";    # Obviously not what you meant.

=begin original

To do what you meant properly, you must write:

=end original

意味したいことを適切に行うには、以下のように書く必要があります:

    print(($foo & 255) + 1, "\n");

=begin original

See L<Named Unary Operators> for more discussion of this.

=end original

詳しくは、L<Named Unary Operators> を参照してください。

=begin original

Also parsed as terms are the C<do {}> and C<eval {}> constructs, as
well as subroutine and method calls, and the anonymous
constructors C<[]> and C<{}>.

=end original

この他に「項」として解析されるものには、C<do {}> や C<eval {}> の
構成、サブルーティンやメソッドの呼び出し、無名のコンストラクタ
C<[]> と C<{}> があります。

=begin original

See also L<Quote and Quote-like Operators> toward the end of this section,
as well as L<"I/O Operators">.

=end original

後の方のL<Quote and Quote-like Operators>や
L<"I/O Operators">も参照してください。

=head2 The Arrow Operator
X<arrow> X<dereference> X<< -> >>

=begin original

"C<< -> >>" is an infix dereference operator, just as it is in C
and C++.  If the right side is either a C<[...]>, C<{...}>, or a
C<(...)> subscript, then the left side must be either a hard or
symbolic reference to an array, a hash, or a subroutine respectively.
(Or technically speaking, a location capable of holding a hard
reference, if it's an array or hash reference being used for
assignment.)  See L<perlreftut> and L<perlref>.

=end original

C や C++ と同じように "C<< -> >>" は中置の被参照演算子です。
右側が C<[...]>, C<{...}>,
C<(...)> のいずれかの形の添字であれば、左側は配列、ハッシュ、
サブルーチンへのハードリファレンスかシンボリックリファレンス (あるいは
技術的には、配列またはハードリファレンスが代入可能であれば
ハードリファレンスを保持できる場所)
でなければなりません。L<perlreftut> と L<perlref> を参照してください。

=begin original

Otherwise, the right side is a method name or a simple scalar
variable containing either the method name or a subroutine reference,
and the left side must be either an object (a blessed reference)
or a class name (that is, a package name).  See L<perlobj>.

=end original

そうでなければ、右側はメソッド名かサブルーチンのリファレンスを持った
単純スカラ変数で、左側はオブジェクト (bless されたリファレンス) か
クラス名でなければなりません。
L<perlobj> を参照してください。

=head2 Auto-increment and Auto-decrement
X<increment> X<auto-increment> X<++> X<decrement> X<auto-decrement> X<-->

(インクリメントとデクリメント)

=begin original

"++" and "--" work as in C.  That is, if placed before a variable,
they increment or decrement the variable by one before returning the
value, and if placed after, increment or decrement after returning the
value.

=end original

"++" と "--" は、C の場合と同じように動作します。
つまり、変数の前に置かれれば、値を返す前に変数を 1 インクリメントまたは
デクリメントし、後に置かれれば、値を返した後で変数を
インクリメントまたはデクリメントします。

    $i = 0;  $j = 0;
    print $i++;  # prints 0
    print ++$j;  # prints 1

=begin original

Note that just as in C, Perl doesn't define B<when> the variable is
incremented or decremented. You just know it will be done sometime 
before or after the value is returned. This also means that modifying
a variable twice in the same statement will lead to undefined behaviour.
Avoid statements like:

=end original

Note that just as in C, Perl doesn't define B<when> the variable is
incremented or decremented. You just know it will be done sometime 
before or after the value is returned. This also means that modifying
a variable twice in the same statement will lead to undefined behaviour.
Avoid statements like:
(TBT)

    $i = $i ++;
    print ++ $i + $i ++;

=begin original

Perl will not guarantee what the result of the above statements is.

=end original

Perl will not guarantee what the result of the above statements is.
(TBT)

=begin original

The auto-increment operator has a little extra builtin magic to it.  If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has been used in only string contexts since it was set, and
has a value that is not the empty string and matches the pattern
C</^[a-zA-Z]*[0-9]*\z/>, the increment is done as a string, preserving each
character within its range, with carry:

=end original

インクリメント演算子には、ちょっと風変わりな機能が組み込まれています。
数値が入った変数や、数値の文脈で使われてきた変数を
インクリメントする場合には、通常のインクリメントとして動作します。
しかし、その変数が設定されてからずっと文字列の文脈で
しか使われていなくて、空文字列でなく、 C</^[a-zA-Z]*[0-9]*\z/> にマッチする
値を持っているときには、個々の文字の範囲を保ちながら桁あげを行なって、
文字列としてインクリメントが行なわれます (マジカルインクリメントと呼ばれます):

    print ++($foo = '99');	# prints '100'
    print ++($foo = 'a0');	# prints 'a1'
    print ++($foo = 'Az');	# prints 'Ba'
    print ++($foo = 'zz');	# prints 'aaa'

=begin original

C<undef> is always treated as numeric, and in particular is changed
to C<0> before incrementing (so that a post-increment of an undef value
will return C<0> rather than C<undef>).

=end original

C<undef> is always treated as numeric, and in particular is changed
to C<0> before incrementing (so that a post-increment of an undef value
will return C<0> rather than C<undef>).
(TBT)

=begin original

The auto-decrement operator is not magical.

=end original

デクリメント演算子には、マジカルなものはありません。

=head2 Exponentiation
X<**> X<exponentiation> X<power>

(指数演算子)

=begin original

Binary "**" is the exponentiation operator.  It binds even more
tightly than unary minus, so -2**4 is -(2**4), not (-2)**4. (This is
implemented using C's pow(3) function, which actually works on doubles
internally.)

=end original

二項演算子の "**" は指数演算子です。
この演算子は、単項のマイナスよりも結合が強い演算子で、
-2**4 は (-2)**4 ではなく、-(2**4) と解釈されます。
(これは C の pow(3) を使って実装されていますので、
内部的には double で動作します。)

=head2 Symbolic Unary Operators
X<unary operator> X<operator, unary>

(単項演算子)

=begin original

Unary "!" performs logical negation, i.e., "not".  See also C<not> for a lower
precedence version of this.
X<!>

=end original

単項演算子の "!" は論理否定を行ないます。
つまり 「not」 ということです。
この演算子の優先順位を低くしたものとして、C<not> が用意されています。
X<!>

=begin original

Unary "-" performs arithmetic negation if the operand is numeric.  If
the operand is an identifier, a string consisting of a minus sign
concatenated with the identifier is returned.  Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign
is returned.  One effect of these rules is that -bareword is equivalent
to the string "-bareword".  If, however, the string begins with a
non-alphabetic character (exluding "+" or "-"), Perl will attempt to convert
the string to a numeric and the arithmetic negation is performed. If the
string cannot be cleanly converted to a numeric, Perl will give the warning
B<Argument "the string" isn't numeric in negation (-) at ...>.
X<-> X<negation, arithmetic>

=end original

単項演算子の "-" は被演算子が数値であれば、算術否定を行ないます。
被演算子が識別子ならば、マイナス記号にその識別子をつなげた
文字列が返されます。
これ以外で被演算子の最初の文字がプラスかマイナスのときには、
その記号を逆のものに置き換えた文字列を返します。
この規則の結果、-bareword が文字列 "-bareword" に等価となります。
If, however, the string begins with a
non-alphabetic character (exluding "+" or "-"), Perl will attempt to convert
the string to a numeric and the arithmetic negation is performed. If the
string cannot be cleanly converted to a numeric, Perl will give the warning
B<Argument "the string" isn't numeric in negation (-) at ...>.
X<-> X<negation, arithmetic>

=begin original

Unary "~" performs bitwise negation, i.e., 1's complement.  For
example, C<0666 & ~027> is 0640.  (See also L<Integer Arithmetic> and
L<Bitwise String Operators>.)  Note that the width of the result is
platform-dependent: ~0 is 32 bits wide on a 32-bit platform, but 64
bits wide on a 64-bit platform, so if you are expecting a certain bit
width, remember to use the & operator to mask off the excess bits.
X<~> X<negation, binary>

=end original

単項演算子の "~" はビットごとの否定を行ないます。
つまり、1 の補数を返します。
例えば、C<0666 & ~027> は 0640 です。
(L<Integer Arithmetic> と L<Bitwise String Operators> も参照して下さい。)
結果の幅はプラットホーム依存であることに注意してください。
~0 は 32-bit プラットホームでは 32 ビット幅ですが、
64-bit プラットホームでは 64 ビット幅ですので、
特定のビット幅を仮定する場合は、
余分なビットをマスクするために & 演算子を使うことを忘れないでください。
X<~> X<negation, binary>

=begin original

Unary "+" has no effect whatsoever, even on strings.  It is useful
syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.  (See examples above under L<Terms and List Operators (Leftward)>.)
X<+>

=end original

単項演算子の "+" は、たとえ文字列に対して用いられた場合にも、何もしません。
関数名に続けて括弧付きの式を書く場合に、関数の引数リストと
解釈されないようにするために用いることができます。
(下記 L<Terms and List Operators (Leftward)> の例を参照してください。)
X<+>

=begin original

Unary "\" creates a reference to whatever follows it.  See L<perlreftut>
and L<perlref>.  Do not confuse this behavior with the behavior of
backslash within a string, although both forms do convey the notion
of protecting the next thing from interpolation.
X<\> X<reference> X<backslash>

=end original

単項演算子の "\" はその後に続くものへのリファレンスを生成します。
L<perlreftut> と L<perlref> を参照してください。
この用法も文字列中のバックスラッシュも、後に続くものが展開されるのを
防ぐことになりますが、動作を混同しないでください。
X<\> X<reference> X<backslash>

=head2 Binding Operators
X<binding> X<operator, binding> X<=~> X<!~>

=begin original

Binary "=~" binds a scalar expression to a pattern match.  Certain operations
search or modify the string $_ by default.  This operator makes that kind
of operation work on some other string.  The right argument is a search
pattern, substitution, or transliteration.  The left argument is what is
supposed to be searched, substituted, or transliterated instead of the default
$_.  When used in scalar context, the return value generally indicates the
success of the operation.  Behavior in list context depends on the particular
operator.  See L</"Regexp Quote-Like Operators"> for details and 
L<perlretut> for examples using these operators.

=end original

二項演算子の "=~" は、スカラ式をパターンマッチに拘束します。
デフォルトで $_ の文字列を検索したり、変更したりする演算があります。
この演算子は、そのような演算を他の文字列に対して行なわせるようにするものです。
右引数は、検索パターン、置換、文字変換のいずれかです。
左引数は、デフォルトの $_ の代わりに検索、置換、文字変換の対象となるものです。
スカラコンテキストで使うと、返り値は一般的に演算の結果が成功したか否かです。
リストコンテキストでの振る舞いは演算子に依存します。
詳しくは L</"Regexp Quote-Like Operators"> を、これらの演算子を使った
例については L<perlretut> を参照して下さい。

=begin original

If the right argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at run
time.

=end original

右引数が検索パターン、置換、文字変換ではなく、式であれば、
それは実行時に決まる検索パターンと解釈されます。

=begin original

Binary "!~" is just like "=~" except the return value is negated in
the logical sense.

=end original

二項演算子の "!~" は、返される値が論理否定されることを除いて
"=~" と同じです。

=head2 Multiplicative Operators
X<operator, multiplicative>

=begin original

Binary "*" multiplies two numbers.
X<*>

=end original

二項演算子の "*" は 2 つの数値の積を返します。
X<*>

=begin original

Binary "/" divides two numbers.
X</> X<slash>

=end original

二項演算子の "/" は 2 つの数値の商を返します。
X</> X<slash>

=begin original

Binary "%" computes the modulus of two numbers.  Given integer
operands C<$a> and C<$b>: If C<$b> is positive, then C<$a % $b> is
C<$a> minus the largest multiple of C<$b> that is not greater than
C<$a>.  If C<$b> is negative, then C<$a % $b> is C<$a> minus the
smallest multiple of C<$b> that is not less than C<$a> (i.e. the
result will be less than or equal to zero). 
Note that when C<use integer> is in scope, "%" gives you direct access
to the modulus operator as implemented by your C compiler.  This
operator is not as well defined for negative operands, but it will
execute faster.
X<%> X<remainder> X<modulus> X<mod>

=end original

二項演算子の "%" は 2 つの数値の剰余を返します。
C<$a> と C<$b> の二つの整数の被演算子を取ります。
C<$b> が正の場合、C<$a % $b> は、C<$a> から C<$a> を超えない
最大の C<$b> の倍数を引いた値です。
C<$b> が負の場合、C<$a % $b> は、C<$a> から C<$a> を下回らない
最小の C<$b> の倍数を引いた値です。(従って結果はゼロ以下になります。)
C<use integer> がスコープ内にある場合、
"%" は C コンパイラで実装された剰余演算子を使います。
この演算子は被演算子が負の場合の挙動が不確実ですが、
より高速です。
X<%> X<remainder> X<modulus> X<mod>

=begin original

Binary "x" is the repetition operator.  In scalar context or if the left
operand is not enclosed in parentheses, it returns a string consisting
of the left operand repeated the number of times specified by the right
operand.  In list context, if the left operand is enclosed in
parentheses or is a list formed by C<qw/STRING/>, it repeats the list.
If the right operand is zero or negative, it returns an empty string
or an empty list, depending on the context.
X<x>

=end original

二項演算子の "x" は繰り返し演算子です。
スカラコンテキストまたは左辺値が括弧で括られていない場合は、
左被演算子を右被演算子に示す数だけ繰り返したもので構成される
文字列を返します。
リストコンテキストでは、左被演算子が括弧で括られているか、C<qw/STRING> の
形のリストの場合、リストを繰り返します。
If the right operand is zero or negative, it returns an empty string
or an empty list, depending on the context.
X<x>

    print '-' x 80;		# print row of dashes

    print "\t" x ($tab/8), ' ' x ($tab%8);	# tab over

    @ones = (1) x 80;		# a list of 80 1's
    @ones = (5) x @ones;	# set all elements to 5


=head2 Additive Operators
X<operator, additive>

=begin original

Binary "+" returns the sum of two numbers.
X<+>

=end original

二項演算子の "+" は 2 つの数値の和を返します。
X<+>

=begin original

Binary "-" returns the difference of two numbers.
X<->

=end original

二項演算子の "-" は 2 つの数値の差を返します。
X<->

=begin original

Binary "." concatenates two strings.
X<string, concatenation> X<concatenation>
X<cat> X<concat> X<concatenate> X<.>

=end original

二項演算子の "." は 2 つの文字列を連結します。
X<string, concatenation> X<concatenation>
X<cat> X<concat> X<concatenate> X<.>

=head2 Shift Operators
X<shift operator> X<operator, shift> X<<< << >>>
X<<< >> >>> X<right shift> X<left shift> X<bitwise shift>
X<shl> X<shr> X<shift, right> X<shift, left>

(シフト演算子)

=begin original

Binary "<<" returns the value of its left argument shifted left by the
number of bits specified by the right argument.  Arguments should be
integers.  (See also L<Integer Arithmetic>.)

=end original

二項演算子の "<<" は左引数の値を、右引数で示すビット数だけ、
左にシフトした値を返します。
引数は整数でなければなりません。
(L<Integer Arithmetic> も参照して下さい。)

=begin original

Binary ">>" returns the value of its left argument shifted right by
the number of bits specified by the right argument.  Arguments should
be integers.  (See also L<Integer Arithmetic>.)

=end original

二項演算子の ">>" は左引数の値を、右引数で示すビット数だけ、
右にシフトした値を返します。
引数は整数でなければなりません。
(L<Integer Arithmetic> も参照して下さい。)

=begin original

Note that both "<<" and ">>" in Perl are implemented directly using
"<<" and ">>" in C.  If C<use integer> (see L<Integer Arithmetic>) is
in force then signed C integers are used, else unsigned C integers are
used.  Either way, the implementation isn't going to generate results
larger than the size of the integer type Perl was built with (32 bits
or 64 bits).

=end original

Note that both "<<" and ">>" in Perl are implemented directly using
"<<" and ">>" in C.  If C<use integer> (see L<Integer Arithmetic>) is
in force then signed C integers are used, else unsigned C integers are
used.  Either way, the implementation isn't going to generate results
larger than the size of the integer type Perl was built with (32 bits
or 64 bits).
(TBT)

=begin original

The result of overflowing the range of the integers is undefined
because it is undefined also in C.  In other words, using 32-bit
integers, C<< 1 << 32 >> is undefined.  Shifting by a negative number
of bits is also undefined.

=end original

The result of overflowing the range of the integers is undefined
because it is undefined also in C.  In other words, using 32-bit
integers, C<< 1 << 32 >> is undefined.  Shifting by a negative number
of bits is also undefined.
(TBT)

=head2 Named Unary Operators
X<operator, named unary>

(名前付き単項演算子)

=begin original

The various named unary operators are treated as functions with one
argument, with optional parentheses.

=end original

さまざまな名前付き単項演算子が、引数を 1 つ持ち、括弧が省略可能な、
関数として扱われます。

=begin original

If any list operator (print(), etc.) or any unary operator (chdir(), etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.  For example,
because named unary operators are higher precedence than ||:

=end original

リスト演算子 (print() など) や単項演算子 (chdir() など) は、
すべて次のトークンとして開き括弧が続くと、その演算子と括弧内の引数は、
通常の関数呼び出しのようにもっとも高い優先順位として扱われます。
たとえば、名前つき単項演算子は || より優先順位が高いので、
以下のようになります:

    chdir $foo    || die;	# (chdir $foo) || die
    chdir($foo)   || die;	# (chdir $foo) || die
    chdir ($foo)  || die;	# (chdir $foo) || die
    chdir +($foo) || die;	# (chdir $foo) || die

=begin original

but, because * is higher precedence than named operators:

=end original

しかし * は名前つき演算子より優先順位が高いので、以下のようになります:

    chdir $foo * 20;	# chdir ($foo * 20)
    chdir($foo) * 20;	# (chdir $foo) * 20
    chdir ($foo) * 20;	# (chdir $foo) * 20
    chdir +($foo) * 20;	# chdir ($foo * 20)

    rand 10 * 20;	# rand (10 * 20)
    rand(10) * 20;	# (rand 10) * 20
    rand (10) * 20;	# (rand 10) * 20
    rand +(10) * 20;	# rand (10 * 20)

=begin original

Regarding precedence, the filetest operators, like C<-f>, C<-M>, etc. are
treated like named unary operators, but they don't follow this functional
parenthesis rule.  That means, for example, that C<-f($file).".bak"> is
equivalent to C<-f "$file.bak">.
X<-X> X<filetest> X<operator, filetest>

=end original

これには C<-f> や C<-M> のようなファイルテスト演算子も含まれます。
L<perlfunc> を参照してください。
(TBT)

=begin original

See also L<"Terms and List Operators (Leftward)">.

=end original

L<"Terms and List Operators (Leftward)"> も参照して下さい。

=head2 Relational Operators
X<relational operator> X<operator, relational>

=begin original

Binary "<" returns true if the left argument is numerically less than
the right argument.
X<< < >>

=end original

二項演算子の "<" は左引数が数値的に右引数よりも小さければ、
真を返します。

=begin original

Binary ">" returns true if the left argument is numerically greater
than the right argument.
X<< > >>

=end original

二項演算子の ">" は左引数が数値的に右引数よりも大きければ、
真を返します。

=begin original

Binary "<=" returns true if the left argument is numerically less than
or equal to the right argument.
X<< <= >>

=end original

二項演算子の "<=" は左引数が数値的に右引数よりも小さいか等しければ、
真を返します。

=begin original

Binary ">=" returns true if the left argument is numerically greater
than or equal to the right argument.
X<< >= >>

=end original

二項演算子の ">=" は左引数が数値的に右引数よりも大きいか等しければ、
真を返します。

=begin original

Binary "lt" returns true if the left argument is stringwise less than
the right argument.
X<< lt >>

=end original

二項演算子の "lt" は左引数が文字列的に右引数よりも小さければ、
真を返します。

=begin original

Binary "gt" returns true if the left argument is stringwise greater
than the right argument.
X<< gt >>

=end original

二項演算子の "gt" は左引数が文字列的に右引数よりも大きければ、
真を返します。

=begin original

Binary "le" returns true if the left argument is stringwise less than
or equal to the right argument.
X<< le >>

=end original

二項演算子の "le" は左引数が文字列的に右引数よりも小さいか等しければ、
真を返します。

=begin original

Binary "ge" returns true if the left argument is stringwise greater
than or equal to the right argument.
X<< ge >>

=end original

二項演算子の "ge" は左引数が文字列的に右引数よりも大きいか等しければ、
真を返します。

=head2 Equality Operators
X<equality> X<equal> X<equals> X<operator, equality>

=begin original

Binary "==" returns true if the left argument is numerically equal to
the right argument.
X<==>

=end original

二項演算子の "==" は左引数が数値的に右引数と等しければ、
真を返します。

=begin original

Binary "!=" returns true if the left argument is numerically not equal
to the right argument.
X<!=>

=end original

二項演算子の "!=" は左引数が数値的に右引数と等しくなければ、
真を返します。

=begin original

Binary "<=>" returns -1, 0, or 1 depending on whether the left
argument is numerically less than, equal to, or greater than the right
argument.  If your platform supports NaNs (not-a-numbers) as numeric
values, using them with "<=>" returns undef.  NaN is not "<", "==", ">",
"<=" or ">=" anything (even NaN), so those 5 return false. NaN != NaN
returns true, as does NaN != anything else. If your platform doesn't
support NaNs then NaN is just a string with numeric value 0.
X<< <=> >> X<spaceship>

=end original

二項演算子の "<=>" は左引数が数値的に右引数より小さいか、等しいか、
大きいかに従って、-1, 0, 1 を返します。
数値として NaN (非数) に対応しているプラットフォームでは、
NaN に対して "<=>" を使うと undef を返します。
NaN はどの値に対しても(NaN に対してでさえも) "<", "==", ">",
"<=", ">=" のいずれも成立しないので、これらは全て偽となります。
NaN != NaN は真を返しますが、その他のどの値に対しても != は偽を返します。
NaN に対応していないプラットフォームでは、NaN は
単に数としての値 0 を持つ文字列です。

    perl -le '$a = "NaN"; print "No NaN support here" if $a == $a'
    perl -le '$a = "NaN"; print "NaN support here" if $a != $a'

=begin original

Binary "eq" returns true if the left argument is stringwise equal to
the right argument.
X<eq>

=end original

二項演算子の "eq" は左引数が文字列的に右引数と等しければ、
真を返します。

=begin original

Binary "ne" returns true if the left argument is stringwise not equal
to the right argument.
X<ne>

=end original

二項演算子の "ne" は左引数が文字列的に右引数と等しくなければ、
真を返します。

=begin original

Binary "cmp" returns -1, 0, or 1 depending on whether the left
argument is stringwise less than, equal to, or greater than the right
argument.
X<cmp>

=end original

二項演算子の "cmp" は左引数が文字列的に右引数より小さいか、
等しいか、大きいかに従って、-1, 0, 1 を返します。

=begin original

"lt", "le", "ge", "gt" and "cmp" use the collation (sort) order specified
by the current locale if C<use locale> is in effect.  See L<perllocale>.

=end original

"lt", "le", "ge", "gt", "cmp" は C<use locale> が有効な場合は
現在のロケールで指定された辞書(ソート)順が使われます。
L<perllocale> を参照して下さい。

=head2 Bitwise And
X<operator, bitwise, and> X<bitwise and> X<&>

=begin original

Binary "&" returns its operands ANDed together bit by bit.
(See also L<Integer Arithmetic> and L<Bitwise String Operators>.)

=end original

二項演算子の "&" は、両オペランドのビットごとに論理積をとって、
その結果を返します。
(L<Integer Arithmetic> と L<Bitwise String Operators> も参照して下さい。)

=begin original

Note that "&" has lower priority than relational operators, so for example
the brackets are essential in a test like

=end original

Note that "&" has lower priority than relational operators, so for example
the brackets are essential in a test like
(TBT)

	print "Even\n" if ($x & 1) == 0;

=head2 Bitwise Or and Exclusive Or
X<operator, bitwise, or> X<bitwise or> X<|> X<operator, bitwise, xor>
X<bitwise xor> X<^>

=begin original

Binary "|" returns its operands ORed together bit by bit.
(See also L<Integer Arithmetic> and L<Bitwise String Operators>.)

=end original

二項演算子の "|" は、両オペランドのビットごとに論理和をとって、
その結果を返します。
(L<Integer Arithmetic> と L<Bitwise String Operators> も参照して下さい。)

=begin original

Binary "^" returns its operands XORed together bit by bit.
(See also L<Integer Arithmetic> and L<Bitwise String Operators>.)

=end original

二項演算子の "^" は、両オペランドのビットごとに排他論理和をとって、
その結果を返します。
(L<Integer Arithmetic> と L<Bitwise String Operators> も参照して下さい。)

=begin original

Note that "|" and "^" have lower priority than relational operators, so
for example the brackets are essential in a test like

=end original

Note that "|" and "^" have lower priority than relational operators, so
for example the brackets are essential in a test like
(TBT)

	print "false\n" if (8 | 2) != 10;

=head2 C-style Logical And
X<&&> X<logical and> X<operator, logical, and>

=begin original

Binary "&&" performs a short-circuit logical AND operation.  That is,
if the left operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

=end original

二項演算子の "&&" は、短絡の論理積演算を行ないます。
つまり、左被演算子が偽であれば、右被演算子は評価さえ
行なわれないということです。
評価される場合には、スカラーかリストかというコンテキストは、
右被演算子にも及びます。

=head2 C-style Logical Or
X<||> X<operator, logical, or>

=begin original

Binary "||" performs a short-circuit logical OR operation.  That is,
if the left operand is true, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

=end original

二項演算子の "||" は、短絡の論理和演算を行ないます。
つまり、左被演算子が真であれば、右被演算子は評価さえ
行なわれないということです。
評価される場合には、スカラーかリストかというコンテキストは、
右被演算子にも及びます。

=begin original

The C<||> and C<&&> operators return the last value evaluated
(unlike C's C<||> and C<&&>, which return 0 or 1). Thus, a reasonably
portable way to find out the home directory might be:

=end original

|| 演算子と && 演算子は、(C のように 単に 0 や 1 を返すのではなく)最後に
評価された値を返します。
これにより、かなり一般的に使えるホームディレクトリを探す方法は:

    $home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
	(getpwuid($<))[7] || die "You're homeless!\n";

=begin original

In particular, this means that you shouldn't use this
for selecting between two aggregates for assignment:

=end original

特に、これは代入のために二つの集合を選択するためには
使うべきではないことを意味します。

    @a = @b || @c;		# this is wrong
    @a = scalar(@b) || @c;	# really meant this
    @a = @b ? @b : @c;		# this works fine, though

=begin original

As more readable alternatives to C<&&> and C<||> when used for
control flow, Perl provides C<and> and C<or> operators (see below).
The short-circuit behavior is identical.  The precedence of "and" and
"or" is much lower, however, so that you can safely use them after a
list operator without the need for parentheses:

=end original

Perl では、フロー制御に使う場合の多少読みやすい C<&&> と C<||> の同義語として、
C<and> 演算子と C<or> 演算子が用意されています (下記参照)。
短絡の動作は全く同じです。
しかし、"and" と "or" の優先順位はかなり低くしてあるので、
引数に括弧を使っていないリスト演算子のあとに続けて使う場合にも、
安心して使うことができます:

    unlink "alpha", "beta", "gamma"
	    or gripe(), next LINE;

=begin original

With the C-style operators that would have been written like this:

=end original

C スタイルの演算子では以下のように書く必要があります。

    unlink("alpha", "beta", "gamma")
	    || (gripe(), next LINE);

=begin original

Using "or" for assignment is unlikely to do what you want; see below.

=end original

代入で "or" を使うと、したいことと違うことになります。
以下を参照して下さい。

=head2 Range Operators
X<operator, range> X<range> X<..> X<...>

(範囲演算子)

=begin original

Binary ".." is the range operator, which is really two different
operators depending on the context.  In list context, it returns a
list of values counting (up by ones) from the left value to the right
value.  If the left value is greater than the right value then it
returns the empty list.  The range operator is useful for writing
C<foreach (1..10)> loops and for doing slice operations on arrays. In
the current implementation, no temporary array is created when the
range operator is used as the expression in C<foreach> loops, but older
versions of Perl might burn a lot of memory when you write something
like this:

=end original

二項演算子の ".." は範囲演算子で、使われるコンテキストによって
異なる動作をする 2 つの演算子を合わせたものです。
リストコンテキストでは、左の値から右の値まで (1 づつ昇順で) 数えあげた値から
なるリストを返します。
左側の値が右側の値より大きい場合は、空リストを返します。
範囲演算子は、C<foreach (1..10)> のようなループを書くときや、
配列のスライス演算を行なうときに便利です。
現状の実装では、C<foreach> ループの式の中で範囲演算子を使っても
一時配列は作りませんが、古い Perl は以下のようなことを書くと、
大量のメモリを消費することになります:

    for (1 .. 1_000_000) {
	# code
    }

=begin original

The range operator also works on strings, using the magical auto-increment,
see below.

=end original

The range operator also works on strings, using the magical auto-increment,
see below.
(TBT)

=begin original

In scalar context, ".." returns a boolean value.  The operator is
bistable, like a flip-flop, and emulates the line-range (comma) operator
of B<sed>, B<awk>, and various editors.  Each ".." operator maintains its
own boolean state.  It is false as long as its left operand is false.
Once the left operand is true, the range operator stays true until the
right operand is true, I<AFTER> which the range operator becomes false
again.  It doesn't become false till the next time the range operator is
evaluated.  It can test the right operand and become false on the same
evaluation it became true (as in B<awk>), but it still returns true once.
If you don't want it to test the right operand till the next
evaluation, as in B<sed>, just use three dots ("...") instead of
two.  In all other regards, "..." behaves just like ".." does.

=end original

スカラコンテキストで使われたときには、".." は真偽値を返します。
この演算子は、フリップフロップのように 2 値安定で、
B<sed> や B<awk> や多くのエディタでの行範囲 (コンマ) 演算子を
エミュレートするものとなります。
各々の ".." 演算子がそれぞれに独立して自分の真偽状態を管理します。
はじめは、左被演算子が偽である間、演算全体も偽となっています。
範囲演算子は、いったん左被演算子が真になると、右被演算子が真である間、
真を返すようになります。
右被演算子が偽になると、演算子も偽を返すようになります。
(次に範囲演算子が評価されるまでは、偽とはなりません。
(B<awk> でのように) 真となった、その評価の中で右被演算子をテストし、
偽とすることができますが、1 度は真を返すことになります。
B<sed> でのように、次に評価されるまで右被演算子をテストしたくなければ、
2 個のドットの代わりに 3 つのドット ("...") を使ってください。
その他の点では、"..." は ".." と同様に振舞います．

=begin original

The right operand is not evaluated while the operator is in the
"false" state, and the left operand is not evaluated while the
operator is in the "true" state.  The precedence is a little lower
than || and &&.  The value returned is either the empty string for
false, or a sequence number (beginning with 1) for true.  The
sequence number is reset for each range encountered.  The final
sequence number in a range has the string "E0" appended to it, which
doesn't affect its numeric value, but gives you something to search
for if you want to exclude the endpoint.  You can exclude the
beginning point by waiting for the sequence number to be greater
than 1.

=end original

右被演算子は、演算子の状態が「偽」である間は評価されることがなく、
左被演算子は、演算子の状態が「真」である間は評価されることがありません。
優先順位は、|| と && の少し下です。
偽としては空文字列が返され、
真としては (1 から始まる) 順に並んだ数値が返されます。
この通し番号は、新たに範囲が始まるごとにリセットされます。
範囲の最後の数字には、文字列 "E0" がお尻につけられます。
これは、数値としては何の影響もありませんが、範囲の終わりで何か特別なことを
したい場合に、目印として使うことができます。
範囲の始まりで何かしたい場合には、通し番号が 1 よりも大きくなるのを
待っていればよいでしょう。

=begin original

If either operand of scalar ".." is a constant expression,
that operand is considered true if it is equal (C<==>) to the current
input line number (the C<$.> variable).

=end original

スカラの ".." の被演算子が定数表現であるときは、その被演算子は暗黙に、
現在の入力行番号(変数 C<$.>) と等しい(C<==>) 場合に真となります。

=begin original

To be pedantic, the comparison is actually C<int(EXPR) == int(EXPR)>,
but that is only an issue if you use a floating point expression; when
implicitly using C<$.> as described in the previous paragraph, the
comparison is C<int(EXPR) == int($.)> which is only an issue when C<$.>
is set to a floating point value and you are not reading from a file.
Furthermore, C<"span" .. "spat"> or C<2.18 .. 3.14> will not do what
you want in scalar context because each of the operands are evaluated
using their integer representation.

=end original

To be pedantic, the comparison is actually C<int(EXPR) == int(EXPR)>,
but that is only an issue if you use a floating point expression; when
implicitly using C<$.> as described in the previous paragraph, the
comparison is C<int(EXPR) == int($.)> which is only an issue when C<$.>
is set to a floating point value and you are not reading from a file.
Furthermore, C<"span" .. "spat"> or C<2.18 .. 3.14> will not do what
you want in scalar context because each of the operands are evaluated
using their integer representation.
(TBT)

=begin original

Examples:

=end original

例:

=begin original

As a scalar operator:

=end original

スカラー演算子として:

    if (101 .. 200) { print; } # print 2nd hundred lines, short for
                               #   if ($. == 101 .. $. == 200) ...

    next LINE if (1 .. /^$/);  # skip header lines, short for
                               #   ... if ($. == 1 .. /^$/);
                               # (typically in a loop labeled LINE)

    s/^/> / if (/^$/ .. eof());  # quote body

    # parse mail messages
    while (<>) {
        $in_header =   1  .. /^$/;
        $in_body   = /^$/ .. eof;
        if ($in_header) {
            # ...
        } else { # in body
            # ...
        }
    } continue {
        close ARGV if eof;             # reset $. each file
    }

=begin original

Here's a simple example to illustrate the difference between
the two range operators:

=end original

Here's a simple example to illustrate the difference between
the two range operators:
(TBT)

    @lines = ("   - Foo",
              "01 - Bar",
              "1  - Baz",
              "   - Quux");

    foreach (@lines) {
        if (/0/ .. /1/) {
            print "$_\n";
        }
    }

=begin original

This program will print only the line containing "Bar". If
the range operator is changed to C<...>, it will also print the
"Baz" line.

=end original

This program will print only the line containing "Bar". If
the range operator is changed to C<...>, it will also print the
"Baz" line.
(TBT)

=begin original

And now some examples as a list operator:

=end original

And now some examples as a list operator:
(TBT)

    for (101 .. 200) { print; }	# print $_ 100 times
    @foo = @foo[0 .. $#foo];	# an expensive no-op
    @foo = @foo[$#foo-4 .. $#foo];	# slice last 5 items

=begin original

The range operator (in list context) makes use of the magical
auto-increment algorithm if the operands are strings.  You
can say

=end original

(リストコンテキストでの) 範囲演算子は、被演算子が文字列であるときには、
マジカルインクリメントの機能を使います。
以下のように書くと:

    @alphabet = ('A' .. 'Z');

=begin original

to get all normal letters of the English alphabet, or

=end original

英語の大文字すべてを得られますし:

    $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];

=begin original

to get a hexadecimal digit, or

=end original

と書けば、16 進の数字が得られますし、

    @z2 = ('01' .. '31');  print $z2[$mday];

=begin original

to get dates with leading zeros.  If the final value specified is not
in the sequence that the magical increment would produce, the sequence
goes until the next value would be longer than the final value
specified.

=end original

とすれば、0 付きの日付が得られます。
マジカルインクリメントによって得られる値の中に指定した最終値に
ちょうど一致するものが見つからないような場合には、
マジカルインクリメントによって得られる次の値の文字列長が、
最終値として指定した値のものより長くなるまでインクリメントが続けられます。

=begin original

Because each operand is evaluated in integer form, C<2.18 .. 3.14> will
return two elements in list context.

=end original

Because each operand is evaluated in integer form, C<2.18 .. 3.14> will
return two elements in list context.
(TBT)

    @list = (2.18 .. 3.14); # same as @list = (2 .. 3);

=head2 Conditional Operator
X<operator, conditional> X<operator, ternary> X<ternary> X<?:>

(条件演算子)

=begin original

Ternary "?:" is the conditional operator, just as in C.  It works much
like an if-then-else.  If the argument before the ? is true, the
argument before the : is returned, otherwise the argument after the :
is returned.  For example:

=end original

三項演算子の "?:" は、C の場合と同じ条件演算子です。
これは、if-then-else のように働きます。
"?" の前の引数が真であれば ":" の前の引数が返されますが、
真でなければ、":" の後の引数が返されます。例:

    printf "I have %d dog%s.\n", $n,
	    ($n == 1) ? '' : "s";

=begin original

Scalar or list context propagates downward into the 2nd
or 3rd argument, whichever is selected.

=end original

スカラコンテキストかリストコンテキストかという状況は、
選択された 2 番目もしくは 3 番目の引数にまで伝わります。

    $a = $ok ? $b : $c;  # get a scalar
    @a = $ok ? @b : @c;  # get an array
    $a = $ok ? @b : @c;  # oops, that's just a count!

=begin original

The operator may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):

=end original

2 番目と 3 番目の引数双方が左辺値 (代入可能ということ)であれば、
この演算子に代入を行なうこともできます:

    ($a_or_b ? $a : $b) = $c;

=begin original

Because this operator produces an assignable result, using assignments
without parentheses will get you in trouble.  For example, this:

=end original

この演算子は代入可能な結果を生み出すので、
括弧なしで代入を行うとおかしくなるかもしれません。例えば:

    $a % 2 ? $a += 10 : $a += 2

=begin original

Really means this:

=end original

は以下を意味し:

    (($a % 2) ? ($a += 10) : $a) += 2

=begin original

Rather than this:

=end original

以下のようにはなりません:

    ($a % 2) ? ($a += 10) : ($a += 2)

=begin original

That should probably be written more simply as:

=end original

恐らく以下のようにもっと単純に書くべきでしょう:

    $a += ($a % 2) ? 10 : 2;

=head2 Assignment Operators
X<assignment> X<operator, assignment> X<=> X<**=> X<+=> X<*=> X<&=>
X<<< <<= >>> X<&&=> X<-=> X</=> X<|=> X<<< >>= >>> X<||=> X<.=>
X<%=> X<^=> X<x=>

(代入演算子)

=begin original

"=" is the ordinary assignment operator.

=end original

"=" は通常の代入演算子です。

=begin original

Assignment operators work as in C.  That is,

=end original

代入演算子は C の場合と同様の働きをします。つまり、

    $a += 2;

=begin original

is equivalent to

=end original

は以下と等価です。

    $a = $a + 2;

=begin original

although without duplicating any side effects that dereferencing the lvalue
might trigger, such as from tie().  Other assignment operators work similarly.
The following are recognized:

=end original

しかし、tie() のようなもので起こる左辺値の被参照による
副作用が 2 回起こることはありません。
他の代入演算も同様に働きます。以下のものが認識されます:

    **=    +=    *=    &=    <<=    &&=
           -=    /=    |=    >>=    ||=
           .=    %=    ^=
                 x=

=begin original

Although these are grouped by family, they all have the precedence
of assignment.

=end original

グループ分けしてありますが、これらはいずれも代入演算子として
同じ優先順位となっています。

=begin original

Unlike in C, the scalar assignment operator produces a valid lvalue.
Modifying an assignment is equivalent to doing the assignment and
then modifying the variable that was assigned to.  This is useful
for modifying a copy of something, like this:

=end original

C と違って、スカラ代入演算子は有効な左辺値を作り出します。
代入を修正することは、代入を行なってから、その代入された変数を修正するのと
同じことになります。
これは、以下のように何かのコピーを変更したいときに便利です:

    ($tmp = $global) =~ tr [A-Z] [a-z];

=begin original

Likewise,

=end original

同様に、

    ($a += 2) *= 3;

=begin original

is equivalent to

=end original

は以下と同等です。

    $a += 2;
    $a *= 3;

=begin original

Similarly, a list assignment in list context produces the list of
lvalues assigned to, and a list assignment in scalar context returns
the number of elements produced by the expression on the right hand
side of the assignment.

=end original

同様に、リストコンテキストでのリストへの代入は代入可能な左辺値のリストとなり、
スカラコンテキストでのリストへの代入は代入の右側の式で作成された
要素の数を返します。

=head2 Comma Operator
X<comma> X<operator, comma> X<,>

(コンマ演算子)

=begin original

Binary "," is the comma operator.  In scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.  This is just like C's comma operator.

=end original

二項演算子の "," はコンマ演算子です。
スカラコンテキストではその左引数を評価し、その値を捨てて、
それから右引数を評価し、その値を返します。
これはちょうど、C のコンマ演算子と同じです。

=begin original

In list context, it's just the list argument separator, and inserts
both its arguments into the list.

=end original

リストコンテキストでは、これは単にリスト引数の区切り文字で、
双方の引数をそのリストに挿入する働きがあります。

=begin original

The C<< => >> operator is a synonym for the comma, but forces any word
(consisting entirely of word characters) to its left to be interpreted
as a string (as of 5.001).  This includes words that might otherwise be
considered a constant or function call.

=end original

C<< => >> 演算子はコンマ演算子の同義語ですが、(5.001 以降)左辺値の単語
(単語文字で構成される全体)を必ず文字列として扱うという効果もあります。
これには他の場所では定数や関数呼び出しとして扱われる単語を含みます。

    use constant FOO => "something";

    my %h = ( FOO => 23 );

=begin original

is equivalent to:

=end original

は、以下と等価です:

    my %h = ("FOO", 23);

=begin original

It is I<NOT>:

=end original

これは I<違います>:

    my %h = ("something", 23);

=begin original

If the argument on the left is not a word, it is first interpreted as
an expression, and then the string value of that is used.

=end original

If the argument on the left is not a word, it is first interpreted as
an expression, and then the string value of that is used.
(TBT)

=begin original

The C<< => >> operator is helpful in documenting the correspondence
between keys and values in hashes, and other paired elements in lists.

=end original

The C<< => >> operator is helpful in documenting the correspondence
between keys and values in hashes, and other paired elements in lists.
(TBT)

        %hash = ( $key => $value );
        login( $username => $password );

=head2 List Operators (Rightward)
X<operator, list, rightward> X<list operator>

(リスト演算子 (右方向))

=begin original

On the right side of a list operator, it has very low precedence,
such that it controls all comma-separated expressions found there.
The only operators with lower precedence are the logical operators
"and", "or", and "not", which may be used to evaluate calls to list
operators without the need for extra parentheses:

=end original

リスト演算子の右側のものにとって、リスト演算子はとても低い優先順位になります。
これによってコンマで区切った式をリスト演算子の引数として
置くことができます。
これよりも優先順位が低いものは、論理演算子の "and", "or", "not" のみで、
余分な括弧を付けないリスト演算子の呼び出しを評価するために使うことができます:

    open HANDLE, "filename"
	or die "Can't open: $!\n";

=begin original

See also discussion of list operators in L<Terms and List Operators (Leftward)>.

=end original

L<Terms and List Operators (Leftward)> のリスト演算子の議論も参照して下さい。

=head2 Logical Not
X<operator, logical, not> X<not>

(論理否定)

=begin original

Unary "not" returns the logical negation of the expression to its right.
It's the equivalent of "!" except for the very low precedence.

=end original

単項演算子の "not" は右側に来る式の否定を返します。
これは、優先順位がずっと低いことを除いては "!" と等価です。

=head2 Logical And
X<operator, logical, and> X<and>

(論理積)

=begin original

Binary "and" returns the logical conjunction of the two surrounding
expressions.  It's equivalent to && except for the very low
precedence.  This means that it short-circuits: i.e., the right
expression is evaluated only if the left expression is true.

=end original

二項演算子の "and" は両側の式の論理積を返します。
これは、優先順位がずっと低いことを除けば && と等価です。
つまり、これも短絡演算を行ない、右側の式は左側の式が
「真」であった場合にのみ評価されます。

=head2 Logical or and Exclusive Or
X<operator, logical, or> X<operator, logical, xor> X<operator, logical, err>
X<operator, logical, defined or> X<operator, logical, exclusive or>
X<or> X<xor> X<err>

(論理和と排他論理和)

=begin original

Binary "or" returns the logical disjunction of the two surrounding
expressions.  It's equivalent to || except for the very low precedence.
This makes it useful for control flow

=end original

二項演算子の "or" は両側の式の論理和を返します。
これは、優先順位がずっと低いことを除いて || と等価です。
これはフローを制御するのに有用です:

    print FH $data		or die "Can't write to FH: $!";

=begin original

This means that it short-circuits: i.e., the right expression is evaluated
only if the left expression is false.  Due to its precedence, you should
probably avoid using this for assignment, only for control flow.

=end original

つまり、これも短絡演算を行ない、右側の式は左側の式が
「偽」であった場合にのみ評価されます。
優先度の関係で、これは代入には使わず、フローの制御のみに使うべきです。

    $a = $b or $c;		# bug: this is wrong
    ($a = $b) or $c;		# really means this
    $a = $b || $c;		# better written this way

=begin original

However, when it's a list-context assignment and you're trying to use
"||" for control flow, you probably need "or" so that the assignment
takes higher precedence.

=end original

しかし、代入がリストコンテキストの時に "||" をフロー制御に使おうとする場合、
代入により大きな優先順位を持たせるために "or" が必要かもしれません。

    @info = stat($file) || die;     # oops, scalar sense of stat!
    @info = stat($file) or die;     # better, now @info gets its due

=begin original

Then again, you could always use parentheses. 

=end original

もちろん、常に括弧をつけてもよいです。

=begin original

Binary "xor" returns the exclusive-OR of the two surrounding expressions.
It cannot short circuit, of course.

=end original

二項演算子の "xor" は両側の式の排他論理和を返します。
これはもちろん、短絡ではありません。

=head2 C Operators Missing From Perl
X<operator, missing from perl> X<&> X<*>
X<typecasting> X<(TYPE)>

(Perl にない C の演算子)

=begin original

Here is what C has that Perl doesn't:

=end original

C にあって Perl に無いものは以下の通りです:

=over 8

=item unary &

=begin original

Address-of operator.  (But see the "\" operator for taking a reference.)

=end original

アドレス演算子。
("\" 演算子がリファレンスのために用いられます。)

=item unary *

=begin original

Dereference-address operator. (Perl's prefix dereferencing
operators are typed: $, @, %, and &.)

=end original

被アドレス参照演算子。
(Perl の被参照プリフィクス演算子が型づけを行ないます: $, @, %, &。)

=item (TYPE)

=begin original

Type-casting operator.

=end original

型のキャスト演算子。

=back

=head2 Quote and Quote-like Operators
X<operator, quote> X<operator, quote-like> X<q> X<qq> X<qx> X<qw> X<m> 
X<qr> X<s> X<tr> X<'> X<''> X<"> X<""> X<//> X<`> X<``> X<<< << >>>
X<escape sequence> X<escape>

(クォートとクォート風の演算子)

=begin original

While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.  Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.  In the following table, a C<{}> represents
any pair of delimiters you choose.

=end original

クォートはリテラル値であると考えるのが普通ですが、Perl において、
クォートは演算子として働き、さまざまな展開やパターンマッチの機能を
持っています。
そのような動作をさせるのに、Perl は慣習的にクォート文字を使っていますが、
どの種類のクォートも、自分でクォート文字を選べるようになっています。
以下の表では、{} がその選んだ区切文字のペアを示しています。

=begin original

    Customary  Generic        Meaning	     Interpolates
	''	 q{}	      Literal		  no
	""	qq{}	      Literal		  yes
	``	qx{}	      Command		  yes*
		qw{}	     Word list		  no
	//	 m{}	   Pattern match	  yes*
		qr{}	      Pattern		  yes*
		 s{}{}	    Substitution	  yes*
		tr{}{}	  Transliteration	  no (but see below)
        <<EOF                 here-doc            yes*

	* unless the delimiter is ''.

=end original

     通常記法  汎用記法        意味             展開
    =================================================
	''	 q{}	     リテラル		不可
	""	qq{}	     リテラル		可
	``	qx{}	     コマンド		可 *
		qw{}	     単語リスト		不可
	//	 m{}	  パターンマッチ	可 *
		qr{}	     パターン		可 *
		 s{}{}	       置換		可 *
		tr{}{}	       変換		不可 (但し以下を参照のこと)
        <<EOF            ヒヤドキュメント       可 *

	* '' がデリミタでない場合のみ

=begin original

Non-bracketing delimiters use the same character fore and aft, but the four
sorts of brackets (round, angle, square, curly) will all nest, which means
that

=end original

選んだ区切文字が括弧の類でない場合には、前後の文字として同一のものを
使いますが、4 つの括弧 ((), <>, [], {}) の場合にはネストできます。
つまり、以下のものは、

	q{foo{bar}baz}

=begin original

is the same as

=end original

以下と同じです。

	'foo{bar}baz'

=begin original

Note, however, that this does not always work for quoting Perl code:

=end original

しかし、以下のコードはクォートされた Perl コードでは
いつも正しく動くわけではないことに注意してください:

	$s = q{ if($a eq "}") ... }; # WRONG

=begin original

is a syntax error. The C<Text::Balanced> module (from CPAN, and
starting from Perl 5.8 part of the standard distribution) is able
to do this properly.

=end original

これは文法エラーとなります。
C<Text::Balanced> モジュール(CPAN から、または Perl 5.8 からは標準配布
の一部です)はこれを適切に行います。

=begin original

There can be whitespace between the operator and the quoting
characters, except when C<#> is being used as the quoting character.
C<q#foo#> is parsed as the string C<foo>, while C<q #foo#> is the
operator C<q> followed by a comment.  Its argument will be taken
from the next line.  This allows you to write:

=end original

演算子とクォート文字の間に空白を置くことも出来ます。
ただし、C<#> をクォート文字として使う場合は例外です。
C<q#foo#> は文字列 C<foo> としてパースされますが、
C<q #foo#> は C<q> 演算子の後にコメントがあるとみなされます。
この引数は次の行から取られます。つまり、以下のように書けます:

    s {foo}  # Replace foo
      {bar}  # with bar.

=begin original

The following escape sequences are available in constructs that interpolate
and in transliterations.
X<\t> X<\n> X<\r> X<\f> X<\b> X<\a> X<\e> X<\x> X<\0> X<\c> X<\N>

=end original

The following escape sequences are available in constructs that interpolate
and in transliterations.
X<\t> X<\n> X<\r> X<\f> X<\b> X<\a> X<\e> X<\x> X<\0> X<\c> X<\N>
(TBT)

=begin original

    \t		tab             (HT, TAB)
    \n		newline         (NL)
    \r		return          (CR)
    \f		form feed       (FF)
    \b		backspace       (BS)
    \a		alarm (bell)    (BEL)
    \e		escape          (ESC)
    \033	octal char	(ESC)
    \x1b	hex char	(ESC)
    \x{263a}	wide hex char	(SMILEY)
    \c[		control char    (ESC)
    \N{name}	named Unicode character

=end original

    \t          タブ
    \n          改行
    \r          復帰
    \f          改ページ
    \b          バックスペース
    \a          アラーム (ベル)
    \e          エスケープ
    \033        8 進数で表した文字
    \x1b        16 進数で表した文字
    \x{263a}	16 進数で表したワイド文字	(SMILEY)
    \c[         コントロール文字
    \N{name}	名前つき Unicode 文字

=begin original

B<NOTE>: Unlike C and other languages, Perl has no \v escape sequence for
the vertical tab (VT - ASCII 11).

=end original

B<NOTE>: Unlike C and other languages, Perl has no \v escape sequence for
the vertical tab (VT - ASCII 11).
(TBT)

=begin original

The following escape sequences are available in constructs that interpolate
but not in transliterations.
X<\l> X<\u> X<\L> X<\U> X<\E> X<\Q>

=end original

The following escape sequences are available in constructs that interpolate
but not in transliterations.
X<\l> X<\u> X<\L> X<\U> X<\E> X<\Q>
(TBT)

=begin original

    \l		lowercase next char
    \u		uppercase next char
    \L		lowercase till \E
    \U		uppercase till \E
    \E		end case modification
    \Q		quote non-word characters till \E

=end original

    \l          次の文字を小文字にする
    \u          次の文字を大文字にする
    \L          \E まで小文字にする
    \U          \E まで大文字にする
    \E          変更の終わり
    \Q          \E まで非単語文字をクォートする

=begin original

If C<use locale> is in effect, the case map used by C<\l>, C<\L>,
C<\u> and C<\U> is taken from the current locale.  See L<perllocale>.
If Unicode (for example, C<\N{}> or wide hex characters of 0x100 or
beyond) is being used, the case map used by C<\l>, C<\L>, C<\u> and
C<\U> is as defined by Unicode.  For documentation of C<\N{name}>,
see L<charnames>.

=end original

C<use locale> が有効の場合、
C<\l>, C<\L>, C<\u>, C<\U> で使われる大文字小文字テーブルは
現在のロケールのものが使われます。
L<perllocale> を参照して下さい。
If Unicode (for example, C<\N{}> or wide hex characters of 0x100 or
beyond) is being used, the case map used by C<\l>, C<\L>, C<\u> and
C<\U> is as defined by Unicode.
C<\N{name}> のドキュメントに関しては、L<charnames> を参照して下さい。
(TBT)

=begin original

All systems use the virtual C<"\n"> to represent a line terminator,
called a "newline".  There is no such thing as an unvarying, physical
newline character.  It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.  Not all
systems read C<"\r"> as ASCII CR and C<"\n"> as ASCII LF.  For example,
on a Mac, these are reversed, and on systems without line terminator,
printing C<"\n"> may emit no actual data.  In general, use C<"\n"> when
you mean a "newline" for your system, but use the literal ASCII when you
need an exact character.  For example, most networking protocols expect
and prefer a CR+LF (C<"\015\012"> or C<"\cM\cJ">) for line terminators,
and although they often accept just C<"\012">, they seldom tolerate just
C<"\015">.  If you get in the habit of using C<"\n"> for networking,
you may be burned some day.
X<newline> X<line terminator> X<eol> X<end of line>
X<\n> X<\r> X<\r\n>

=end original

全てのシステムでは "newline" と呼ばれる行端末子を表現するために
仮想的な C<"\n"> が用いられます。
普遍の、物理的な "newline" 文字と言うものはありません。
オペレーティングシステム、デバイスドライバ、C ライブラリ、
Perl が全て協力して保存しようとすると言うのは単なる幻想です。
全てのシステムで C<"\r"> を ASCII CR として、また C<"\n"> を
ASCII LF として読み込むわけではありません。
例えば Mac ではこれらは保存され、行端末子のないシステムでは、
C<"\n"> を print しても実際のデータは何も出力しません。
一般に、システムで "newline" を意味したいときには C<"\n"> を使いますが、
正確な文字が必要な場合はリテラルな ASCII を使います。
例えば、ほとんどのネットワークプロトコルでは行端末子として
CR+LF (C<"\015\012"> または C<"\cM\cJ">) を予想し、また好みますが、
しばしば C<"\012"> だけでも許容し、さらに時々は C<"\015"> だけでも認めます。
もしネットワーク関係で C<"\n"> を使う習慣がついていると、
いつか痛い目を見ることになるでしょう。

=begin original

For constructs that do interpolate, variables beginning with "C<$>"
or "C<@>" are interpolated.  Subscripted variables such as C<$a[3]> or
C<< $href->{key}[0] >> are also interpolated, as are array and hash slices.
But method calls such as C<< $obj->meth >> are not.

=end original

展開が行なわれる構文では、"C<$>" や "C<@>" で始まる変数が展開されます。
Subscripted variables such as C<$a[3]> or
C<< $href->{key}[0] >> are also interpolated, as are array and hash slices.
But method calls such as C<< $obj->meth >> are not.
(TBT)

=begin original

Interpolating an array or slice interpolates the elements in order,
separated by the value of C<$">, so is equivalent to interpolating
C<join $", @array>.    "Punctuation" arrays such as C<@+> are only
interpolated if the name is enclosed in braces C<@{+}>.

=end original

Interpolating an array or slice interpolates the elements in order,
separated by the value of C<$">, so is equivalent to interpolating
C<join $", @array>.    "Punctuation" arrays such as C<@+> are only
interpolated if the name is enclosed in braces C<@{+}>.
(TBT)

=begin original

You cannot include a literal C<$> or C<@> within a C<\Q> sequence. 
An unescaped C<$> or C<@> interpolates the corresponding variable, 
while escaping will cause the literal string C<\$> to be inserted.
You'll need to write something like C<m/\Quser\E\@\Qhost/>. 

=end original

C<\Q> シーケンスの中にリテラルな C<$> や C<@> を入れることはできません。
エスケープされない C<$> や C<@> は対応する変数に変換されます。
一方、エスケープすると、リテラルな文字列 C<\$> が挿入されます。
C<m/\Quser\E\@\Qhost/> などという風に書く必要があります。

=begin original

Patterns are subject to an additional level of interpretation as a
regular expression.  This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.  If this is not what you want, use C<\Q> to
interpolate a variable literally.

=end original

パターンはさらに、正規表現として展開が行なわれます。
これは、変数が展開された後の 2 回目のパスで行なわれるので、
変数に正規表現を含めておき、パターンの中へ展開することができます。
もし、そうしたくないのであれば、C<\Q> を使うと変数の内容を文字通りに
展開することができます。

=begin original

Apart from the behavior described above, Perl does not expand
multiple levels of interpolation.  In particular, contrary to the
expectations of shell programmers, back-quotes do I<NOT> interpolate
within double quotes, nor do single quotes impede evaluation of
variables when used within double quotes.

=end original

上記の振る舞いを除けば、Perl は 複数の段階を踏んで展開を行ないません。
特に、シェルのプログラマの期待とは裏腹に、
バッククォートはダブルクォートの中では展開されませんし、シングルクォートが
ダブルクォートの中で使われても、変数の展開を妨げることは I<ありません>。

=head2 Regexp Quote-Like Operators
X<operator, regexp>

(正規表現のクォート風の演算子)

=begin original

Here are the quote-like operators that apply to pattern
matching and related activities.

=end original

以下はパターンマッチングと関連する行動に関するクォート風の演算子です。

=over 8

=item ?PATTERN?
X<?>

=begin original

This is just like the C</pattern/> search, except that it matches only
once between calls to the reset() operator.  This is a useful
optimization when you want to see only the first occurrence of
something in each file of a set of files, for instance.  Only C<??>
patterns local to the current package are reset.

=end original

これは、reset() 演算子を呼び出すごとに 1 度だけしか
マッチしないことを除いては C</pattern/> による検索と全く同じです。
たとえば、ファイルの集まりの中で個々のファイルについて、
あるものを探すとき、最初の 1 つだけの存在がわかれば良いのであれば、
この機能を使って最適化をはかることができます。
現在のパッケージにローカルとなっている C<??> のパターンだけが
リセットされます。

    while (<>) {
	if (?^$?) {
			    # blank line between header and body
	}
    } continue {
	reset if eof;	    # clear ?? status for next file
    }

=begin original

This usage is vaguely deprecated, which means it just might possibly
be removed in some distant future version of Perl, perhaps somewhere
around the year 2168.

=end original

この方法は、あまりお勧めしません。
Perl の遠い将来のバージョン(おそらく 2168 年頃)では削除されるかもしれません。

=item m/PATTERN/cgimosx
X<m> X<operator, match> 
X<regexp, options> X<regexp> X<regex, options> X<regex> 
X</c> X</i> X</m> X</o> X</s> X</x>

=item /PATTERN/cgimosx

=begin original

Searches a string for a pattern match, and in scalar context returns
true if it succeeds, false if it fails.  If no string is specified
via the C<=~> or C<!~> operator, the $_ string is searched.  (The
string specified with C<=~> need not be an lvalue--it may be the
result of an expression evaluation, but remember the C<=~> binds
rather tightly.)  See also L<perlre>.  See L<perllocale> for
discussion of additional considerations that apply when C<use locale>
is in effect.

=end original

パターンマッチで文字列検索を行ない、スカラコンテキストでは成功したときは真、
失敗したときは偽を返します。
C<=~> 演算子か C<!~> 演算子で検索対象の文字列を示さなかったときには、
C<$_> の文字列が検索対象となります。
(C<=~> で指定される文字列は、左辺値である必要はありません。
式を評価した結果でもかまいませんが、C<=~> の優先順位がいくぶん高いことに
注意してください。)
L<perlre> も参照してください。
C<use locale> が有効の場合の議論については L<perllocale> を参照して下さい。

=begin original

Options are:

=end original

オプションには以下のものがあります。

=begin original

    c	Do not reset search position on a failed match when /g is in effect.
    g	Match globally, i.e., find all occurrences.
    i	Do case-insensitive pattern matching.
    m	Treat string as multiple lines.
    o	Compile pattern only once.
    s	Treat string as single line.
    x	Use extended regular expressions.

=end original

    c	/g が有効なとき、マッチングに失敗しても検索位置をリセットしない
    g   グローバルにマッチ、つまり、すべてを探し出す
    i   大文字、小文字を区別しない
    m   文字列を複数行として扱う
    o   パターンのコンパイルを 1 度だけにする
    s   文字列を単一行として扱う
    x   拡張正規表現を使用する

=begin original

If "/" is the delimiter then the initial C<m> is optional.  With the C<m>
you can use any pair of non-alphanumeric, non-whitespace characters 
as delimiters.  This is particularly useful for matching path names
that contain "/", to avoid LTS (leaning toothpick syndrome).  If "?" is
the delimiter, then the match-only-once rule of C<?PATTERN?> applies.
If "'" is the delimiter, no interpolation is performed on the PATTERN.

=end original

区切文字が "/" のときには、最初の C<m> は付けても付けなくてもかまいません。
C<m> を付けるときには、英数字でも空白でもない、任意の文字のペアを
区切文字として使うことができます。
これは "/" を含むパス名にパターンパッチを行なうときに便利でしょう。
LTS (楊枝偏執症候群) を避けるためにも。
"'" がデリミタの場合、PATTERN に対する展開は行われません。

=begin original

PATTERN may contain variables, which will be interpolated (and the
pattern recompiled) every time the pattern search is evaluated, except
for when the delimiter is a single quote.  (Note that C<$(>, C<$)>, and
C<$|> are not interpolated because they look like end-of-string tests.)
If you want such a pattern to be compiled only once, add a C</o> after
the trailing delimiter.  This avoids expensive run-time recompilations,
and is useful when the value you are interpolating won't change over
the life of the script.  However, mentioning C</o> constitutes a promise
that you won't change the variables in the pattern.  If you change them,
Perl won't even notice.  See also L<"qr/STRING/imosx">.

=end original

PATTERN には、変数が含まれていてもよく、パターンが評価されるごとに、
(デリミタがシングルクォートでない限り)
変数は展開され (パターンが再コンパイルされ) ます。
(変数 C<$(>, C<$)>, C<$|> は文字列の終わりを調べるパターンであると
解釈されるので、展開されません。)
パターンがコンパイルされるのを 1 度だけにしたい場合には、
終わりの区切文字の後に C</o> 修飾子を付けます。
これにより、実行時に再コンパイルが頻繁に起こることが避けられ、
展開する値がスクリプトの実行中に変化しない場合に有効なものとなります。
しかし、C</o> を付けることは、パターンの中の変数を変更しないことを
約束するものです。
変更したとしても、Perl がそれに気付くことはありません。
L<"qr/STRING/imosx"> も参照して下さい。

=begin original

If the PATTERN evaluates to the empty string, the last
I<successfully> matched regular expression is used instead. In this
case, only the C<g> and C<c> flags on the empty pattern is honoured -
the other flags are taken from the original pattern. If no match has
previously succeeded, this will (silently) act instead as a genuine
empty pattern (which will always match).

=end original

PATTERN を評価した結果が空文字列となった場合には、
最後にマッチに I<成功した> 正規表現が、代わりに使われます。
In this
case, only the C<g> and C<c> flags on the empty pattern is honoured -
the other flags are taken from the original pattern. If no match has
previously succeeded, this will (silently) act instead as a genuine
empty pattern (which will always match).
(TBT)

=begin original

If the C</g> option is not used, C<m//> in list context returns a
list consisting of the subexpressions matched by the parentheses in the
pattern, i.e., (C<$1>, C<$2>, C<$3>...).  (Note that here C<$1> etc. are
also set, and that this differs from Perl 4's behavior.)  When there are
no parentheses in the pattern, the return value is the list C<(1)> for
success.  With or without parentheses, an empty list is returned upon
failure.

=end original

C</g>オプションが使われなかった場合、リストコンテキストでのC<m//>は
パターンの中の括弧で括られた部分列にマッチしたもので構成されるリストを
返します。
これは、(C<$1>, C<$2>, C<$3>, ...) ということです。
(この場合、C<$1> なども設定されます。
この点で Perl 4 の動作と違っています。)
パターンに括弧がない場合は、返り値は成功時はリスト C<(1)> です。
括弧のあるなしに関わらず、失敗時は空リストを返します。

=begin original

Examples:

=end original

例を示します:

    open(TTY, '/dev/tty');
    <TTY> =~ /^y/i && foo();	# do foo if desired

    if (/Version: *([0-9.]*)/) { $version = $1; }

    next if m#^/usr/spool/uucp#;

    # poor man's grep
    $arg = shift;
    while (<>) {
	print if /$arg/o;	# compile only once
    }

    if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))

=begin original

This last example splits $foo into the first two words and the
remainder of the line, and assigns those three fields to $F1, $F2, and
$Etc.  The conditional is true if any variables were assigned, i.e., if
the pattern matched.

=end original

最後の例は、$foo を最初の 2 つの単語と行の残りに分解し、
$F1 と $F2 と $Etc に代入しています。
変数に代入されれば、すなわちパターンがマッチすれば、
if の条件が真となります。

=begin original

The C</g> modifier specifies global pattern matching--that is,
matching as many times as possible within the string.  How it behaves
depends on the context.  In list context, it returns a list of the
substrings matched by any capturing parentheses in the regular
expression.  If there are no parentheses, it returns a list of all
the matched strings, as if there were parentheses around the whole
pattern.

=end original

C</g> 修飾子は、グローバルなパターンマッチを指定するもので、
文字列の中で可能な限りたくさんマッチを行ないます。
この動作は、コンテキストに依存します。
リストコンテキストでは、正規表現内の括弧付けされたものにマッチした
部分文字列のリストが返されます。
括弧がなければ、パターン全体を括弧で括っていたかのように、
すべてのマッチした文字列のリストが返されます。

=begin original

In scalar context, each execution of C<m//g> finds the next match,
returning true if it matches, and false if there is no further match.
The position after the last match can be read or set using the pos()
function; see L<perlfunc/pos>.   A failed match normally resets the
search position to the beginning of the string, but you can avoid that
by adding the C</c> modifier (e.g. C<m//gc>).  Modifying the target
string also resets the search position.

=end original

スカラコンテキストでは、C<m//g> を実行する毎に次のマッチを探します。
マッチした場合は真を返し、もうマッチしなくなったら偽を返します。
最後のマッチの位置は pos() 関数で読み出しや設定ができます。
L<perlfunc/pos> を参照して下さい。
マッチに失敗すると通常は検索位置を文字列の先頭にリセットしますが、
C</c> 修飾子をつける(つまり C<m//gc>)ことでこれを防ぐことができます。
ターゲットとなる文字列が変更された場合も検索位置はリセットされます。

=begin original

You can intermix C<m//g> matches with C<m/\G.../g>, where C<\G> is a
zero-width assertion that matches the exact position where the previous
C<m//g>, if any, left off.  Without the C</g> modifier, the C<\G> assertion
still anchors at pos(), but the match is of course only attempted once.
Using C<\G> without C</g> on a target string that has not previously had a
C</g> match applied to it is the same as using the C<\A> assertion to match
the beginning of the string.  Note also that, currently, C<\G> is only
properly supported when anchored at the very beginning of the pattern.

=end original

C<m//g> マッチを C<m/\G.../g> と混ぜることもできます。
C<\G> は前回の C<m//g> があればその同じ位置でマッチする
ゼロ文字幅のアサートです。
C</g> 修飾子なしの場合、C<\G> アサートは pos() に固定しますが、
マッチはもちろん一度だけ試されます。
以前に C</g> マッチを適用していないターゲット文字列に対して
C</g> なしで C<\G> を使うと、文字列の先頭にマッチする C<\A> アサートを
使うのと同じことになります。
Note also that, currently, C<\G> is only
properly supported when anchored at the very beginning of the pattern.
(TBT)

=begin original

Examples:

=end original

例:

    # list context
    ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

    # scalar context
    $/ = "";
    while (defined($paragraph = <>)) {
	while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
	    $sentences++;
	}
    }
    print "$sentences\n";

    # using m//gc with \G
    $_ = "ppooqppqq";
    while ($i++ < 2) {
        print "1: '";
        print $1 while /(o)/gc; print "', pos=", pos, "\n";
        print "2: '";
        print $1 if /\G(q)/gc;  print "', pos=", pos, "\n";
        print "3: '";
        print $1 while /(p)/gc; print "', pos=", pos, "\n";
    }
    print "Final: '$1', pos=",pos,"\n" if /\G(.)/;

=begin original

The last example should print:

=end original

最後のものは以下のものを表示するはずです:

    1: 'oo', pos=4
    2: 'q', pos=5
    3: 'pp', pos=7
    1: '', pos=7
    2: 'q', pos=8
    3: '', pos=8
    Final: 'q', pos=8

=begin original

Notice that the final match matched C<q> instead of C<p>, which a match
without the C<\G> anchor would have done. Also note that the final match
did not update C<pos> -- C<pos> is only updated on a C</g> match. If the
final match did indeed match C<p>, it's a good bet that you're running an
older (pre-5.6.0) Perl.

=end original

C<\G> なしでのマッチが行われたため、最後のマッチでは C<p> ではなく
C<q> がマッチすることに注意してください。
また、最後のマッチは C<pos> を更新しないことに注意してください。
C<pos> は C</g> マッチでのみ更新されます。
もし最後のマッチで C<p> にマッチした場合、かなりの確率で
古い (5.6.0 以前の) Perl で実行しているはずです。

=begin original

A useful idiom for C<lex>-like scanners is C</\G.../gc>.  You can
combine several regexps like this to process a string part-by-part,
doing different actions depending on which regexp matched.  Each
regexp tries to match where the previous one leaves off.

=end original

C<lex> 風にスキャンするために便利な指定は C</\G.../gc> です。
文字列を部分ごとに処理するためにいくつかの正規表現をつなげて、
どの正規表現にマッチしたかによって異なる処理をすることができます。
それぞれの正規表現は前の正規表現が飛ばした部分に対して
マッチを試みます。

 $_ = <<'EOL';
      $url = new URI::URL "http://www/";   die if $url eq "xXx";
 EOL
 LOOP:
    {
      print(" digits"),		redo LOOP if /\G\d+\b[,.;]?\s*/gc;
      print(" lowercase"),	redo LOOP if /\G[a-z]+\b[,.;]?\s*/gc;
      print(" UPPERCASE"),	redo LOOP if /\G[A-Z]+\b[,.;]?\s*/gc;
      print(" Capitalized"),	redo LOOP if /\G[A-Z][a-z]+\b[,.;]?\s*/gc;
      print(" MiXeD"),		redo LOOP if /\G[A-Za-z]+\b[,.;]?\s*/gc;
      print(" alphanumeric"),	redo LOOP if /\G[A-Za-z0-9]+\b[,.;]?\s*/gc;
      print(" line-noise"),	redo LOOP if /\G[^A-Za-z0-9]+/gc;
      print ". That's all!\n";
    }

=begin original

Here is the output (split into several lines):

=end original

出力は以下のようになります(何行かに分割しています):

 line-noise lowercase line-noise lowercase UPPERCASE line-noise
 UPPERCASE line-noise lowercase line-noise lowercase line-noise
 lowercase lowercase line-noise lowercase lowercase line-noise
 MiXeD line-noise. That's all!

=item q/STRING/
X<q> X<quote, double> X<'> X<''>

=item C<'STRING'>

=begin original

A single-quoted, literal string.  A backslash represents a backslash
unless followed by the delimiter or another backslash, in which case
the delimiter or backslash is interpolated.

=end original

シングルクォートされた、リテラル文字列です。
バックスラッシュは、後ろに続くものが区切文字か、別のバックスラッシュで
ある場合を除いて単なるバックスラッシュです。
区切文字やバックスラッシュが続く場合には、その区切文字自身もしくは
バックスラッシュそのものが展開されます。

    $foo = q!I said, "You said, 'She said it.'"!;
    $bar = q('This is it.');
    $baz = '\n';		# a two-character string

=item qq/STRING/
X<qq> X<quote, double> X<"> X<"">

=item "STRING"

=begin original

A double-quoted, interpolated string.

=end original

ダブルクォートされた、リテラル文字列です。

    $_ .= qq
     (*** The previous line contains the naughty word "$1".\n)
		if /\b(tcl|java|python)\b/i;      # :-)
    $baz = "\n";		# a one-character string

=item qr/STRING/imosx
X<qr> X</i> X</m> X</o> X</s> X</x>

=begin original

This operator quotes (and possibly compiles) its I<STRING> as a regular
expression.  I<STRING> is interpolated the same way as I<PATTERN>
in C<m/PATTERN/>.  If "'" is used as the delimiter, no interpolation
is done.  Returns a Perl value which may be used instead of the
corresponding C</STRING/imosx> expression.

=end original

この演算子は I<STRING> を正規表現としてクォートします
(そして可能ならコンパイルします)。
I<STRING> は C<m/PATTERN/> 内の I<PATTERN> と同様に文字変換されます。
"'" がデリミタとして使用された場合、文字変換は行われません。
対応する C</STRING/imosx> 表現の代わりに使われた Perl の値を返します。

=begin original

For example,

=end original

例えば:

    $rex = qr/my.STRING/is;
    s/$rex/foo/;

=begin original

is equivalent to

=end original

は以下と等価です:

    s/my.STRING/foo/is;

=begin original

The result may be used as a subpattern in a match:

=end original

結果はマッチのサブパターンとして使えます:

    $re = qr/$pattern/;
    $string =~ /foo${re}bar/;	# can be interpolated in other patterns
    $string =~ $re;		# or used standalone
    $string =~ /$re/;		# or this way

=begin original

Since Perl may compile the pattern at the moment of execution of qr()
operator, using qr() may have speed advantages in some situations,
notably if the result of qr() is used standalone:

=end original

Perl は qr() 演算子を実行する瞬間にパターンをコンパイルするので、
qr() を使うことでいくつかの場面で速度的に有利になります。
特に qr() の結果が独立して使われる場合に有利になります。

    sub match {
	my $patterns = shift;
	my @compiled = map qr/$_/i, @$patterns;
	grep {
	    my $success = 0;
	    foreach my $pat (@compiled) {
		$success = 1, last if /$pat/;
	    }
	    $success;
	} @_;
    }

=begin original

Precompilation of the pattern into an internal representation at
the moment of qr() avoids a need to recompile the pattern every
time a match C</$pat/> is attempted.  (Perl has many other internal
optimizations, but none would be triggered in the above example if
we did not use qr() operator.)

=end original

qr() の時点でパターンを内部表現にプリコンパイルすることにより、
C</$pat/> を試みる毎に毎回パターンを再コンパイルするのを避けることができます
(Perl はその他にも多くの内部最適化を行いますが、
上の例で qr() 演算子を使わなかった場合はどの最適化も行われません)。

=begin original

Options are:

=end original

オプションは以下の通りです:

=begin original

    i	Do case-insensitive pattern matching.
    m	Treat string as multiple lines.
    o	Compile pattern only once.
    s	Treat string as single line.
    x	Use extended regular expressions.

=end original

    i	パターンマッチにおいて大文字小文字を区別しない
    m	文字列を複数行として扱う
    o	一度だけコンパイルする
    s	文字列を一行として扱う
    x	拡張正規表現を使う

=begin original

See L<perlre> for additional information on valid syntax for STRING, and
for a detailed look at the semantics of regular expressions.

=end original

STRING の有効な文法に関する追加の情報と、正規表現の動作に関する
詳細については L<perlre> を参照して下さい。

=item qx/STRING/
X<qx> X<`> X<``> X<backtick>

=item `STRING`

=begin original

A string which is (possibly) interpolated and then executed as a
system command with C</bin/sh> or its equivalent.  Shell wildcards,
pipes, and redirections will be honored.  The collected standard
output of the command is returned; standard error is unaffected.  In
scalar context, it comes back as a single (potentially multi-line)
string, or undef if the command failed.  In list context, returns a
list of lines (however you've defined lines with $/ or
$INPUT_RECORD_SEPARATOR), or an empty list if the command failed.

=end original

展開され、C</bin/sh> またはそれと等価なものでシステムのコマンドとして
実行される(であろう)文字列です。
シェルのワイルドカード、パイプ、リダイレクトが有効です。
そのコマンドの、標準出力を集めたものが返されます。
標準エラーは影響を与えません。
スカラコンテキストでは、(複数行を含むかもしれない)
1 つの文字列が戻ってきます。
コマンドが失敗したときは未定義値を返します。
リストコンテキストでは、($/ もしくは $INPUT_RECORD_SEPARATOR を
どのように設定していても) 行のリストを返します。
コマンドが失敗したときは空リストを返します。

=begin original

Because backticks do not affect standard error, use shell file descriptor
syntax (assuming the shell supports this) if you care to address this.
To capture a command's STDERR and STDOUT together:

=end original

バッククォートは標準エラーには影響を与えないので、
標準エラーを使いたい場合は(シェルが対応しているものとして)
シェルのファイル記述子の文法を使ってください。
コマンドの STDERR と STDOUT を共に取得したい場合は:

    $output = `cmd 2>&1`;

=begin original

To capture a command's STDOUT but discard its STDERR:

=end original

コマンドの STDOUT は取得するが STDERR は捨てる場合は:

    $output = `cmd 2>/dev/null`;

=begin original

To capture a command's STDERR but discard its STDOUT (ordering is
important here):

=end original

コマンドの STDERR は取得するが STDOUT は捨てる場合は
(ここでは順序が重要です):

    $output = `cmd 2>&1 1>/dev/null`;

=begin original

To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out the old STDERR:

=end original

STDERR を取得するが、STDOUT は古い STDERR のために残しておくために
STDOUT と STDERR を交換するには:

    $output = `cmd 3>&1 1>&2 2>&3 3>&-`;

=begin original

To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:

=end original

コマンドの STDOUT と STDERR の両方を別々に読み込みたい場合、
一番簡単な方法は別々のファイルにリダイレクトし、
プログラムが終了してからそのファイルを読むことです:

    system("program args 1>program.stdout 2>program.stderr");

=begin original

Using single-quote as a delimiter protects the command from Perl's
double-quote interpolation, passing it on to the shell instead:

=end original

シングルクォートをデリミタとして使うと Perl のダブルクォート展開から
保護され、そのままシェルに渡されます:

    $perl_info  = qx(ps $$);            # that's Perl's $$
    $shell_info = qx'ps $$';            # that's the new shell's $$

=begin original

How that string gets evaluated is entirely subject to the command
interpreter on your system.  On most platforms, you will have to protect
shell metacharacters if you want them treated literally.  This is in
practice difficult to do, as it's unclear how to escape which characters.
See L<perlsec> for a clean and safe example of a manual fork() and exec()
to emulate backticks safely.

=end original

この文字列がどのように評価されるかは完全にシステムの
コマンドインタプリタに依存します。
ほとんどのプラットフォームでは、シェルのメタキャラクタを
リテラルに扱ってほしい場合はそれを守る必要があります。
文字をエスケープする方法が明確ではないので、これは理論的には難しいことです。
逆クォートを安全にエミュレートするために手動で fork() と exec() を
行うためのきれいで安全な例については L<perlsec> を参照してください。

=begin original

On some platforms (notably DOS-like ones), the shell may not be
capable of dealing with multiline commands, so putting newlines in
the string may not get you what you want.  You may be able to evaluate
multiple commands in a single line by separating them with the command
separator character, if your shell supports that (e.g. C<;> on many Unix
shells; C<&> on the Windows NT C<cmd> shell).

=end original

(特に DOS 風の)プラットフォームには、シェルが複数行のコマンドを
扱うことができないものがあるので、文字列に改行を入れると
あなたの望まない結果になる場合があります。
シェルが対応していれば、コマンド分割文字で分割することで
1 行に複数のコマンドを入れて解釈させることができます
(この文字は、多くの Unix シェルでは C<;>、Windows NT C<cmd> シェルでは
C<&> です)。

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before starting the child process, but this may not be supported
on some platforms (see L<perlport>).  To be safe, you may need to set
C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method of
C<IO::Handle> on any open handles.

=end original

v5.6.0 以降、Perl は子プロセスの実行前に書き込み用に開いている全ての
ファイルをフラッシュしようとしますが、これに対応していない
プラットフォームもあります(L<perlport> を参照してください)。
安全のためには、C<$|> (English モジュールでは $AUTOFLUSH)をセットするか、
開いている全てのハンドルに対して C<IO::Handle> の C<autoflush()> メソッドを
呼び出す必要があります。

=begin original

Beware that some command shells may place restrictions on the length
of the command line.  You must ensure your strings don't exceed this
limit after any necessary interpolations.  See the platform-specific
release notes for more details about your particular environment.

=end original

コマンド行の長さに制限があるコマンドシェルがあることに注意してください。
全ての必要な変換が行われた後、コマンド文字列がこの制限を越えないことを
保障する必要があります。
特定の環境に関するさらなる詳細についてはプラットフォーム固有の
リリースノートを参照してください。

=begin original

Using this operator can lead to programs that are difficult to port,
because the shell commands called vary between systems, and may in
fact not be present at all.  As one example, the C<type> command under
the POSIX shell is very different from the C<type> command under DOS.
That doesn't mean you should go out of your way to avoid backticks
when they're the right way to get something done.  Perl was made to be
a glue language, and one of the things it glues together is commands.
Just understand what you're getting yourself into.

=end original

この演算子を使うと、プログラムの移殖が困難になります。
呼び出されるシェルコマンドはシステムによって異なり、
実際全く存在しないこともあるからです。
一つの例としては、POSIX シェルの C<type> コマンドは
DOS の C<type> コマンドと大きく異なっています。
これは、何かを為すために正しい方法として逆クォートを使うことを
避けるべきであることを意味しません。
Perl は接着剤のような言語として作られ、接着されるべきものの一つは
コマンドです。
単にあなたが何をしようとしているかを理解しておいてください。

=begin original

See L<"I/O Operators"> for more discussion.

=end original

さらなる議論については L<"I/O Operators"> を参照して下さい。

=item qw/STRING/
X<qw> X<quote, list> X<quote, words>

=begin original

Evaluates to a list of the words extracted out of STRING, using embedded
whitespace as the word delimiters.  It can be understood as being roughly
equivalent to:

=end original

埋め込まれた空白を区切文字として、STRING から抜き出した
単語のリストを評価します。
これは、以下の式と大体同じと考えられます:

    split(' ', q/STRING/);

=begin original

the differences being that it generates a real list at compile time, and
in scalar context it returns the last element in the list.  So
this expression:

=end original

違いは、実際のリストをコンパイル時に生成し、スカラコンテキストではリストの
最後の要素を返すことです。
従って、以下の表現は:

    qw(foo bar baz)

=begin original

is semantically equivalent to the list:

=end original

以下のリストと文法的に等価です。

    'foo', 'bar', 'baz'

=begin original

Some frequently seen examples:

=end original

よく行なわれる例としては以下のものです:

    use POSIX qw( setlocale localeconv )
    @EXPORT = qw( foo bar baz );

=begin original

A common mistake is to try to separate the words with comma or to
put comments into a multi-line C<qw>-string.  For this reason, the
C<use warnings> pragma and the B<-w> switch (that is, the C<$^W> variable) 
produces warnings if the STRING contains the "," or the "#" character.

=end original

よくある間違いは、単語をカンマで区切ったり、複数行の C<qw> 文字列の中に
コメントを書いたりすることです。
このために、C<usr warnings> プラグマと B<-w> スイッチ
(つまり、C<$^W> 変数) は STRING に "," や "#" の文字が入っていると
警告を出します。

=item s/PATTERN/REPLACEMENT/egimosx
X<substitute> X<substitution> X<replace> X<regexp, replace>
X<regexp, substitute> X</e> X</g> X</i> X</m> X</o> X</s> X</x>

=begin original

Searches a string for a pattern, and if found, replaces that pattern
with the replacement text and returns the number of substitutions
made.  Otherwise it returns false (specifically, the empty string).

=end original

文字列中でパターンを検索し、もし見つかれば、置換テキストで置き換え、
置換した数を返します。
見つからなければ、偽 (具体的には、空文字列) を返します。

=begin original

If no string is specified via the C<=~> or C<!~> operator, the C<$_>
variable is searched and modified.  (The string specified with C<=~> must
be scalar variable, an array element, a hash element, or an assignment
to one of those, i.e., an lvalue.)

=end original

C<=~> 演算子や C<!~> 演算子によって文字列が指定されていなければ、
変数 C<$_> が検索され、修正されます。
(C<=~> で指定される文字列は、スカラ変数、配列要素、ハッシュ要素、
あるいは、これらへの代入式といった左辺値でなければなりません。)

=begin original

If the delimiter chosen is a single quote, no interpolation is
done on either the PATTERN or the REPLACEMENT.  Otherwise, if the
PATTERN contains a $ that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern
at run-time.  If you want the pattern compiled only once the first time
the variable is interpolated, use the C</o> option.  If the pattern
evaluates to the empty string, the last successfully executed regular
expression is used instead.  See L<perlre> for further explanation on these.
See L<perllocale> for discussion of additional considerations that apply
when C<use locale> is in effect.

=end original

あとで述べますが、区切り文字はスラッシュとは限りません。
シングルクォートを区切り文字として使った場合には、
PATTERN にも REPLACEMENT にも変数の展開を行ないません。
それ以外の場合、文字列の最後を表わすものには見えない $ が
PATTERN に含まれると、実行時に変数がパターン内に展開されます。
最初に変数が展開されるときにだけパターンのコンパイルを行ないたいときには、
C</o> オプションを使ってください。
パターンの評価結果が空文字列になった場合には、最後に成功した正規表現が
代わりに使われます。
これについてさらに詳しくは、L<perlre> を参照してください。
C<use locale> が有効の場合の議論については L<perllocale> を参照して下さい。

=begin original

Options are:

=end original

オプションには以下のものがあります:

=begin original

    e	Evaluate the right side as an expression.
    g	Replace globally, i.e., all occurrences.
    i	Do case-insensitive pattern matching.
    m	Treat string as multiple lines.
    o	Compile pattern only once.
    s	Treat string as single line.
    x	Use extended regular expressions.

=end original

    e   式の右側の評価を行なう
    g   グローバルな置換、つまり見つかったものすべて
    i   大文字、小文字を区別しないで検索
    m   文字列を複数行として扱う
    o   パターンのコンパイルを 1 度だけにする
    s   文字列を単一行として扱う
    x   拡張正規表現を使用する

=begin original

Any non-alphanumeric, non-whitespace delimiter may replace the
slashes.  If single quotes are used, no interpretation is done on the
replacement string (the C</e> modifier overrides this, however).  Unlike
Perl 4, Perl 5 treats backticks as normal delimiters; the replacement
text is not evaluated as a command.  If the
PATTERN is delimited by bracketing quotes, the REPLACEMENT has its own
pair of quotes, which may or may not be bracketing quotes, e.g.,
C<s(foo)(bar)> or C<< s<foo>/bar/ >>.  A C</e> will cause the
replacement portion to be treated as a full-fledged Perl expression
and evaluated right then and there.  It is, however, syntax checked at
compile-time. A second C<e> modifier will cause the replacement portion
to be C<eval>ed before being run as a Perl expression.

=end original

英数字、空白ではない任意の区切り文字で、スラッシュを
置き換えることができます。
先に述べたように、シングルクォートを使うと
置換文字列での展開はされません (C</e>修飾子を使えば可能です)。
Perl 4 と違って、 Perl 5 はバッククォートを通常のデリミタとして扱います。
置換テキストはコマンドとして評価されません。
PATTERN を括弧類で括った場合には、
REPLACEMENT 用にもう一組の区切り文字を用意します。
これは、括弧類であっても、なくてもかまいません。
例: C<s(foo)(bar)> や C<< s<foo>/bar/ >>。
C</e> は置換文字列を完全な Perl の式として扱い、その場所で直ちに解釈します。
しかし、これはコンパイル時に構文チェックされます。
二番目の C<e> 修飾子を指定すると、置換部分がまず Perl の式として
C<eval> されます。

=begin original

Examples:

=end original

例:

    s/\bgreen\b/mauve/g;		# don't change wintergreen

    $path =~ s|/usr/bin|/usr/local/bin|;

    s/Login: $foo/Login: $bar/; # run-time pattern

    ($foo = $bar) =~ s/this/that/;	# copy first, then change

    $count = ($paragraph =~ s/Mister\b/Mr./g);  # get change-count

    $_ = 'abc123xyz';
    s/\d+/$&*2/e;		# yields 'abc246xyz'
    s/\d+/sprintf("%5d",$&)/e;	# yields 'abc  246xyz'
    s/\w/$& x 2/eg;		# yields 'aabbcc  224466xxyyzz'

    s/%(.)/$percent{$1}/g;	# change percent escapes; no /e
    s/%(.)/$percent{$1} || $&/ge;	# expr now, so /e
    s/^=(\w+)/&pod($1)/ge;	# use function call

    # expand variables in $_, but dynamics only, using
    # symbolic dereferencing
    s/\$(\w+)/${$1}/g;

    # Add one to the value of any numbers in the string
    s/(\d+)/1 + $1/eg;

    # This will expand any embedded scalar variable
    # (including lexicals) in $_ : First $1 is interpolated
    # to the variable name, and then evaluated
    s/(\$\w+)/$1/eeg;

    # Delete (most) C comments.
    $program =~ s {
	/\*	# Match the opening delimiter.
	.*?	# Match a minimal number of characters.
	\*/	# Match the closing delimiter.
    } []gsx;

    s/^\s*(.*?)\s*$/$1/;	# trim whitespace in $_, expensively

    for ($variable) {		# trim whitespace in $variable, cheap
	s/^\s+//;
	s/\s+$//;
    }

    s/([^ ]*) *([^ ]*)/$2 $1/;	# reverse 1st two fields

=begin original

Note the use of $ instead of \ in the last example.  Unlike
B<sed>, we use the \<I<digit>> form in only the left hand side.
Anywhere else it's $<I<digit>>.

=end original

最後の例で \ の代わりに $ を使っているのに注意してください。
B<sed> と違って、\<I<数字>> の形式はパターンの方でのみ使用できます。
その他の場所では、$<I<数字>> を使います。

=begin original

Occasionally, you can't use just a C</g> to get all the changes
to occur that you might want.  Here are two common cases:

=end original

ときには、C</g> を付けるだけでは、あなたが望んでいるような形で
すべてを変更することができないことがあります。
2 つ例を示します:

    # put commas in the right places in an integer
    1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;  

    # expand tabs to 8-column spacing
    1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;

=item tr/SEARCHLIST/REPLACEMENTLIST/cds
X<tr> X<y> X<transliterate> X</c> X</d> X</s>

=item y/SEARCHLIST/REPLACEMENTLIST/cds

=begin original

Transliterates all occurrences of the characters found in the search list
with the corresponding character in the replacement list.  It returns
the number of characters replaced or deleted.  If no string is
specified via the =~ or !~ operator, the $_ string is transliterated.  (The
string specified with =~ must be a scalar variable, an array element, a
hash element, or an assignment to one of those, i.e., an lvalue.)

=end original

検索リスト (SEARCHLIST) に含まれる文字を、対応する置換リスト
(REPLACEMENTLIST) の文字に変換します。
置換または削除が行なわれた、文字数を返します。
=~ 演算子や =! 演算子で文字列が指定されていなければ、$_ の文字列が変換されます。
(=~ で指定される文字列は、スカラ変数、配列要素、ハッシュ要素、
あるいはこれらへの代入式といった左辺値でなければなりません。)

=begin original

A character range may be specified with a hyphen, so C<tr/A-J/0-9/> 
does the same replacement as C<tr/ACEGIBDFHJ/0246813579/>.
For B<sed> devotees, C<y> is provided as a synonym for C<tr>.  If the
SEARCHLIST is delimited by bracketing quotes, the REPLACEMENTLIST has
its own pair of quotes, which may or may not be bracketing quotes,
e.g., C<tr[A-Z][a-z]> or C<tr(+\-*/)/ABCD/>.

=end original

文字の範囲はハイフンを使って指定できます。
C<tr/A-J/0-9/> は C<tr/ACEGIBDFHJ/0246813579/> と同じ置換を行います。
B<sed> の信仰者のために C<y> が C<tr> の同義語として提供されています。
SEARCHLIST を括弧類で括った場合には、
REPLACEMENTLIST 用に、もう一組の区切り文字を用意します。
これは、括弧類であっても、なくてもかまいません。
例: C<tr[A-Z][a-z]> や C<tr(+\-*/)/ABCD/>。

=begin original

Note that C<tr> does B<not> do regular expression character classes
such as C<\d> or C<[:lower:]>.  The <tr> operator is not equivalent to
the tr(1) utility.  If you want to map strings between lower/upper
cases, see L<perlfunc/lc> and L<perlfunc/uc>, and in general consider
using the C<s> operator if you need regular expressions.

=end original

C<tr> は C<\d> や C<[:lower:]> といった正規表現文字クラスを
B<使わない> ことに注意してください。
C<tr> 演算子は tr(1) ユーティリティと等価ではありません。
文字列の大文字小文字をマップしたい場合は、
L<perlfunc/lc> と L<perlfunc/uc> を参照して下さい。
また正規表現が必要な場合には一般的に C<s> 演算子を使うことを
考慮してみてください。

=begin original

Note also that the whole range idea is rather unportable between
character sets--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabets of equal case (a-e, A-E),
or digits (0-4).  Anything else is unsafe.  If in doubt, spell out the
character sets in full.

=end original

範囲指定という考え方は文字セットが異なる場合はやや移植性に欠けることにも
注意してください -- そして同じ文字セットでも恐らく期待しているのとは違う
結果を引き起こすこともあります。
健全な原則としては、範囲の最初と最後をどちらもアルファベット
(大文字小文字も同じ)(a-e, A-E)にするか、どちらも数字にする(0-4)ことです。
それ以外は全て安全ではありません。
疑わしいときは、文字セットを完全に書き出してください。

=begin original

Options:

=end original

オプションは以下の通りです:

=begin original

    c	Complement the SEARCHLIST.
    d	Delete found but unreplaced characters.
    s	Squash duplicate replaced characters.

=end original

    c   SEARCHLIST を補集合にする
    d   見つかったが置換されなかった文字を削除する
    s   置換された文字が重なったときに圧縮する

=begin original

If the C</c> modifier is specified, the SEARCHLIST character set
is complemented.  If the C</d> modifier is specified, any characters
specified by SEARCHLIST not found in REPLACEMENTLIST are deleted.
(Note that this is slightly more flexible than the behavior of some
B<tr> programs, which delete anything they find in the SEARCHLIST,
period.) If the C</s> modifier is specified, sequences of characters
that were transliterated to the same character are squashed down
to a single instance of the character.

=end original

C</c> 修飾子が指定されると、SEARCHLIST には補集合が指定されたものと
解釈されます。
C</d> 修飾子が指定されると、SEARCHLIST に指定されて、
REPLACEMENTLIST に対応するものがない文字が削除されます。
(これは、SEARCHLIST で見つかったものを削除する、ただそれだけの、ある種の
B<tr> プログラムの動作よりと比べれば、いく分柔軟なものになっています。)
C</s> 修飾子が指定されると、同じ文字に文字変換された文字の並びを、
その文字 1 文字だけに圧縮します。　

=begin original

If the C</d> modifier is used, the REPLACEMENTLIST is always interpreted
exactly as specified.  Otherwise, if the REPLACEMENTLIST is shorter
than the SEARCHLIST, the final character is replicated till it is long
enough.  If the REPLACEMENTLIST is empty, the SEARCHLIST is replicated.
This latter is useful for counting characters in a class or for
squashing character sequences in a class.

=end original

C</d> 修飾子が使われると、REPLACEMENTLIST は、常に指定された通りに
解釈されます。
C</d> が指定されない場合で、REPLACEMENTLIST が SEARCHLIST よりも短いと、
同じ長さになるまで、REPLACEMENTLIST の最後の文字が
繰り返されているものとして扱われます。
REPLACEMENTLIST が空文字列でのときには、SEARCHLIST と同じになります。
後者は、ある文字クラスに含まれる文字数を数えるときや、
ある文字クラスの文字の並びを圧縮するようなときに便利です。

=begin original

Examples:

=end original

例:

    $ARGV[1] =~ tr/A-Z/a-z/;	# canonicalize to lower case

    $cnt = tr/*/*/;		# count the stars in $_

    $cnt = $sky =~ tr/*/*/;	# count the stars in $sky

    $cnt = tr/0-9//;		# count the digits in $_

    tr/a-zA-Z//s;		# bookkeeper -> bokeper

    ($HOST = $host) =~ tr/a-z/A-Z/;

    tr/a-zA-Z/ /cs;		# change non-alphas to single space

    tr [\200-\377]
       [\000-\177];		# delete 8th bit

=begin original

If multiple transliterations are given for a character, only the
first one is used:

=end original

複数の文字変換が一つの文字について指定されると、最初のものだけが使われます。

    tr/AAA/XYZ/

=begin original

will transliterate any A to X.

=end original

は A を X に変換します。

=begin original

Because the transliteration table is built at compile time, neither
the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote
interpolation.  That means that if you want to use variables, you
must use an eval():

=end original

変換テーブルはコンパイル時に作られるので、SEARCHLIST も
REPLACEMENTLIST もダブルクォート展開の対象とはなりません。
変数を使いたい場合には、eval() を使わなければならないということです:

    eval "tr/$oldlist/$newlist/";
    die $@ if $@;

    eval "tr/$oldlist/$newlist/, 1" or die $@;

=item <<EOF
X<here-doc> X<heredoc> X<here-document> X<<< << >>>

=begin original

A line-oriented form of quoting is based on the shell "here-document"
syntax.  Following a C<< << >> you specify a string to terminate
the quoted material, and all lines following the current line down to
the terminating string are the value of the item.  The terminating
string may be either an identifier (a word), or some quoted text.  If
quoted, the type of quotes you use determines the treatment of the
text, just as in regular quoting.  An unquoted identifier works like
double quotes.  There must be no space between the C<< << >> and
the identifier, unless the identifier is quoted.  (If you put a space it
will be treated as a null identifier, which is valid, and matches the first
empty line.)  The terminating string must appear by itself (unquoted and
with no surrounding whitespace) on the terminating line.

=end original

A line-oriented form of quoting is based on the shell "here-document"
syntax.  Following a C<< << >> you specify a string to terminate
the quoted material, and all lines following the current line down to
the terminating string are the value of the item.  The terminating
string may be either an identifier (a word), or some quoted text.  If
quoted, the type of quotes you use determines the treatment of the
text, just as in regular quoting.  An unquoted identifier works like
double quotes.  There must be no space between the C<< << >> and
the identifier, unless the identifier is quoted.  (If you put a space it
will be treated as a null identifier, which is valid, and matches the first
empty line.)  The terminating string must appear by itself (unquoted and
with no surrounding whitespace) on the terminating line.
(TBT)

       print <<EOF;
    The price is $Price.
    EOF

       print << "EOF"; # same as above
    The price is $Price.
    EOF

       print << `EOC`; # execute commands
    echo hi there
    echo lo there
    EOC

       print <<"foo", <<"bar"; # you can stack them
    I said foo.
    foo
    I said bar.
    bar

       myfunc(<< "THIS", 23, <<'THAT');
    Here's a line
    or two.
    THIS
    and here's another.
    THAT

=begin original

Just don't forget that you have to put a semicolon on the end
to finish the statement, as Perl doesn't know you're not going to
try to do this:

=end original

Just don't forget that you have to put a semicolon on the end
to finish the statement, as Perl doesn't know you're not going to
try to do this:
(TBT)

       print <<ABC
    179231
    ABC
       + 20;

=begin original

If you want your here-docs to be indented with the 
rest of the code, you'll need to remove leading whitespace
from each line manually:

=end original

If you want your here-docs to be indented with the 
rest of the code, you'll need to remove leading whitespace
from each line manually:
(TBT)

    ($quote = <<'FINIS') =~ s/^\s+//gm;
       The Road goes ever on and on, 
       down from the door where it began.
    FINIS

=begin original

If you use a here-doc within a delimited construct, such as in C<s///eg>,
the quoted material must come on the lines following the final delimiter.
So instead of

=end original

If you use a here-doc within a delimited construct, such as in C<s///eg>,
the quoted material must come on the lines following the final delimiter.
So instead of
(TBT)

    s/this/<<E . 'that'
    the other
    E
     . 'more '/eg;

=begin original

you have to write

=end original

以下のように書かなければなりません:

    s/this/<<E . 'that' 
     . 'more '/eg; 
    the other 
    E 

=begin original

If the terminating identifier is on the last line of the program, you
must be sure there is a newline after it; otherwise, Perl will give the
warning B<Can't find string terminator "END" anywhere before EOF...>.

=end original

If the terminating identifier is on the last line of the program, you
must be sure there is a newline after it; otherwise, Perl will give the
warning B<Can't find string terminator "END" anywhere before EOF...>.
(TBT)

=begin original

Additionally, the quoting rules for the identifier are not related to
Perl's quoting rules -- C<q()>, C<qq()>, and the like are not supported
in place of C<''> and C<"">, and the only interpolation is for backslashing
the quoting character:

=end original

Additionally, the quoting rules for the identifier are not related to
Perl's quoting rules -- C<q()>, C<qq()>, and the like are not supported
in place of C<''> and C<"">, and the only interpolation is for backslashing
the quoting character:
(TBT)

    print << "abc\"def";
    testing...
    abc"def

=begin original

Finally, quoted strings cannot span multiple lines.  The general rule is
that the identifier must be a string literal.  Stick with that, and you
should be safe.

=end original

Finally, quoted strings cannot span multiple lines.  The general rule is
that the identifier must be a string literal.  Stick with that, and you
should be safe.
(TBT)

=back

=head2 Gory details of parsing quoted constructs
X<quote, gory details>

(クォートされた構造のパースに関する詳細)

=begin original

When presented with something that might have several different
interpretations, Perl uses the B<DWIM> (that's "Do What I Mean")
principle to pick the most probable interpretation.  This strategy
is so successful that Perl programmers often do not suspect the
ambivalence of what they write.  But from time to time, Perl's
notions differ substantially from what the author honestly meant.

=end original

何か複数の解釈が可能な表現があった場合、Perl は最も確からしい解釈を
選択するために B<DWIM> ("Do What I Mean")原則を使います。
この戦略は非常に成功したので、Perl プログラマはしばしば
自分が書いたものの矛盾を疑いません。
しかし時間がたつにつれて、Perl の概念は作者が本当に意味していたものから
かなり変わりました。

=begin original

This section hopes to clarify how Perl handles quoted constructs.
Although the most common reason to learn this is to unravel labyrinthine
regular expressions, because the initial steps of parsing are the
same for all quoting operators, they are all discussed together.

=end original

この章では Perl がどのようにクォートされた構造を扱うかを
明確にしようと思います。
これを学ぼうとする最もよくある理由は正規表現の迷宮をほぐすためですが、
パースの初期ステップは全てのクォート演算子で同じなので、全て同時に扱います。

=begin original

The most important Perl parsing rule is the first one discussed
below: when processing a quoted construct, Perl first finds the end
of that construct, then interprets its contents.  If you understand
this rule, you may skip the rest of this section on the first
reading.  The other rules are likely to contradict the user's
expectations much less frequently than this first one.

=end original

Perl のパースに関するルールで最も重要なものは以下で述べているうち
最初のものです。
つまり、クォートされた構造を処理するときは、Perl はまずその構造の
最後を探して、それから中身を解釈します。
このルールがわかれば、とりあえずはこの章の残りは読み飛ばしてもかまいません。
その他のルールは最初のルールに比べてユーザーの予想に反する頻度は
はるかに少ないです。

=begin original

Some passes discussed below are performed concurrently, but because
their results are the same, we consider them individually.  For different
quoting constructs, Perl performs different numbers of passes, from
one to five, but these passes are always performed in the same order.

=end original

以下で議論するパスには同時に実行されるものもありますが、
結果は同じことなので、別々に考えることにします。
クォート構造の種類によって、Perl が実行するパスの数は
1 から 5 まで異なりますが、これらのパスは常に同じ順番で実行されます。

=over 4

=item Finding the end

(最後を探す)

=begin original

The first pass is finding the end of the quoted construct, whether
it be a multicharacter delimiter C<"\nEOF\n"> in the C<<<EOF>
construct, a C</> that terminates a C<qq//> construct, a C<]> which
terminates C<qq[]> construct, or a C<< > >> which terminates a
fileglob started with C<< < >>.

=end original

最初のパスはクォートされた構造の最後を探すことです。
C<<<EOF> 構造の複数文字デリミタである C<"\nEOF\n">、
C<qq//> 構造の終わりである C</>、
C<qq[]> 構造の終わりである C<]>、
C<< < >> で始まるファイルグロブの終わりである C<< > >> などです。

=begin original

When searching for single-character non-pairing delimiters, such
as C</>, combinations of C<\\> and C<\/> are skipped.  However,
when searching for single-character pairing delimiter like C<[>,
combinations of C<\\>, C<\]>, and C<\[> are all skipped, and nested
C<[>, C<]> are skipped as well.  When searching for multicharacter
delimiters, nothing is skipped.

=end original

C</>のように、1 文字でペアでないデリミタを探す場合、
C<\\> と C<\/> を読み飛ばします。
しかし、C<[>のように 1 文字でペアになるデリミタの場合、
C<\\>, C<\]>, C<\[> を読み飛ばし、
さらにネストした C<[>, C<]> も読み飛ばします。
複数文字のデリミタの場合、何も読み飛ばしません。

=begin original

For constructs with three-part delimiters (C<s///>, C<y///>, and
C<tr///>), the search is repeated once more.

=end original

3 つのデリミタからなる構造 (C<s///>, C<y///>, C<tr///>) の場合、
検索はもう一度繰り返されます。

=begin original

During this search no attention is paid to the semantics of the construct.
Thus:

=end original

検索する間、構造の文脈は考慮しません。従って、

    "$hash{"$foo/$bar"}"

=begin original

or:

=end original

や、

    m/ 
      bar	# NOT a comment, this slash / terminated m//!
     /x

=begin original

do not form legal quoted expressions.   The quoted part ends on the
first C<"> and C</>, and the rest happens to be a syntax error.
Because the slash that terminated C<m//> was followed by a C<SPACE>,
the example above is not C<m//x>, but rather C<m//> with no C</x>
modifier.  So the embedded C<#> is interpreted as a literal C<#>.

=end original

は正しいクォート表現ではありません。
クォートは最初の C<"> や C</> で終わりとなり、
残りの部分は文法エラーとなります。
C<m//> を終わらせているスラッシュの次に来ているのが C<空白> なので、
上の例では C<m//x> ではなく、C</x> なしの C<m//> となります。
従って、中にある C<#> はリテラルな C<#> として扱われます。

=begin original

Also no attention is paid to C<\c\> during this search.
Thus the second C<\> in C<qq/\c\/> is interpreted as a part of C<\/>,
and the following C</> is not recognized as a delimiter.
Instead, use C<\034> or C<\x1c> at the end of quoted constructs.

=end original

Also no attention is paid to C<\c\> during this search.
Thus the second C<\> in C<qq/\c\/> is interpreted as a part of C<\/>,
and the following C</> is not recognized as a delimiter.
Instead, use C<\034> or C<\x1c> at the end of quoted constructs.
(TBT)

=item Removal of backslashes before delimiters

(デリミタの前のバックスラッシュの削除)

=begin original

During the second pass, text between the starting and ending
delimiters is copied to a safe location, and the C<\> is removed
from combinations consisting of C<\> and delimiter--or delimiters,
meaning both starting and ending delimiters will should these differ.
This removal does not happen for multi-character delimiters.
Note that the combination C<\\> is left intact, just as it was.

=end original

第二のパスとして、開始デリミタと終了デリミタの間のテキストは
安全な場所にコピーされ、C<\> とデリミタの組み合わせから
C<\> を削除します。
開始デリミタと終了デリミタが異なる場合はその両方に対してです。
この削除は複数文字デリミタに対しては行われません。
今までと同様、C<\\> はそのまま残されることに注意してください。

=begin original

Starting from this step no information about the delimiters is
used in parsing.

=end original

このステップの開始から、デリミタに関する情報は一切パースには
使われません。

=item Interpolation
X<interpolation>

(文字変換)

=begin original

The next step is interpolation in the text obtained, which is now
delimiter-independent.  There are four different cases.

=end original

次のステップは、得られた(デリミタに依存しない)テキストに対する文字変換です。
4 つのケースがあります。

=over 4

=item C<<<'EOF'>, C<m''>, C<s'''>, C<tr///>, C<y///>

=begin original

No interpolation is performed.

=end original

文字変換は行われません。

=item C<''>, C<q//>

=begin original

The only interpolation is removal of C<\> from pairs C<\\>.

=end original

C<\\> の組における C<\> の削除のみが行われます。

=item C<"">, C<``>, C<qq//>, C<qx//>, C<< <file*glob> >>

=begin original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l> (possibly paired with C<\E>) are
converted to corresponding Perl constructs.  Thus, C<"$foo\Qbaz$bar">
is converted to C<$foo . (quotemeta("baz" . $bar))> internally.
The other combinations are replaced with appropriate expansions.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l> (おそらくは C<\E> との組)は
対応する Perl 構造に変換されます。
従って、C<"$foo\Qbaz$bar"> は内部的に
C<$foo . (quotemeta("baz" . $bar))> に変換されます。
その他の組み合わせは適切な拡張に置換されます。

=begin original

Let it be stressed that I<whatever falls between C<\Q> and C<\E>>
is interpolated in the usual way.  Something like C<"\Q\\E"> has
no C<\E> inside.  instead, it has C<\Q>, C<\\>, and C<E>, so the
result is the same as for C<"\\\\E">.  As a general rule, backslashes
between C<\Q> and C<\E> may lead to counterintuitive results.  So,
C<"\Q\t\E"> is converted to C<quotemeta("\t")>, which is the same
as C<"\\\t"> (since TAB is not alphanumeric).  Note also that:

=end original

I<C<\Q> と C<\E> の間にある全てのもの> が通常の方法で展開されます。
C<"\Q\\E"> のようなものは内部にあるのは C<\E> ではなく、
C<\Q>, C<\\>, C<E> であるので、結果は C<"\\\\E"> と同じになります。
一般的なルールとして、C<\Q> と C<\E> の間にあるバックスラッシュは
直感に反した結果になります。
それで、C<"\Q\t\E"> は C<quotemeta("\t")> に変換され、これは(TAB は
英数字ではないので C<"\\\t"> と同じです。
以下のようなことにも注意してください:

  $str = '\t';
  return "\Q$str";

=begin original

may be closer to the conjectural I<intention> of the writer of C<"\Q\t\E">.

=end original

これは C<"\Q\t\E"> を書いた人の憶測上の I<意図> により近いです。

=begin original

Interpolated scalars and arrays are converted internally to the C<join> and
C<.> catenation operations.  Thus, C<"$foo XXX '@arr'"> becomes:

=end original

展開されたスカラと配列は内部で C<join> と C<.> の結合操作に変換されます。
従って、C<"$foo XXX '@arr'"> は以下のようになります:

  $foo . " XXX '" . (join $", @arr) . "'";

=begin original

All operations above are performed simultaneously, left to right.

=end original

上記の全ての操作は、左から右に同時に行われます。

=begin original

Because the result of C<"\Q STRING \E"> has all metacharacters
quoted, there is no way to insert a literal C<$> or C<@> inside a
C<\Q\E> pair.  If protected by C<\>, C<$> will be quoted to became
C<"\\\$">; if not, it is interpreted as the start of an interpolated
scalar.

=end original

C<"\Q STRING \E"> の結果は全てのメタ文字がクォートされているので、
C<\Q\E> の組の内側にリテラルの C<$> や C<@> を挿入する方法はありません。
C<\> によって守られている場合、C<$> はクォートされて C<"\\\$"> と
なります。
そうでない場合、これは展開されるスカラ変数の開始として解釈されます。

=begin original

Note also that the interpolation code needs to make a decision on
where the interpolated scalar ends.  For instance, whether 
C<< "a $b -> {c}" >> really means:

=end original

展開コードは、展開するスカラ変数がどこで終わるかを決定する必要が
あることにも注意してください。
例えば、C<< "a $b -> {c}" >> が実際には以下のようになるか:

  "a " . $b . " -> {c}";

=begin original

or:

=end original

以下のようになるかです:

  "a " . $b -> {c};

=begin original

Most of the time, the longest possible text that does not include
spaces between components and which contains matching braces or
brackets.  because the outcome may be determined by voting based
on heuristic estimators, the result is not strictly predictable.
Fortunately, it's usually correct for ambiguous cases.

=end original

ほとんどの場合、要素と、マッチする中かっこや大かっこの間に空白を含まない、
最も長いテキストになります。
出力は発見的な推定器をよる投票によって決定されるので、結果は厳密には
予測できません。
幸い、紛らわしい場合でも普通は正しいです。

=item C<?RE?>, C</RE/>, C<m/RE/>, C<s/RE/foo/>, 

=begin original

Processing of C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, and interpolation
happens (almost) as with C<qq//> constructs, but the substitution
of C<\> followed by RE-special chars (including C<\>) is not
performed.  Moreover, inside C<(?{BLOCK})>, C<(?# comment )>, and
a C<#>-comment in a C<//x>-regular expression, no processing is
performed whatsoever.  This is the first step at which the presence
of the C<//x> modifier is relevant.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l> の処理と展開が C<qq//> 構造と(ほとんど)
同じように起こりますが, C<\> の後に正規表現の特殊文字(C<\> を含みます)が
続く場合の置換は行われません。
さらに、C<(?{BLOCK})>, C<(?# comment )>, C<//x> 正規表現での C<#> の
コメントの中では、どのような処理も行われません。
これは C<//x> 修飾子が影響を与える最初のステップです。

=begin original

Interpolation has several quirks: C<$|>, C<$(>, and C<$)> are not
interpolated, and constructs C<$var[SOMETHING]> are voted (by several
different estimators) to be either an array element or C<$var>
followed by an RE alternative.  This is where the notation
C<${arr[$bar]}> comes handy: C</${arr[0-9]}/> is interpreted as
array element C<-9>, not as a regular expression from the variable
C<$arr> followed by a digit, which would be the interpretation of
C</$arr[0-9]/>.  Since voting among different estimators may occur,
the result is not predictable.

=end original

展開ではいくつか特殊な動作をします: C<$|>, C<$(>, C<$)> は展開されず、
C<$var[SOMETHING]> は(いくつかの異なる推定器によって)配列の要素か
C<$var> の後に正規表現が続いているのかが投票されます。
これは C<${arr[$bar]}> が便利になるところです: C</${arr[0-9]}/> は
配列要素 C<-9> として解釈され、C</$arr[0-9]/> の場合のように C<$arr> の後に
数値が続いているような正規表現としては解釈されません。
異なった推定器によって投票されることがあるので、結果は予測できません。

=begin original

It is at this step that C<\1> is begrudgingly converted to C<$1> in
the replacement text of C<s///> to correct the incorrigible
I<sed> hackers who haven't picked up the saner idiom yet.  A warning
is emitted if the C<use warnings> pragma or the B<-w> command-line flag
(that is, the C<$^W> variable) was set.

=end original

このステップでは、より健全な文法をまだ導入していない、手に負えない I<sed>
ハッカーのために、C<s///> の置換テキストの中にある C<\1> を、しぶしぶながら
C<$1> に変換します。
C<use warnings> プラグマやコマンドラインオプション B<-w> (これは C<$^W>
変数です) がセットされていると警告が生成されます。

=begin original

The lack of processing of C<\\> creates specific restrictions on
the post-processed text.  If the delimiter is C</>, one cannot get
the combination C<\/> into the result of this step.  C</> will
finish the regular expression, C<\/> will be stripped to C</> on
the previous step, and C<\\/> will be left as is.  Because C</> is
equivalent to C<\/> inside a regular expression, this does not
matter unless the delimiter happens to be character special to the
RE engine, such as in C<s*foo*bar*>, C<m[foo]>, or C<?foo?>; or an
alphanumeric char, as in:

=end original

C<\\> を処理しないことにより、後処理したテキストに特定の制限があります。
デリミタが C</> の場合、このステップの結果として C<\/> を得ることは
できません。
C</> は正規表現を終わらせ、C<\/> は前のステップで C</> に展開され、
C<\\/> はそのまま残されます。
C</> は正規表現の中では C<\/> と等価なので、これはたまたまデリミタが
正規検索エンジンにとって特別な文字の場合、つまり C<s*foo*bar*>,
C<m[foo]>, C<?foo?> のような場合、あるいは以下のように英数字でなければ、
問題にはなりません:

  m m ^ a \s* b mmx;

=begin original

In the RE above, which is intentionally obfuscated for illustration, the
delimiter is C<m>, the modifier is C<mx>, and after backslash-removal the
RE is the same as for C<m/ ^ a \s* b /mx>.  There's more than one 
reason you're encouraged to restrict your delimiters to non-alphanumeric,
non-whitespace choices.

=end original

上記の正規表現では、説明のために意図的にわかりにくくしていますが、
デリミタは C<m> で、修飾子は C<mx> で、バックスラッシュを取り除いた後の
正規表現は C<m/ ^ a \s* b /mx> と同じです。
デリミタを英数字や空白でないものに制限するべきである理由は複数あります。

=back

=begin original

This step is the last one for all constructs except regular expressions,
which are processed further.

=end original

これは正規表現以外の全ての構造にとって最後のステップです。
正規表現はさらに処理が続きます。

=item Interpolation of regular expressions
X<regexp, interpolation>

(正規表現の文字変換)

=begin original

Previous steps were performed during the compilation of Perl code,
but this one happens at run time--although it may be optimized to
be calculated at compile time if appropriate.  After preprocessing
described above, and possibly after evaluation if catenation,
joining, casing translation, or metaquoting are involved, the
resulting I<string> is passed to the RE engine for compilation.

=end original

以前のステップは Perl コードのコンパイル中に実行されますが、
これは実行時に起こります -- しかし、もし適切ならコンパイル時に
計算できるように最適化されることもあります。
上記の前処理の後、そして必要なら連結、結合、大文字小文字変換、
メタクォート化が行われた後、結果の I<文字列> がコンパイルのために
正規表現エンジンに渡されます。

=begin original

Whatever happens in the RE engine might be better discussed in L<perlre>,
but for the sake of continuity, we shall do so here.

=end original

正規表現エンジンで起こることについては L<perlre> で議論した方が
よいでしょうが、継続性のために、ここでそれを行います。

=begin original

This is another step where the presence of the C<//x> modifier is
relevant.  The RE engine scans the string from left to right and
converts it to a finite automaton.

=end original

これも C<//x> 修飾子の存在が関連するステップの一つです。
正規表現エンジンは文字列を左から右にスキャンして、有限状態オートマトンに
変換します。

=begin original

Backslashed characters are either replaced with corresponding
literal strings (as with C<\{>), or else they generate special nodes
in the finite automaton (as with C<\b>).  Characters special to the
RE engine (such as C<|>) generate corresponding nodes or groups of
nodes.  C<(?#...)> comments are ignored.  All the rest is either
converted to literal strings to match, or else is ignored (as is
whitespace and C<#>-style comments if C<//x> is present).

=end original

バックスラッシュ付きの文字は(C<\{> のように)対応するリテラル文字列に
置換されるか、あるいは(C<\b> のように)有限状態オートマトンの特別な
ノードを生成します。
(C<|> のような)正規表現エンジンにとって特別な文字は対応するノードか
ノードのグループを生成します。
残りの全てはマッチするリテラル文字列に変換されるか、そうでなければ
(C<//x> が指定された時の空白と C<#> スタイルのコメントと同様に)
無視されます。

=begin original

Parsing of the bracketed character class construct, C<[...]>, is
rather different than the rule used for the rest of the pattern.
The terminator of this construct is found using the same rules as
for finding the terminator of a C<{}>-delimited construct, the only
exception being that C<]> immediately following C<[> is treated as
though preceded by a backslash.  Similarly, the terminator of
C<(?{...})> is found using the same rules as for finding the
terminator of a C<{}>-delimited construct.

=end original

文字クラス構造 C<[...]> のパースは他のパターンとはルールが異なります。
この構造の終端は C<{}> でデリミタされた構造の終端を検索するのと同じルールで
検索されます; 唯一の例外は、C<[> の直後の C<]> はバックスラッシュが
先行しているものとして扱われます。
同様に、C<(?{...})> の終端は C<{}> でデリミタされた構造の終端を
検索されるのと同じルールで検索されます。

=begin original

It is possible to inspect both the string given to RE engine and the
resulting finite automaton.  See the arguments C<debug>/C<debugcolor>
in the C<use L<re>> pragma, as well as Perl's B<-Dr> command-line
switch documented in L<perlrun/"Command Switches">.

=end original

正規表現に与えられる文字列と、結果としての有限状態オートマトンの両方を
検査できます。
C<use L<re>> プラグマの C<debug>/C<debugcolor> 引数と、
L<perlrun/"Command Switches"> に記述されている B<-Dr> コマンドライン
オプションを参照してください。

=item Optimization of regular expressions
X<regexp, optimization>

(正規表現の最適化)

=begin original

This step is listed for completeness only.  Since it does not change
semantics, details of this step are not documented and are subject
to change without notice.  This step is performed over the finite
automaton that was generated during the previous pass.

=end original

このステップは完全性のためだけにリストされています。
これは意味論的には変化がないので、このステップの詳細は文書化されておらず、
将来予告なしに変更されることがあります。
このステップはここまでの処理で生成された有限オートマトンに対して
適用されます。

=begin original

It is at this stage that C<split()> silently optimizes C</^/> to
mean C</^/m>.

=end original

C<split()> で C</^/> を暗黙に C</^/m> に最適化するのもこのステップです。

=back

=head2 I/O Operators
X<operator, i/o> X<operator, io> X<io> X<while> X<filehandle>
X<< <> >> X<@ARGV>

(I/O 演算子)

=begin original

There are several I/O operators you should know about.

=end original

知っておいた方がよい I/O 演算子もいくつかあります。

=begin original

A string enclosed by backticks (grave accents) first undergoes
double-quote interpolation.  It is then interpreted as an external
command, and the output of that command is the value of the
backtick string, like in a shell.  In scalar context, a single string
consisting of all output is returned.  In list context, a list of
values is returned, one per line of output.  (You can set C<$/> to use
a different line terminator.)  The command is executed each time the
pseudo-literal is evaluated.  The status value of the command is
returned in C<$?> (see L<perlvar> for the interpretation of C<$?>).
Unlike in B<csh>, no translation is done on the return data--newlines
remain newlines.  Unlike in any of the shells, single quotes do not
hide variable names in the command from interpretation.  To pass a
literal dollar-sign through to the shell you need to hide it with a
backslash.  The generalized form of backticks is C<qx//>.  (Because
backticks always undergo shell expansion as well, see L<perlsec> for
security concerns.)
X<qx> X<`> X<``> X<backtick> X<glob>

=end original

バッククォートで括られた文字列は、まず、ダブルクォート補完のように
変数の展開が行なわれます。
その後、シェルでの場合と同じように、外部コマンドとして解釈され、
そのコマンドの出力がこのバッククォート文字列の値となります。
スカラーコンテキストでは、出力すべてを含む一個の文字列が返されます。
リストコンテキストでは、出力の 1 行 1 行が個々の要素となるリストが返されます。
(C<$/> を設定すれば、行の終わりを示す文字を変えることができます。)
コマンドは、この擬似リテラルが評価されるごとに実行されます。
コマンドのステータス値は C<$?> に返されます (C<$?> の解釈については、
L<perlvar> を参照してください)。
B<csh> での場合とは違って、結果のデータに対する変換は行なわれず、
改行は改行のままです。
どのシェルとも違って、シングルクォートがコマンド中の変数名を
解釈させないようにすることはありません。
シェルにリテラルなドル記号を渡すには、バックスラッシュで
エスケープしなければなりません。
バッククォートの一般形は、C<qx//> です。
(バッククォートは常にシェル展開されます。
セキュリティに関しては L<perlsec> を参照して下さい)

=begin original

In scalar context, evaluating a filehandle in angle brackets yields
the next line from that file (the newline, if any, included), or
C<undef> at end-of-file or on error.  When C<$/> is set to C<undef>
(sometimes known as file-slurp mode) and the file is empty, it
returns C<''> the first time, followed by C<undef> subsequently.

=end original

スカラーコンテキストで山括弧の中のファイルハンドルを評価すると、
そのファイルから、次の行を読み込むことになります
(改行があればそれも含まれます)。
ファイルの最後またはエラーの場合は C<undef> を返します。
C<$/> が C<undef> に設定されている場合(ファイル吸い込みモードと呼ばれます)
でファイルが空の場合、
最初は C<''> を返し、次は C<undef> を返します。

=begin original

Ordinarily you must assign the returned value to a variable, but
there is one situation where an automatic assignment happens.  If
and only if the input symbol is the only thing inside the conditional
of a C<while> statement (even if disguised as a C<for(;;)> loop),
the value is automatically assigned to the global variable $_,
destroying whatever was there previously.  (This may seem like an
odd thing to you, but you'll use the construct in almost every Perl
script you write.)  The $_ variable is not implicitly localized.
You'll have to put a C<local $_;> before the loop if you want that
to happen.

=end original

通常は、返された値を変数に代入しなければなりませんが、自動的に
代入される場合が 1 つだけあります。
この入力シンボルが、while 文(C<for(;;)> の形になっていたとしても)の条件式中に
単独で現れた場合だけは、その値が自動的にグローバル変数 $_ に代入されます。
以前の値は破壊されます。
(これは、奇妙に思えるかもしれませんが、ほとんどすべての Perl スクリプトで
これが必要になることでしょう。)
$_ 変数は暗黙にはローカル化されません。
そうしたい場合はループの前に C<local $_;> と書く必要があります。

=begin original

The following lines are equivalent:

=end original

以下のものは、お互いに同値なものです:

    while (defined($_ = <STDIN>)) { print; }
    while ($_ = <STDIN>) { print; }
    while (<STDIN>) { print; }
    for (;<STDIN>;) { print; }
    print while defined($_ = <STDIN>);
    print while ($_ = <STDIN>);
    print while <STDIN>;

=begin original

This also behaves similarly, but avoids $_ :

=end original

以下は同様の振る舞いをしますが、$_ を使いません:

    while (my $line = <STDIN>) { print $line }    

=begin original

In these loop constructs, the assigned value (whether assignment
is automatic or explicit) is then tested to see whether it is
defined.  The defined test avoids problems where line has a string
value that would be treated as false by Perl, for example a "" or
a "0" with no trailing newline.  If you really mean for such values
to terminate the loop, they should be tested for explicitly:

=end original

これらのループ構造の中で、代入された値は (代入が自動か明示的かに関わりなく)
定義されているかどうかを見るためにテストされます。
定義テストは、行が Perl にとって偽となる文字列値を持っているかどうかの
問題を避けます。例えば newline のついていない  "" や "0" です。
もし本当にこのような値でループを終了させたいときは、
以下のように明示的にテストするべきです:

    while (($_ = <STDIN>) ne '0') { ... }
    while (<STDIN>) { last unless $_; ... }

=begin original

In other boolean contexts, C<< <I<filehandle>> >> without an
explicit C<defined> test or comparison elicit a warning if the 
C<use warnings> pragma or the B<-w>
command-line switch (the C<$^W> variable) is in effect.

=end original

その他のブール値コンテキストでは、明示的な C<defined> や比較なしに
C<< <I<filehandle>> >> を使うと、C<use warnings> プラグマや
B<-w> コマンドラインスイッチ (C<$^W> 変数) が有効なときには、
警告を発生させます。

=begin original

The filehandles STDIN, STDOUT, and STDERR are predefined.  (The
filehandles C<stdin>, C<stdout>, and C<stderr> will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additional filehandles may be created with
the open() function, amongst others.  See L<perlopentut> and
L<perlfunc/open> for details on this.
X<stdin> X<stdout> X<sterr>

=end original

STDIN、STDOUT、STDERR というファイルハンドルは、あらかじめ定義されています。
(C<stdin>、C<stdout>、C<stderr> というファイルハンドルも、
ローカルな名前でこれらのグローバルな名前が見えなくなっている
パッケージを除けば、使用することができます。)
その他のファイルハンドルは、open() 関数などで作ることができます。
これに関する詳細については L<perlopentut> と L<perlfunc/open> を
参照して下さい。
X<stdin> X<stdout> X<sterr>

=begin original

If a <FILEHANDLE> is used in a context that is looking for
a list, a list comprising all input lines is returned, one line per
list element.  It's easy to grow to a rather large data space this
way, so use with care.

=end original

<FILEHANDLE> がリストを必要とするコンテキストで用いられると、
1 要素に 1 行の入力行すべてからなるリストが返されます。
これを使うと簡単にかなり大きなデータになってしまいますので、
注意を要します。

=begin original

<FILEHANDLE> may also be spelled C<readline(*FILEHANDLE)>.
See L<perlfunc/readline>.

=end original

<FILEHANDLE> は C<readline(*FILEHANDLE)> とも書けます。
L<perlfunc/readline> を参照して下さい。

=begin original

The null filehandle <> is special: it can be used to emulate the
behavior of B<sed> and B<awk>.  Input from <> comes either from
standard input, or from each file listed on the command line.  Here's
how it works: the first time <> is evaluated, the @ARGV array is
checked, and if it is empty, C<$ARGV[0]> is set to "-", which when opened
gives you standard input.  The @ARGV array is then processed as a list
of filenames.  The loop

=end original

ヌルファイルハンドル <> は特別で、B<sed> や B<awk> の動作を
エミュレートするために使われます。
<> からの入力は、標準入力からか、コマンドライン上に並べられた個々の
ファイルから行なわれます。
動作の概要は、以下のようになります。
最初に <> が評価されると、配列 @ARGV が調べられ、空であれば、
C<$ARGV[0]> に "-"を設定します。
これは、open されるとき標準入力となります。
その後、配列 @ARGV がファイル名のリストとして処理されます。

    while (<>) {
	...			# code for each line
    }

=begin original

is equivalent to the following Perl-like pseudo code:

=end original

は以下ののような Perl の擬似コードと等価です:

    unshift(@ARGV, '-') unless @ARGV;
    while ($ARGV = shift) {
	open(ARGV, $ARGV);
	while (<ARGV>) {
	    ...		# code for each line
	}
    }

=begin original

except that it isn't so cumbersome to say, and will actually work.
It really does shift the @ARGV array and put the current filename
into the $ARGV variable.  It also uses filehandle I<ARGV>
internally--<> is just a synonym for <ARGV>, which
is magical.  (The pseudo code above doesn't work because it treats
<ARGV> as non-magical.)

=end original

但し、わずらわしく書かなくても、動作します。
実際に @ARGV を shift しますし、その時点のファイル名を変数 $ARGV に
入れています。
また、内部的にファイルハンドル ARGV を使っていて、<> はマジカルな
<ARGV> の同義語となっています。
(上記の擬似コードは、<ARGV> を通常のものとして扱っているので、
うまく動作しません。)

=begin original

You can modify @ARGV before the first <> as long as the array ends up
containing the list of filenames you really want.  Line numbers (C<$.>)
continue as though the input were one big happy file.  See the example
in L<perlfunc/eof> for how to reset line numbers on each file.

=end original

最終的に、@ARGV に扱いたいと思っているファイル名が含まれるのであれば、
最初に <> を評価する前に @ARGV を変更することも可能です。
行番号 (C<$.>) は、入力ファイルがあたかも 1 つの大きなファイルで
あるかのように、続けてカウントされます。
個々のファイルごとにリセットする方法は、L<perlfunc/eof> の例を
参照してください。

=begin original

If you want to set @ARGV to your own list of files, go right ahead.  
This sets @ARGV to all plain text files if no @ARGV was given:

=end original

最初から @ARGV に自分でファイルのリストを設定してもかまいません。
以下は @ARGV が与えられなかったときに全てのテキストファイルを
@ARGV に設定します。

    @ARGV = grep { -f && -T } glob('*') unless @ARGV;

=begin original

You can even set them to pipe commands.  For example, this automatically
filters compressed arguments through B<gzip>:

=end original

ここにパイプコマンドを置くことも出来ます。
例えば、以下は圧縮された引数を自動的に B<gzip> のフィルタに通します:

    @ARGV = map { /\.(gz|Z)$/ ? "gzip -dc < $_ |" : $_ } @ARGV;

=begin original

If you want to pass switches into your script, you can use one of the
Getopts modules or put a loop on the front like this:

=end original

スクリプトにスイッチを渡したいのであれば、Getopts モジュールを
使うこともできますし、実際の処理の前にのようなループを置くこともできます。

    while ($_ = $ARGV[0], /^-/) {
	shift;
        last if /^--$/;
	if (/^-D(.*)/) { $debug = $1 }
	if (/^-v/)     { $verbose++  }
	# ...		# other switches
    }

    while (<>) {
	# ...		# code for each line
    }

=begin original

The <> symbol will return C<undef> for end-of-file only once.  
If you call it again after this, it will assume you are processing another 
@ARGV list, and if you haven't set @ARGV, will read input from STDIN.

=end original

シンボル <> がファイルの最後で C<undef> を返すのは一度きりです。
そのあとでもう一度呼び出すと、新たに別の @ARGV を処理するものとみなされ、
その時に @ARGV を設定しなおしていないと、STDIN からの入力を
読み込むことになります。

=begin original

If what the angle brackets contain is a simple scalar variable (e.g.,
<$foo>), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to the
same.  For example:

=end original

山括弧の中の文字列が (<$foo> のような) 単純スカラ変数であれば、
その変数が入力を行なうファイルハンドルの名前そのもの、名前への型グロブ、
名前へのリファレンスのいずれかを示しているとみなされます。

    $fh = \*STDIN;
    $line = <$fh>;

=begin original

If what's within the angle brackets is neither a filehandle nor a simple
scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.  This distinction is determined on syntactic
grounds alone.  That means C<< <$x> >> is always a readline() from
an indirect handle, but C<< <$hash{key}> >> is always a glob().
That's because $x is a simple scalar variable, but C<$hash{key}> is
not--it's a hash element.  Even C<< <$x > >> (note the extra space)
is treated as C<glob("$x ")>, not C<readline($x)>.

=end original

山括弧の中の文字列がファイルハンドルでもファイルハンドル名、型グロブ、
型グロブリファレンスのいずれかが入った単純スカラ変数でもなければ、
グロブを行なうファイル名のパターンと解釈され、コンテキストによって
ファイル名のリストか、そのリストの次のファイル名が返されます。
この区別は単に構文的に行われます。
C<< <$x> >> は常に間接ハンドルから readline() しますが、
C<< <$hash{key}> >> は常に glob() します。
$x は単純スカラー変数ですが、C<$hash{key}> は違う(ハッシュ要素)からです。
Even C<< <$x > >> (note the extra space)
is treated as C<glob("$x ")>, not C<readline($x)>.
(TBT)

=begin original

One level of double-quote interpretation is done first, but you can't
say C<< <$foo> >> because that's an indirect filehandle as explained
in the previous paragraph.  (In older versions of Perl, programmers
would insert curly brackets to force interpretation as a filename glob:
C<< <${foo}> >>.  These days, it's considered cleaner to call the
internal function directly as C<glob($foo)>, which is probably the right
way to have done it in the first place.)  For example:

=end original

まず、1 段階だけダブルクォート展開が行なわれますが、前の段落に書いた
間接ファイルハンドルと同じになる、C<< <$foo> >> のようには書けません。
(Perl の古いバージョンでは、ファイル名グロブと解釈させるために
C<< <${foo}> >> のように中括弧を入れていました。
最近ではより明確にするために、C<glob($foo)> と内部関数を
呼ぶこともできます。
おそらく、まず、こちらの方で試すのが正解でしょう。)
例:

    while (<*.c>) {
	chmod 0644, $_;
    }

=begin original

is roughly equivalent to:

=end original

はだいたい以下と等価です:

    open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
    while (<FOO>) {
	chomp;
	chmod 0644, $_;
    }

=begin original

except that the globbing is actually done internally using the standard
C<File::Glob> extension.  Of course, the shortest way to do the above is:

=end original

但し実際のグロブは内部的に標準の C<File::Glob> モジュールを使います。
もちろん、もっと簡単に以下のように書けます:

    chmod 0644, <*.c>;

=begin original

A (file)glob evaluates its (embedded) argument only when it is
starting a new list.  All values must be read before it will start
over.  In list context, this isn't important because you automatically
get them all anyway.  However, in scalar context the operator returns
the next value each time it's called, or C<undef> when the list has
run out.  As with filehandle reads, an automatic C<defined> is
generated when the glob occurs in the test part of a C<while>,
because legal glob returns (e.g. a file called F<0>) would otherwise
terminate the loop.  Again, C<undef> is returned only once.  So if
you're expecting a single value from a glob, it is much better to
say

=end original

(ファイル)グロブは新しいリストを開始するときにだけ(組み込みの)引数を
評価します。
全ての値は開始する前に読み込んでいなければなりません。
これはリストコンテキストでは、とにかく自動的に全てを取り込むので
重要ではありません。
しかし、スカラーコンテキストではこの演算子は呼び出された時の
次の値か、リストがなくなったときには C<undef> を返します。
ファイルハンドルを読み込む場合は、グロブが C<while> の条件部にある場合は
自動的な C<defined> が生成されます。
なぜならそうしないと、本来の glob の返り値 (F<0> というファイル) が
ループを終了させるからです。
ここでも、C<undef> は一度だけ返されます。
従って、もしグロブから一つの値だけを想定している場合、
以下のように書くことが:

    ($file) = <blurch*>;

=begin original

than

=end original

以下のように書くよりはるかに良いです:

    $file = <blurch*>;

=begin original

because the latter will alternate between returning a filename and
returning false.

=end original

なぜなら後者はファイル名を返す場合と偽を返す場合があるからです。

=begin original

If you're trying to do variable interpolation, it's definitely better
to use the glob() function, because the older notation can cause people
to become confused with the indirect filehandle notation.

=end original

変数変換に挑戦する場合、明らかに glob() 関数を使う方が良いです。
なぜなら古い表記は間接ファイルハンドル表記と混乱するかも知れないからです。

    @files = glob("$dir/*.[ch]");
    @files = glob($files[$i]);

=head2 Constant Folding
X<constant folding> X<folding>

(定数の畳み込み)

=begin original

Like C, Perl does a certain amount of expression evaluation at
compile time whenever it determines that all arguments to an
operator are static and have no side effects.  In particular, string
concatenation happens at compile time between literals that don't do
variable substitution.  Backslash interpolation also happens at
compile time.  You can say

=end original

C と同じように Perl でも、演算子に対するすべての引数がスタティックで、
副作用がないと判断できれば、コンパイル時に式の評価を行なってしまいます。
特に、変数置換の無いリテラルどうしの文字列連結はコンパイル時に行なわれます。
バックスラッシュの解釈もコンパイル時に行なわれます。

    'Now is the time for all' . "\n" .
	'good men to come to.'

=begin original

and this all reduces to one string internally.  Likewise, if
you say

=end original

と書いても、内部的に 1 つの文字列になります。同様に

    foreach $file (@filenames) {
	if (-s $file > 5 + 100 * 2**16) {  }
    }

=begin original

the compiler will precompute the number which that expression
represents so that the interpreter won't have to.

=end original

と書くとコンパイラは、式が表わす数値をあらかじめ計算しますので、
インタプリタで計算する必要がなくなっています。

=head2 No-ops
X<no-op> X<nop>

=begin original

Perl doesn't officially have a no-op operator, but the bare constants
C<0> and C<1> are special-cased to not produce a warning in a void
context, so you can for example safely do

=end original

Perl doesn't officially have a no-op operator, but the bare constants
C<0> and C<1> are special-cased to not produce a warning in a void
context, so you can for example safely do
(TBT)

    1 while foo();

=head2 Bitwise String Operators
X<operator, bitwise, string>

(ビット列演算子)

=begin original

Bitstrings of any size may be manipulated by the bitwise operators
(C<~ | & ^>).

=end original

任意のサイズのビット列はビット単位演算子(C<~ | & ^>)で操作できます。

=begin original

If the operands to a binary bitwise op are strings of different
sizes, B<|> and B<^> ops act as though the shorter operand had
additional zero bits on the right, while the B<&> op acts as though
the longer operand were truncated to the length of the shorter.
The granularity for such extension or truncation is one or more
bytes.

=end original

二項ビット単位演算子のオペランドが異なった長さの文字列だった場合、
B<|> と B<^> の演算子は短い側のオペランドの右側に追加のゼロが
ついているとみなします。
一方 B<&> 演算子は長い方のオペランドが短い方に切り詰められます。
この拡張や短縮の粒度はバイト単位です。

    # ASCII-based examples 
    print "j p \n" ^ " a h";        	# prints "JAPH\n"
    print "JA" | "  ph\n";          	# prints "japh\n"
    print "japh\nJunk" & '_____';   	# prints "JAPH\n";
    print 'p N$' ^ " E<H\n";		# prints "Perl\n";

=begin original

If you are intending to manipulate bitstrings, be certain that
you're supplying bitstrings: If an operand is a number, that will imply
a B<numeric> bitwise operation.  You may explicitly show which type of
operation you intend by using C<""> or C<0+>, as in the examples below.

=end original

ビット列を操作したい場合は、確実にビット列が渡されるようにしてください:
オペランドが数字の場合、B<数値> ビット単位演算を仮定します。
明示的に演算の型を指定するときには、以下の例のように
C<""> か C<0+> を使ってください。

    $foo =  150  |  105;	# yields 255  (0x96 | 0x69 is 0xFF)
    $foo = '150' |  105;	# yields 255
    $foo =  150  | '105';	# yields 255
    $foo = '150' | '105';	# yields string '155' (under ASCII)

    $baz = 0+$foo & 0+$bar;	# both ops explicitly numeric
    $biz = "$foo" ^ "$bar";	# both ops explicitly stringy

=begin original

See L<perlfunc/vec> for information on how to manipulate individual bits
in a bit vector.

=end original

ビットベクタの個々のビットをどのように操作するかの情報については
L<perlfunc/vec> を参照して下さい。

=head2 Integer Arithmetic
X<integer>

(整数演算)

=begin original

By default, Perl assumes that it must do most of its arithmetic in
floating point.  But by saying

=end original

デフォルトでは、Perl は演算を浮動小数で行なわなければならないものと
しています。
しかし、(もしそうしたいなら)

    use integer;

=begin original

you may tell the compiler that it's okay to use integer operations
(if it feels like it) from here to the end of the enclosing BLOCK.
An inner BLOCK may countermand this by saying

=end original

と書けば、その場所から現在の BLOCK の終わりまでは、整数演算を
行なってよいと、コンパイラに指示することができます。
内部の BLOCK で、

    no integer;

=begin original

which lasts until the end of that BLOCK.  Note that this doesn't
mean everything is only an integer, merely that Perl may use integer
operations if it is so inclined.  For example, even under C<use
integer>, if you take the C<sqrt(2)>, you'll still get C<1.4142135623731>
or so.

=end original

と書けば、その BLOCK の終わりまでは、指示を取り消すことになります。
これは全てを整数だけを使って処理することを意味するわけではないことに
注意してください。
これは単に Perl が整数を使いたいと思ったときに使うかもしれない、
というだけです。
例えば、C<use integer> の指定があっても、C<sqrt(2)> とすると、
C<1.4142135623731> といった結果が返ってきます。

=begin original

Used on numbers, the bitwise operators ("&", "|", "^", "~", "<<",
and ">>") always produce integral results.  (But see also 
L<Bitwise String Operators>.)  However, C<use integer> still has meaning for
them.  By default, their results are interpreted as unsigned integers, but
if C<use integer> is in effect, their results are interpreted
as signed integers.  For example, C<~0> usually evaluates to a large
integral value.  However, C<use integer; ~0> is C<-1> on twos-complement
machines.

=end original

数値を使う場合、ビット単位演算子 ("&", "|", "^", "~", "<<", ">>") は
常に整数の結果を生成します(但し L<Bitwise String Operators> も
参照して下さい)。
しかし、それでも C<use integer> は意味があります。
デフォルトでは、これらの結果は符号なし整数として解釈されますが、
C<use integer> が有効の場合は、符号付き整数として解釈されます。
例えば、C<~0> は通常大きな整数の値として評価されます。
しかし、C<use integer; ~0> は 2 の補数のマシンでは C<-1> になります。

=head2 Floating-point Arithmetic
X<floating-point> X<floating point> X<float> X<real>

(浮動小数点演算)

=begin original

While C<use integer> provides integer-only arithmetic, there is no
analogous mechanism to provide automatic rounding or truncation to a
certain number of decimal places.  For rounding to a certain number
of digits, sprintf() or printf() is usually the easiest route.
See L<perlfaq4>.

=end original

C<use integer> が整数演算を提供する一方、数を特定の桁で自動的に丸めたり
切り捨てたりする機構はありません。
数を丸めるには、sprintf() や printf() を使うのが一番簡単な方法です。
L<perlfaq4> を参照して下さい。

=begin original

Floating-point numbers are only approximations to what a mathematician
would call real numbers.  There are infinitely more reals than floats,
so some corners must be cut.  For example:

=end original

浮動小数点数は数学者が実数と呼ぶものの近似でしかありません。
実数は浮動小数点より無限に続くので、多少角が丸められます。
例:

    printf "%.20g\n", 123456789123456789;
    #        produces 123456789123456784

=begin original

Testing for exact equality of floating-point equality or inequality is
not a good idea.  Here's a (relatively expensive) work-around to compare
whether two floating-point numbers are equal to a particular number of
decimal places.  See Knuth, volume II, for a more robust treatment of
this topic.

=end original

浮動小数点数が等しいかどうかをちょうど同じかどうかで比較するのは
いいアイデアではありません。
以下に、二つの浮動小数点数が指定された桁まで等しいかどうかを
比較する(比較的重い)次善の策を示します。
この問題に関するより厳密な扱いについては Knuth, volume II を参照して下さい。

    sub fp_equal {
	my ($X, $Y, $POINTS) = @_;
	my ($tX, $tY);
	$tX = sprintf("%.${POINTS}g", $X);
	$tY = sprintf("%.${POINTS}g", $Y);
	return $tX eq $tY;
    }

=begin original

The POSIX module (part of the standard perl distribution) implements
ceil(), floor(), and other mathematical and trigonometric functions.
The Math::Complex module (part of the standard perl distribution)
defines mathematical functions that work on both the reals and the
imaginary numbers.  Math::Complex not as efficient as POSIX, but
POSIX can't work with complex numbers.

=end original

POSIX モジュール(Perl 標準配布パッケージの一部) は ceil(), floor() 及び
その他の数学関数や三角関数を実装しています。
Math::Complex モジュール(Perl 標準配布パッケージの一部)は
実数と虚数の両方で動作する数学関数を定義しています。
Math::Complex は POSIX ほど効率的ではありませんが、
POSIX は複素数は扱えません。

=begin original

Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.

=end original

金融アプリケーションにおける丸めは深刻な影響を与える可能性があり、
使用する丸めメソッドは指定された精度で行われるべきです。
このような場合、Perl が使用するシステム丸めを信用せず、
代わりに自分自身で丸め関数を実装するべきです。

=head2 Bigger Numbers
X<number, arbitrary precision>

(より大きな数)

=begin original

The standard Math::BigInt and Math::BigFloat modules provide
variable-precision arithmetic and overloaded operators, although
they're currently pretty slow. At the cost of some space and
considerable speed, they avoid the normal pitfalls associated with
limited-precision representations.

=end original

標準の Math::BigInt と Math::BigFloat モジュールは多倍長演算を提供し、
演算子をオーバーロードしますが、これらは現在のところかなり遅いです。
多少の領域とかなりの速度を犠牲にして、桁数が制限されていることによる
ありがちな落とし穴を避けることができます。

    use Math::BigInt;
    $x = Math::BigInt->new('123456789123456789');
    print $x * $x;

    # prints +15241578780673678515622620750190521

=begin original

There are several modules that let you calculate with (bound only by
memory and cpu-time) unlimited or fixed precision. There are also
some non-standard modules that provide faster implementations via
external C libraries.

=end original

(メモリと CPU 時間のみに依存する)無制限か固定の精度での計算ができる
モジュールがいくつかあります。
さらに外部 C ライブラリを使ってより速い実装を提供する
非標準のモジュールもあります。

=begin original

Here is a short, but incomplete summary:

=end original

以下は短いですが不完全なリストです。

=begin original

	Math::Fraction		big, unlimited fractions like 9973 / 12967
	Math::String		treat string sequences like numbers
	Math::FixedPrecision	calculate with a fixed precision
	Math::Currency		for currency calculations
	Bit::Vector		manipulate bit vectors fast (uses C)
	Math::BigIntFast	Bit::Vector wrapper for big numbers
	Math::Pari		provides access to the Pari C library
	Math::BigInteger	uses an external C library
	Math::Cephes		uses external Cephes C library (no big numbers)
	Math::Cephes::Fraction	fractions via the Cephes library
	Math::GMP		another one using an external C library

=end original

	Math::Fraction		9973 / 12967 のような、大きくて無制限の分数
	Math::String		文字列を数値のように扱う
	Math::FixedPrecision	固定精度で計算する
	Math::Currency		通貨の計算用
	Bit::Vector		(C を使って)ビットベクタを速く操作する
	Math::BigIntFast	大きな数のための Bit::Vector のラッパー
	Math::Pari		Pari C ライブラリへのアクセスを提供する
	Math::BigInteger	外部 C ライブラリを使う
	Math::Cephes		外部の Cephes C を使う(大きな数はなし)
	Math::Cephes::Fraction	Cephes ライブラリを使った分数
	Math::GMP		これも外部 C ライブラリを使う

=begin original

Choose wisely.

=end original

うまく選んでください。

=cut

