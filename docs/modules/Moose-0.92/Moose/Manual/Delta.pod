=encoding utf8

=pod

=head1 題名

Moose::Manual::Delta - Mooseの重要な変更点

=head1 本文

これは後方互換性の点で重要な、あるいは特筆に値するMooseの変更点をまとめたものです。F<Changes>ファイルのデータと重複しているのは本当ですが、ここではより詳しい情報や（あれば）対策を紹介するのがねらいです。

このドキュメントは、変化についていくのを助けるだけでなく、特定の機能をサポートする最低バージョンを調べるのにも使えます。問題に遭遇して解決策を見つけたけれどここには書かれていなかったとか、大事な機能を書き漏らしていると思ったら、パッチを送ってください。

=head1 バージョン0.90

=over 4

=item NativeトレートによるCodeRef用の委譲ヘルパー追加

詳細はL<Moose::Meta::Attribute::Native::Trait::Code>をご覧下さい。

=item $object->new() を非推奨化

Mooseはこの機能を長い間実装していましたが、ドキュメントはされていませんでしたし、またこれは良い習慣とは言えないと考えます。もし既存のオブジェクトから新規にオブジェクトを生成したい場合はC<< $object->clone >>のような代替コンストラクタを提供するほうが良いでしょう。

現在はC<< $object->new >> を使用すると警告が発せられますが、将来的にはこれはエラーとなります。

=item Mutable （変更可能）な親クラスを持つクラスについてC<make_immutable> を呼んでも警告しない

理論的にはこの警告は正しいはずですが、この処理の例外ケースがあまりに多く、正しくハンドルするのは難しいという結論に達しました。

=back

=head1 バージョン0.89_02

=over 4

=item L<List::Util> と L<List::MoreUtils>からの新規 Nativeトレートによるメソッド委譲

C<reduce>、 C<shuffle>、 C<uniq>、 それにC<natatime>を実装しました。

=item Moose::Exporter の with_caller 機能が非推奨化されました。

今後は C<with_meta> を使用してください。C<with_caller> は将来のリリースで警告を発するようになります。

=item Mutable （変更可能）な親クラスを持つクラスについてC<make_immutable>を行うと警告が発せられる

あるクラスを子クラスが変更不可状態になった後に変更するとインライン化のため誤作動を起こすことがあるため、この行為は危険です。このような状況はクラスの定義中に子クラスを呼び出したりするような状況では稀に起こることがあるため、このような警告は有効あと考えます。現状ではメタクラス（L<Class::MOP::Object>の子クラス）に関してはこのチェックは適用されません。

=back

=head1 バージョン0.89_01

L<Moose::Meta::Attribute::Native> が L<MooseX::AttributeHelpers>からMooseコアに組み込まれました。重要な変更点は以下の通りです：

=over 4

=item C<metaclass>ではなく、C<traits>

メソッドプロバイダーはトレートからしか利用できません。

=item C<provides>とC<curries>ではなく、C<handles>

C<provides> 構文はMooseコアのC<< handles => HASHREF >>構文のキーと値の位置が入れ替わっただけのものでした。これではわかりにくかったため、使用されるオプションはC<< handles => HASHREF >>に統一されました。

C<curries> 機能も一般化され、C<< handles => HASHREF >>から設定可能となりましたが、現時点ではまだ全ての機能のポートが終わっていません（CODEREFのカリー化は未実装です）

=item C<empty> は C<is_empty> に名称変更し、意味が逆となる

これまではArrayとHash型に設定できたC<empty>メソッドはアトリビュートが「空ではなかった」場合に真を返しました。今後はアトリビュートが空の場合に真を返します。この変更を明示化するために、C<empty>からC<is_empty>に名称が変更されました。

=item C<find> はC<first>に名称変更、C<first> と C<last> は削除

これまでC<find>として提供されていた機能を L<List::Util> は L<first|List::Util/first>として提供しているため、わかりやすくするために名称を統一しました
C<first> と C<last> は C<get>のカリー化で容易に実現可能なため、削除されました。

=item 関数を指定するヘルパーはC<$_>を使用する

C<first>、C<map>、C<grep>の引数を一つだけ受け取る関数は以前のようにC<@_>に引数を受け取るのではなくC<$_>に受け取るようになりました。

一つ以上の関数を受け取る関数はこれまでと同様引数として値を受け取ります。

追加ドキュメントについてはL<Moose::Meta::Attribute::Native> をご覧下さい。

=back

ロール引数の C<alias> と C<excludes> はそれぞれ C<-alias>とC<-excludes>に名称変更されました。これまでの引き数名でも動作しますが、近い将来に削除される予定のため、新規コードは新しい名称を使用するようにしてください。

=head1 バージョン0.89

C<< use Moose -metaclass => 'Foo' >> が C<-traits> (それに C<has>に対するC<metaclass> や C<traits> 引数のように）エイリアスの解決を行うようになりました。

metaclassやmetatraitのエイリアス処理を簡易にするために新関数 C<meta_class_alias> と C<meta_attribute_alias> を L<Moose::Util>に追加しました。これらは以下の旧コードに対するラッパです：

  package Moose::Meta::Class::Custom::Trait::FooTrait;
  sub register_implementation { 'My::Meta::Trait' }

=head1 バージョン 0.84

アトリビュートがI<ひとつも＞アクセサを生成しない場合は警告を発するようになりました。これはC<is>オプションの指定を忘れるユーザーを助けるためです。本当にアクセサを生成したくない場合はC<< is => 'bare' >>を指定してください。以前のMooseとの後方互換お保つには以下のようなコードを指定してください：

    ($Moose::VERSION >= 0.84 ? is => 'bare' : ())

アクセサがすでに存在する同一名のメソッドを上書きしてしまう場合は警告を発するようになりました。本当にこの動作を行いたい場合、アクセサを生成する前に元のメソッドを削除してください：

    sub foo {}

    __PACKAGE__->meta->remove_method('foo');

    has foo => (
        is => 'ro',
    );

C<has>に未知のオプションが渡された場合は警告を発するようになりました。この警告を止めるにはあなたのコードを修正してください :)

C<Role> 型は非推奨化されました。C<< $object->can('does') >>を確認するだけだったため、単体では有用ではありませんでした。カスタム型制約の親として使用していた場合は、C<role_type('Role::Name')>を使用して該当する型を生成してください。

=head1 バージョン0.78

C<use Moose::Exporter;>をしたパッケージにはC<strict>とC<warnings>がインポートされるようになりました。

=head1 バージョン0.77

C<DEMOLISHALL>とC<DEMOLISH>はグローバルなデストラクタを実行中かどうかをあらわす引数を受け取るようになりました。

=head1 バージョン0.76

すでに型制約を満たしている値については型変換が実行されないようになりました。これはC<via>節の副作用に依存している特殊な（バグがあると言ってもよさそうな）型変換に影響を与えるかもしれません。

=head1 バージョン0.75

L<Moose::Exporter>が（L<metaclass>を使わなくても）簡単にメタクラスをオーバーライドできるようにC<-metaclass>オプションを受け付けるようになりました。これはクラスとロールで使えます。

=head1 バージョン0.74

Moose以外のクラスをもっと簡単に統合できるように、L<Moose::Util::TypeConstraints>にC<duck_type>というシュガー関数を追加しました。これは単にC<< $obj->can() >>にメソッドのリストを渡して真を返すかチェックするだけのものです。

多くのメソッドをリネームしました（ほとんどはL<Class::MOP>から継承しているものです。先頭にアンダースコアをつけて、内部用であることを明示しました）。当面は古いメソッドも使えますが、メソッドがリネームされたという警告が出るようになります。いくつかのメソッドについては将来完全に削除する予定です（そのようなメソッドを利用していたMooseXの作者には影響があるかもしれません）。

=head1 バージョン0.73

引数に名前しか渡さずにC<subtype>を呼ぶと、例外を発生するようになりました。無名のサブタイプがほしい場合はこのようにしてください。

    my $subtype = subtype as 'Foo';

これはバージョン0.71_01の変更に関係するものです。

L<Moose::Meta::Method::Destructor>のC<is_needed>メソッドはクラスメソッドとしてしか使えないようになりました（以前はクラスメソッドとしてもオブジェクトメソッドとしても使えましたが、それぞれ内部的な実装は異なっていたのです）。

Class::MOP 0.78_02でクラスを不変化する処理が内部的に大きく変わったのを受けて、Mooseの内部も変更されました。外から見えるC<< $metaclass->make_immutable >>メソッドについては従来通りの動作をします。

=head1 バージョン0.72

可変クラスではC<< Foo->new(undef) >>を文句もいわずに受け入れていました。また、不変化したクラスでは不親切なエラーが出ていました。これからはどちらの場合でも親切なエラーが発生するようになっています。

この「機能」は、もともとはこのようなケースを認めるために追加されたものだったのですが、

  my $args;

  if ( something() ) {
      $args = {...};
  }

  return My::Class->new($args);

このやり方は本当のエラーを簡単に隠蔽できてしまうため、筋が悪いし、いささか魔法も効き過ぎていると判断しました。

=head1 バージョン0.71_01

C<type>やC<subtype>をシュガーヘルパー（C<as>、C<where>、C<message>）なしで呼ぶやり方は廃止されました。

その副作用として、C<as>にはPerlのプロトタイプを使うことになったので、このようなコードは動かなくなります。

  use Moose::Util::TypeConstraints;
  use Declare::Constraints::Simple -All;

  subtype 'ArrayOfInts'
      => as 'ArrayRef'
      => IsArrayRef(IsInt);

これは、このように変更しなければなりません。

  subtype(
      'ArrayOfInts' => {
          as    => 'ArrayRef',
          where => IsArrayRef(IsInt)
      }
  );

古いバージョンのMooseとの後方互換性を維持するには、MooseのC<VERSION>を明示的にテストしなければなりません。

  if ( Moose->VERSION < 0.71_01 ) {
      subtype 'ArrayOfInts'
          => as 'ArrayRef'
          => IsArrayRef(IsInt);
  }
  else {
      subtype(
          'ArrayOfInts' => {
              as    => 'ArrayRef',
              where => IsArrayRef(IsInt)
          }
      );
  }

=head1 バージョン0.70

トリガの最後の引数にメタアトリビュートオブジェクトを渡さないようにしました。実は、インライン展開されたコードの方ではしばらく前からそのように変更されていたのですが、インライン展開していないコードとドキュメントは古いままになっていました。

万一実際にこの機能を利用していた場合の対策は簡単です。このように、トリガの最初の引数として渡されるC<$self>からアトリビュートオブジェクトを取ってください。

  has 'foo' => (
      is      => 'ro',
      isa     => 'Any',
      trigger => sub {
          my ( $self, $value ) = @_;
          my $attr = $self->meta->find_attribute_by_name('foo');

          # ...
      }
  );

=head1 バージョン0.66

サブタイプを作成したとき、Mooseが知らない親クラスを渡すと、その親クラスは単純に無視されていました。いまは自動的にその親クラスのクラス型を作成します。これは期待通りのものではないかもしれませんが、前ほど壊れていません。

以前は「Foo!Bar」のような名前のサブタイプを宣言できました。これは認めるべきなのでしょうが、「ArrayRef[Foo!Bar]」のようなパラメータ付きの型で使うと正しく動作しませんでした。いまはシュガー関数を通じて生成される名前を吟味して、英数字と「:」「.」しか含められないようにしています。

=head1 バージョン0.65

アトリビュート経由で生成されたメソッドもロールのC<requires>を満足させられるようになりました。正直にいって、なぜスティーヴンが最初からそうしていなかったのかはわかりません。まったく、頭がどうかしていたのでしょう。

インライン展開したコードのスタックトレースが、Moose内部ではなく、そのクラスの行やファイルを報告するようになりました。

=head1 バージョン0.62_02

クラスがロールのすべての必須メソッドを用意できなかった場合、エラーメッセージには最初に見つからなかったメソッドだけでなく、見つからなかったすべてのメソッドを載せるようになりました。

Moose::Objectからコンストラクタを継承していないクラスについては、コンストラクタをインライン展開せず、その旨警告するようになりました。とにかくインライン展開を強制したい場合は、C<make_immutable>にC<< replace_constructor => 1 >>を渡してください。

警告を出したくない場合はC<< inline_constructor => 1 >>を渡します。

=head1 バージョン0.62

（廃止済みの）C<make_immutable>キーワードを削除しました。

クラスからアトリビュートを削除すると、そのアトリビュートのためにインストールされていた委譲(C<handles>)メソッドも削除されるようになりました。これは正しい振る舞いですが、間違った振る舞いに依存していた方は痛い目にあうかもしれません。

=head1 バージョン0.58

ロールがメソッドを追加するときはC<alias_method>ではなくC<add_method>を呼ぶようになりました。また、かならずメソッドオブジェクトを提供して内部でクローニングするようになりました。そのため、ロールが提供したメソッドのソースを追跡したり、間にはさまっているロールを含めて履歴を追うこともできるようになっています。また、クラスのメソッドリストやメソッドマップを見るとロールが追加したメソッドも表示されるようになった、ということでもあります。

型制約のパラメータや結合の引数はソートされるようになりました。そのため、Int|Strという制約はStr|Intと同じになります。また、渡される型制約の文字列は正規化されて空白の違いはすべて取り除かれるようになりました。これはもっぱら内部の問題なので、外のコードには影響を与えないはずです。

L<Moose::Exporter>は、エクスポート元のパッケージがエクスポートしなおしたサブルーチンは削除しないようになりました（MooseはCarp::confessなどをエクスポートしなおしています）。L<Moose::Exporter>はユーザが自分で使うために明示的にインポートした関数かどうかを判断できないので、間違ったときには安全が優先されるよう、エクスポートしなおしたサブルーチンは常に残しておくことにしたのです。

=head1 バージョン0.56

C<Moose::init_meta>はメソッドとして呼ぶようになりました。

拡張モジュールの作者向けにL<Moose::Exporter>とL<Moose::Util::MetaRole>という新しいモジュールが追加されました。

=head1 バージョン0.55_01

メタクラスのトレート（と、そのレシピ）が実装されました。

  use Moose -traits => 'Foo'

トレートを使うと、小さな拡張モジュールを書くのが少し楽になります。

=head1 バージョン0.55

C<coerce>を修正して、C<subtype>のように無名の型を受け付けるようにしました。そのため、このようなことができるようになっています。

  coerce $some_anon_type => from 'Str' => via { ... };

=head1 バージョン0.51

C<< Moose::Object->new() >>に新しいステップとしてC<BUILDARGS>を追加しました。

=head1 バージョン0.49

C<reader>やC<writer>、C<accessor>オプションを独自に定義したときのC<< is => (ro|rw) >>の動作を修正しました。詳しくは下の表をご覧ください。

  is => ro, writer => _foo    # turns into (reader => foo, writer => _foo)
  is => rw, writer => _foo    # turns into (reader => foo, writer => _foo)
  is => rw, accessor => _foo  # turns into (accessor => _foo)
  is => ro, accessor => _foo  # error, accesor is rw

=head1 バージョン0.45

C<before/around/after>メソッドモディファイアが正規表現によるメソッド名のマッチングをサポートするようになりました。注意：これはクラスにしか使えません（現時点ではロールはサポートしていませんが……パッチは歓迎です）。

ロールのC<has>キーワードも、クラスの場合と同じ形式の配列リファレンスを受け付けるようになりました。

コンストラクタからトリガを実行できると便利なので、読み取り専用のアトリビュートにトリガを用意してもエラーにはならないようになりました。

パラメータ付きの型のサブタイプはそれ自身がパラメータ指定可能な型になります。

=head1 バージョン0.44

C<DEMOLISHALL>がC<$@>の値を食ってしまうために正しく動作しない問題を修正しました。それでもまだある意味ではC<$@>の値を食っているのですが、これは素のperlの場合も同じです。

=head1 バージョン0.41

継承したアトリビュートは、型が(「isa」や「does」で)制限されていない限り拡張できないようになりました。

このリリースではMoose::Meta::TypeConstraint::*以下のクラスがすべて作り直されました。内部の実装に依存していた場合はコードをよくテストしておいてください。

=head1 バージョン0.40

合成済みのロールに由来するアトリビュートに対して「+name」を使う方法をドキュメント化しました。これは理にかなっていますし、よく使われているものですから、公式にサポートしましょう、ということです。

C<< Moose::Meta::Class->create >>メソッドがロールをサポートするようになりました。

C<< enum $name => @values >>のかわりにC<enum>に配列リファレンスを渡すことで無名のenum型を作ることができるようになりました。

=head1 バージョン0.37

メタオブジェクトのC<make_immutable>を呼ぶためのショートカットとして、C<make_immutable>キーワードを追加しました（これは最終的には削除されました！）。

MooseでC<< init_arg => undef >>できるようになりました。これは「このアトリビュートはコンストラクタのパラメータを受け付けない」という意味です。

型エラーが用意されたエラーメッセージを使うようになりました（このリリースまではそうではありませんでした）。

=head1 バージョン0.34

Mooseはポストモダンなオブジェクトシステムになりました :)

ロールシステムが完全に作り直されました。100%後方互換ですが、内部は完全に変わっていますので、内部の実装に依存していた場合はよくテストしておくことをおすすめします。

ロールのメソッドの排除と別名はこのリリースで追加されました。

L<Moose::Util::TypeConstraints::OptimizedConstraints>モジュールが追加されました。

アクセサに値のリストを渡すと（アクセサが期待している値の数は1つのみです）、以前は黙って無視されていましたが、エラーを発生するようになりました。

=head1 バージョン0.26

パラメータ付きの型が追加されました。また、型制約システムはかなり大幅に作り直されました。

「自前のMooseを作る」ためのフレームワークの拡張性やサポートが強化されました。

=head1 バージョン0.25以前

正直にいって、こんなに古いMooseは使うべきではありません。非常に多くのバグが直っていますし、スピードも速くなっているのですから、アップグレードしないなんて正気の沙汰ではありません。

それに、更新履歴をさかのぼるのにもうんざりしました。だから、ここでおしまいにします。続けたい方がいたらどうぞご自由に。

=head1 作者

Stevan Little E<lt>stevan@iinteractive.comE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2009 by Infinity Interactive, Inc.

L<http://www.iinteractive.com>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

